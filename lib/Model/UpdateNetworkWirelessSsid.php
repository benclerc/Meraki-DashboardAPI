<?php
/**
 * UpdateNetworkWirelessSsid
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Meraki Dashboard API
 *
 * The Cisco Meraki Dashboard API is a modern REST API based on the OpenAPI specification.  > Date: 07 July, 2021 > > [What's New](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com)
 *
 * OpenAPI spec version: 1.11.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.19
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;
use \Swagger\Client\ObjectSerializer;

/**
 * UpdateNetworkWirelessSsid Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class UpdateNetworkWirelessSsid implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'updateNetworkWirelessSsid';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'name' => 'string',
        'enabled' => 'bool',
        'auth_mode' => 'string',
        'enterprise_admin_access' => 'string',
        'encryption_mode' => 'string',
        'psk' => 'string',
        'wpa_encryption_mode' => 'string',
        'dot11w' => '\Swagger\Client\Model\NetworksnetworkIdwirelessssidsnumberDot11w',
        'dot11r' => '\Swagger\Client\Model\NetworksnetworkIdwirelessssidsnumberDot11r',
        'splash_page' => 'string',
        'splash_guest_sponsor_domains' => 'string[]',
        'oauth' => '\Swagger\Client\Model\NetworksnetworkIdwirelessssidsnumberOauth',
        'local_radius' => '\Swagger\Client\Model\NetworksnetworkIdwirelessssidsnumberLocalRadius',
        'ldap' => '\Swagger\Client\Model\NetworksnetworkIdwirelessssidsnumberLdap',
        'active_directory' => '\Swagger\Client\Model\NetworksnetworkIdwirelessssidsnumberActiveDirectory',
        'radius_servers' => '\Swagger\Client\Model\NetworksnetworkIdwirelessssidsnumberRadiusServers[]',
        'radius_proxy_enabled' => 'bool',
        'radius_testing_enabled' => 'bool',
        'radius_called_station_id' => 'string',
        'radius_authentication_nas_id' => 'string',
        'radius_server_timeout' => 'int',
        'radius_server_attempts_limit' => 'int',
        'radius_fallback_enabled' => 'bool',
        'radius_coa_enabled' => 'bool',
        'radius_failover_policy' => 'string',
        'radius_load_balancing_policy' => 'string',
        'radius_accounting_enabled' => 'bool',
        'radius_accounting_servers' => '\Swagger\Client\Model\NetworksnetworkIdwirelessssidsnumberRadiusAccountingServers[]',
        'radius_accounting_interim_interval' => 'int',
        'radius_attribute_for_group_policies' => 'string',
        'ip_assignment_mode' => 'string',
        'use_vlan_tagging' => 'bool',
        'concentrator_network_id' => 'string',
        'vlan_id' => 'int',
        'default_vlan_id' => 'int',
        'ap_tags_and_vlan_ids' => '\Swagger\Client\Model\NetworksnetworkIdwirelessssidsnumberApTagsAndVlanIds[]',
        'walled_garden_enabled' => 'bool',
        'walled_garden_ranges' => 'string[]',
        'radius_override' => 'bool',
        'radius_guest_vlan_enabled' => 'bool',
        'radius_guest_vlan_id' => 'int',
        'min_bitrate' => 'float',
        'band_selection' => 'string',
        'per_client_bandwidth_limit_up' => 'int',
        'per_client_bandwidth_limit_down' => 'int',
        'per_ssid_bandwidth_limit_up' => 'int',
        'per_ssid_bandwidth_limit_down' => 'int',
        'lan_isolation_enabled' => 'bool',
        'visible' => 'bool',
        'available_on_all_aps' => 'bool',
        'availability_tags' => 'string[]',
        'mandatory_dhcp_enabled' => 'bool',
        'adult_content_filtering_enabled' => 'bool',
        'dns_rewrite' => '\Swagger\Client\Model\NetworksnetworkIdwirelessssidsnumberDnsRewrite'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'name' => null,
        'enabled' => null,
        'auth_mode' => null,
        'enterprise_admin_access' => null,
        'encryption_mode' => null,
        'psk' => null,
        'wpa_encryption_mode' => null,
        'dot11w' => null,
        'dot11r' => null,
        'splash_page' => null,
        'splash_guest_sponsor_domains' => null,
        'oauth' => null,
        'local_radius' => null,
        'ldap' => null,
        'active_directory' => null,
        'radius_servers' => null,
        'radius_proxy_enabled' => null,
        'radius_testing_enabled' => null,
        'radius_called_station_id' => null,
        'radius_authentication_nas_id' => null,
        'radius_server_timeout' => null,
        'radius_server_attempts_limit' => null,
        'radius_fallback_enabled' => null,
        'radius_coa_enabled' => null,
        'radius_failover_policy' => null,
        'radius_load_balancing_policy' => null,
        'radius_accounting_enabled' => null,
        'radius_accounting_servers' => null,
        'radius_accounting_interim_interval' => null,
        'radius_attribute_for_group_policies' => null,
        'ip_assignment_mode' => null,
        'use_vlan_tagging' => null,
        'concentrator_network_id' => null,
        'vlan_id' => null,
        'default_vlan_id' => null,
        'ap_tags_and_vlan_ids' => null,
        'walled_garden_enabled' => null,
        'walled_garden_ranges' => null,
        'radius_override' => null,
        'radius_guest_vlan_enabled' => null,
        'radius_guest_vlan_id' => null,
        'min_bitrate' => 'float',
        'band_selection' => null,
        'per_client_bandwidth_limit_up' => null,
        'per_client_bandwidth_limit_down' => null,
        'per_ssid_bandwidth_limit_up' => null,
        'per_ssid_bandwidth_limit_down' => null,
        'lan_isolation_enabled' => null,
        'visible' => null,
        'available_on_all_aps' => null,
        'availability_tags' => null,
        'mandatory_dhcp_enabled' => null,
        'adult_content_filtering_enabled' => null,
        'dns_rewrite' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'name' => 'name',
        'enabled' => 'enabled',
        'auth_mode' => 'authMode',
        'enterprise_admin_access' => 'enterpriseAdminAccess',
        'encryption_mode' => 'encryptionMode',
        'psk' => 'psk',
        'wpa_encryption_mode' => 'wpaEncryptionMode',
        'dot11w' => 'dot11w',
        'dot11r' => 'dot11r',
        'splash_page' => 'splashPage',
        'splash_guest_sponsor_domains' => 'splashGuestSponsorDomains',
        'oauth' => 'oauth',
        'local_radius' => 'localRadius',
        'ldap' => 'ldap',
        'active_directory' => 'activeDirectory',
        'radius_servers' => 'radiusServers',
        'radius_proxy_enabled' => 'radiusProxyEnabled',
        'radius_testing_enabled' => 'radiusTestingEnabled',
        'radius_called_station_id' => 'radiusCalledStationId',
        'radius_authentication_nas_id' => 'radiusAuthenticationNasId',
        'radius_server_timeout' => 'radiusServerTimeout',
        'radius_server_attempts_limit' => 'radiusServerAttemptsLimit',
        'radius_fallback_enabled' => 'radiusFallbackEnabled',
        'radius_coa_enabled' => 'radiusCoaEnabled',
        'radius_failover_policy' => 'radiusFailoverPolicy',
        'radius_load_balancing_policy' => 'radiusLoadBalancingPolicy',
        'radius_accounting_enabled' => 'radiusAccountingEnabled',
        'radius_accounting_servers' => 'radiusAccountingServers',
        'radius_accounting_interim_interval' => 'radiusAccountingInterimInterval',
        'radius_attribute_for_group_policies' => 'radiusAttributeForGroupPolicies',
        'ip_assignment_mode' => 'ipAssignmentMode',
        'use_vlan_tagging' => 'useVlanTagging',
        'concentrator_network_id' => 'concentratorNetworkId',
        'vlan_id' => 'vlanId',
        'default_vlan_id' => 'defaultVlanId',
        'ap_tags_and_vlan_ids' => 'apTagsAndVlanIds',
        'walled_garden_enabled' => 'walledGardenEnabled',
        'walled_garden_ranges' => 'walledGardenRanges',
        'radius_override' => 'radiusOverride',
        'radius_guest_vlan_enabled' => 'radiusGuestVlanEnabled',
        'radius_guest_vlan_id' => 'radiusGuestVlanId',
        'min_bitrate' => 'minBitrate',
        'band_selection' => 'bandSelection',
        'per_client_bandwidth_limit_up' => 'perClientBandwidthLimitUp',
        'per_client_bandwidth_limit_down' => 'perClientBandwidthLimitDown',
        'per_ssid_bandwidth_limit_up' => 'perSsidBandwidthLimitUp',
        'per_ssid_bandwidth_limit_down' => 'perSsidBandwidthLimitDown',
        'lan_isolation_enabled' => 'lanIsolationEnabled',
        'visible' => 'visible',
        'available_on_all_aps' => 'availableOnAllAps',
        'availability_tags' => 'availabilityTags',
        'mandatory_dhcp_enabled' => 'mandatoryDhcpEnabled',
        'adult_content_filtering_enabled' => 'adultContentFilteringEnabled',
        'dns_rewrite' => 'dnsRewrite'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'name' => 'setName',
        'enabled' => 'setEnabled',
        'auth_mode' => 'setAuthMode',
        'enterprise_admin_access' => 'setEnterpriseAdminAccess',
        'encryption_mode' => 'setEncryptionMode',
        'psk' => 'setPsk',
        'wpa_encryption_mode' => 'setWpaEncryptionMode',
        'dot11w' => 'setDot11w',
        'dot11r' => 'setDot11r',
        'splash_page' => 'setSplashPage',
        'splash_guest_sponsor_domains' => 'setSplashGuestSponsorDomains',
        'oauth' => 'setOauth',
        'local_radius' => 'setLocalRadius',
        'ldap' => 'setLdap',
        'active_directory' => 'setActiveDirectory',
        'radius_servers' => 'setRadiusServers',
        'radius_proxy_enabled' => 'setRadiusProxyEnabled',
        'radius_testing_enabled' => 'setRadiusTestingEnabled',
        'radius_called_station_id' => 'setRadiusCalledStationId',
        'radius_authentication_nas_id' => 'setRadiusAuthenticationNasId',
        'radius_server_timeout' => 'setRadiusServerTimeout',
        'radius_server_attempts_limit' => 'setRadiusServerAttemptsLimit',
        'radius_fallback_enabled' => 'setRadiusFallbackEnabled',
        'radius_coa_enabled' => 'setRadiusCoaEnabled',
        'radius_failover_policy' => 'setRadiusFailoverPolicy',
        'radius_load_balancing_policy' => 'setRadiusLoadBalancingPolicy',
        'radius_accounting_enabled' => 'setRadiusAccountingEnabled',
        'radius_accounting_servers' => 'setRadiusAccountingServers',
        'radius_accounting_interim_interval' => 'setRadiusAccountingInterimInterval',
        'radius_attribute_for_group_policies' => 'setRadiusAttributeForGroupPolicies',
        'ip_assignment_mode' => 'setIpAssignmentMode',
        'use_vlan_tagging' => 'setUseVlanTagging',
        'concentrator_network_id' => 'setConcentratorNetworkId',
        'vlan_id' => 'setVlanId',
        'default_vlan_id' => 'setDefaultVlanId',
        'ap_tags_and_vlan_ids' => 'setApTagsAndVlanIds',
        'walled_garden_enabled' => 'setWalledGardenEnabled',
        'walled_garden_ranges' => 'setWalledGardenRanges',
        'radius_override' => 'setRadiusOverride',
        'radius_guest_vlan_enabled' => 'setRadiusGuestVlanEnabled',
        'radius_guest_vlan_id' => 'setRadiusGuestVlanId',
        'min_bitrate' => 'setMinBitrate',
        'band_selection' => 'setBandSelection',
        'per_client_bandwidth_limit_up' => 'setPerClientBandwidthLimitUp',
        'per_client_bandwidth_limit_down' => 'setPerClientBandwidthLimitDown',
        'per_ssid_bandwidth_limit_up' => 'setPerSsidBandwidthLimitUp',
        'per_ssid_bandwidth_limit_down' => 'setPerSsidBandwidthLimitDown',
        'lan_isolation_enabled' => 'setLanIsolationEnabled',
        'visible' => 'setVisible',
        'available_on_all_aps' => 'setAvailableOnAllAps',
        'availability_tags' => 'setAvailabilityTags',
        'mandatory_dhcp_enabled' => 'setMandatoryDhcpEnabled',
        'adult_content_filtering_enabled' => 'setAdultContentFilteringEnabled',
        'dns_rewrite' => 'setDnsRewrite'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'name' => 'getName',
        'enabled' => 'getEnabled',
        'auth_mode' => 'getAuthMode',
        'enterprise_admin_access' => 'getEnterpriseAdminAccess',
        'encryption_mode' => 'getEncryptionMode',
        'psk' => 'getPsk',
        'wpa_encryption_mode' => 'getWpaEncryptionMode',
        'dot11w' => 'getDot11w',
        'dot11r' => 'getDot11r',
        'splash_page' => 'getSplashPage',
        'splash_guest_sponsor_domains' => 'getSplashGuestSponsorDomains',
        'oauth' => 'getOauth',
        'local_radius' => 'getLocalRadius',
        'ldap' => 'getLdap',
        'active_directory' => 'getActiveDirectory',
        'radius_servers' => 'getRadiusServers',
        'radius_proxy_enabled' => 'getRadiusProxyEnabled',
        'radius_testing_enabled' => 'getRadiusTestingEnabled',
        'radius_called_station_id' => 'getRadiusCalledStationId',
        'radius_authentication_nas_id' => 'getRadiusAuthenticationNasId',
        'radius_server_timeout' => 'getRadiusServerTimeout',
        'radius_server_attempts_limit' => 'getRadiusServerAttemptsLimit',
        'radius_fallback_enabled' => 'getRadiusFallbackEnabled',
        'radius_coa_enabled' => 'getRadiusCoaEnabled',
        'radius_failover_policy' => 'getRadiusFailoverPolicy',
        'radius_load_balancing_policy' => 'getRadiusLoadBalancingPolicy',
        'radius_accounting_enabled' => 'getRadiusAccountingEnabled',
        'radius_accounting_servers' => 'getRadiusAccountingServers',
        'radius_accounting_interim_interval' => 'getRadiusAccountingInterimInterval',
        'radius_attribute_for_group_policies' => 'getRadiusAttributeForGroupPolicies',
        'ip_assignment_mode' => 'getIpAssignmentMode',
        'use_vlan_tagging' => 'getUseVlanTagging',
        'concentrator_network_id' => 'getConcentratorNetworkId',
        'vlan_id' => 'getVlanId',
        'default_vlan_id' => 'getDefaultVlanId',
        'ap_tags_and_vlan_ids' => 'getApTagsAndVlanIds',
        'walled_garden_enabled' => 'getWalledGardenEnabled',
        'walled_garden_ranges' => 'getWalledGardenRanges',
        'radius_override' => 'getRadiusOverride',
        'radius_guest_vlan_enabled' => 'getRadiusGuestVlanEnabled',
        'radius_guest_vlan_id' => 'getRadiusGuestVlanId',
        'min_bitrate' => 'getMinBitrate',
        'band_selection' => 'getBandSelection',
        'per_client_bandwidth_limit_up' => 'getPerClientBandwidthLimitUp',
        'per_client_bandwidth_limit_down' => 'getPerClientBandwidthLimitDown',
        'per_ssid_bandwidth_limit_up' => 'getPerSsidBandwidthLimitUp',
        'per_ssid_bandwidth_limit_down' => 'getPerSsidBandwidthLimitDown',
        'lan_isolation_enabled' => 'getLanIsolationEnabled',
        'visible' => 'getVisible',
        'available_on_all_aps' => 'getAvailableOnAllAps',
        'availability_tags' => 'getAvailabilityTags',
        'mandatory_dhcp_enabled' => 'getMandatoryDhcpEnabled',
        'adult_content_filtering_enabled' => 'getAdultContentFilteringEnabled',
        'dns_rewrite' => 'getDnsRewrite'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const AUTH_MODE_OPEN = 'open';
    const AUTH_MODE_PSK = 'psk';
    const AUTH_MODE_OPEN_WITH_RADIUS = 'open-with-radius';
    const AUTH_MODE__8021X_MERAKI = '8021x-meraki';
    const AUTH_MODE__8021X_RADIUS = '8021x-radius';
    const AUTH_MODE__8021X_GOOGLE = '8021x-google';
    const AUTH_MODE__8021X_LOCALRADIUS = '8021x-localradius';
    const AUTH_MODE_IPSK_WITH_RADIUS = 'ipsk-with-radius';
    const AUTH_MODE_IPSK_WITHOUT_RADIUS = 'ipsk-without-radius';
    const ENTERPRISE_ADMIN_ACCESS_DISABLED = 'access disabled';
    const ENTERPRISE_ADMIN_ACCESS_ENABLED = 'access enabled';
    const ENCRYPTION_MODE_WEP = 'wep';
    const ENCRYPTION_MODE_WPA = 'wpa';
    const WPA_ENCRYPTION_MODE_WPA1_ONLY = 'WPA1 only';
    const WPA_ENCRYPTION_MODE_WPA1_AND_WPA2 = 'WPA1 and WPA2';
    const WPA_ENCRYPTION_MODE_WPA2_ONLY = 'WPA2 only';
    const WPA_ENCRYPTION_MODE_WPA3_TRANSITION_MODE = 'WPA3 Transition Mode';
    const WPA_ENCRYPTION_MODE_WPA3_ONLY = 'WPA3 only';
    const SPLASH_PAGE_NONE = 'None';
    const SPLASH_PAGE_CLICK_THROUGH_SPLASH_PAGE = 'Click-through splash page';
    const SPLASH_PAGE_BILLING = 'Billing';
    const SPLASH_PAGE_PASSWORD_PROTECTED_WITH_MERAKI_RADIUS = 'Password-protected with Meraki RADIUS';
    const SPLASH_PAGE_PASSWORD_PROTECTED_WITH_CUSTOM_RADIUS = 'Password-protected with custom RADIUS';
    const SPLASH_PAGE_PASSWORD_PROTECTED_WITH_ACTIVE_DIRECTORY = 'Password-protected with Active Directory';
    const SPLASH_PAGE_PASSWORD_PROTECTED_WITH_LDAP = 'Password-protected with LDAP';
    const SPLASH_PAGE_SMS_AUTHENTICATION = 'SMS authentication';
    const SPLASH_PAGE_SYSTEMS_MANAGER_SENTRY = 'Systems Manager Sentry';
    const SPLASH_PAGE_FACEBOOK_WI_FI = 'Facebook Wi-Fi';
    const SPLASH_PAGE_GOOGLE_O_AUTH = 'Google OAuth';
    const SPLASH_PAGE_SPONSORED_GUEST = 'Sponsored guest';
    const SPLASH_PAGE_CISCO_ISE = 'Cisco ISE';
    const SPLASH_PAGE_GOOGLE_APPS_DOMAIN = 'Google Apps domain';
    const RADIUS_FAILOVER_POLICY_DENY_ACCESS = 'Deny access';
    const RADIUS_FAILOVER_POLICY_ALLOW_ACCESS = 'Allow access';
    const RADIUS_LOAD_BALANCING_POLICY_STRICT_PRIORITY_ORDER = 'Strict priority order';
    const RADIUS_LOAD_BALANCING_POLICY_ROUND_ROBIN = 'Round robin';
    const RADIUS_ATTRIBUTE_FOR_GROUP_POLICIES_FILTER_ID = 'Filter-Id';
    const RADIUS_ATTRIBUTE_FOR_GROUP_POLICIES_REPLY_MESSAGE = 'Reply-Message';
    const RADIUS_ATTRIBUTE_FOR_GROUP_POLICIES_AIRESPACE_ACL_NAME = 'Airespace-ACL-Name';
    const RADIUS_ATTRIBUTE_FOR_GROUP_POLICIES_ARUBA_USER_ROLE = 'Aruba-User-Role';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAuthModeAllowableValues()
    {
        return [
            self::AUTH_MODE_OPEN,
            self::AUTH_MODE_PSK,
            self::AUTH_MODE_OPEN_WITH_RADIUS,
            self::AUTH_MODE__8021X_MERAKI,
            self::AUTH_MODE__8021X_RADIUS,
            self::AUTH_MODE__8021X_GOOGLE,
            self::AUTH_MODE__8021X_LOCALRADIUS,
            self::AUTH_MODE_IPSK_WITH_RADIUS,
            self::AUTH_MODE_IPSK_WITHOUT_RADIUS,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getEnterpriseAdminAccessAllowableValues()
    {
        return [
            self::ENTERPRISE_ADMIN_ACCESS_DISABLED,
            self::ENTERPRISE_ADMIN_ACCESS_ENABLED,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getEncryptionModeAllowableValues()
    {
        return [
            self::ENCRYPTION_MODE_WEP,
            self::ENCRYPTION_MODE_WPA,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getWpaEncryptionModeAllowableValues()
    {
        return [
            self::WPA_ENCRYPTION_MODE_WPA1_ONLY,
            self::WPA_ENCRYPTION_MODE_WPA1_AND_WPA2,
            self::WPA_ENCRYPTION_MODE_WPA2_ONLY,
            self::WPA_ENCRYPTION_MODE_WPA3_TRANSITION_MODE,
            self::WPA_ENCRYPTION_MODE_WPA3_ONLY,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSplashPageAllowableValues()
    {
        return [
            self::SPLASH_PAGE_NONE,
            self::SPLASH_PAGE_CLICK_THROUGH_SPLASH_PAGE,
            self::SPLASH_PAGE_BILLING,
            self::SPLASH_PAGE_PASSWORD_PROTECTED_WITH_MERAKI_RADIUS,
            self::SPLASH_PAGE_PASSWORD_PROTECTED_WITH_CUSTOM_RADIUS,
            self::SPLASH_PAGE_PASSWORD_PROTECTED_WITH_ACTIVE_DIRECTORY,
            self::SPLASH_PAGE_PASSWORD_PROTECTED_WITH_LDAP,
            self::SPLASH_PAGE_SMS_AUTHENTICATION,
            self::SPLASH_PAGE_SYSTEMS_MANAGER_SENTRY,
            self::SPLASH_PAGE_FACEBOOK_WI_FI,
            self::SPLASH_PAGE_GOOGLE_O_AUTH,
            self::SPLASH_PAGE_SPONSORED_GUEST,
            self::SPLASH_PAGE_CISCO_ISE,
            self::SPLASH_PAGE_GOOGLE_APPS_DOMAIN,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getRadiusFailoverPolicyAllowableValues()
    {
        return [
            self::RADIUS_FAILOVER_POLICY_DENY_ACCESS,
            self::RADIUS_FAILOVER_POLICY_ALLOW_ACCESS,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getRadiusLoadBalancingPolicyAllowableValues()
    {
        return [
            self::RADIUS_LOAD_BALANCING_POLICY_STRICT_PRIORITY_ORDER,
            self::RADIUS_LOAD_BALANCING_POLICY_ROUND_ROBIN,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getRadiusAttributeForGroupPoliciesAllowableValues()
    {
        return [
            self::RADIUS_ATTRIBUTE_FOR_GROUP_POLICIES_FILTER_ID,
            self::RADIUS_ATTRIBUTE_FOR_GROUP_POLICIES_REPLY_MESSAGE,
            self::RADIUS_ATTRIBUTE_FOR_GROUP_POLICIES_AIRESPACE_ACL_NAME,
            self::RADIUS_ATTRIBUTE_FOR_GROUP_POLICIES_ARUBA_USER_ROLE,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['name'] = isset($data['name']) ? $data['name'] : null;
        $this->container['enabled'] = isset($data['enabled']) ? $data['enabled'] : null;
        $this->container['auth_mode'] = isset($data['auth_mode']) ? $data['auth_mode'] : null;
        $this->container['enterprise_admin_access'] = isset($data['enterprise_admin_access']) ? $data['enterprise_admin_access'] : null;
        $this->container['encryption_mode'] = isset($data['encryption_mode']) ? $data['encryption_mode'] : null;
        $this->container['psk'] = isset($data['psk']) ? $data['psk'] : null;
        $this->container['wpa_encryption_mode'] = isset($data['wpa_encryption_mode']) ? $data['wpa_encryption_mode'] : null;
        $this->container['dot11w'] = isset($data['dot11w']) ? $data['dot11w'] : null;
        $this->container['dot11r'] = isset($data['dot11r']) ? $data['dot11r'] : null;
        $this->container['splash_page'] = isset($data['splash_page']) ? $data['splash_page'] : null;
        $this->container['splash_guest_sponsor_domains'] = isset($data['splash_guest_sponsor_domains']) ? $data['splash_guest_sponsor_domains'] : null;
        $this->container['oauth'] = isset($data['oauth']) ? $data['oauth'] : null;
        $this->container['local_radius'] = isset($data['local_radius']) ? $data['local_radius'] : null;
        $this->container['ldap'] = isset($data['ldap']) ? $data['ldap'] : null;
        $this->container['active_directory'] = isset($data['active_directory']) ? $data['active_directory'] : null;
        $this->container['radius_servers'] = isset($data['radius_servers']) ? $data['radius_servers'] : null;
        $this->container['radius_proxy_enabled'] = isset($data['radius_proxy_enabled']) ? $data['radius_proxy_enabled'] : null;
        $this->container['radius_testing_enabled'] = isset($data['radius_testing_enabled']) ? $data['radius_testing_enabled'] : null;
        $this->container['radius_called_station_id'] = isset($data['radius_called_station_id']) ? $data['radius_called_station_id'] : null;
        $this->container['radius_authentication_nas_id'] = isset($data['radius_authentication_nas_id']) ? $data['radius_authentication_nas_id'] : null;
        $this->container['radius_server_timeout'] = isset($data['radius_server_timeout']) ? $data['radius_server_timeout'] : null;
        $this->container['radius_server_attempts_limit'] = isset($data['radius_server_attempts_limit']) ? $data['radius_server_attempts_limit'] : null;
        $this->container['radius_fallback_enabled'] = isset($data['radius_fallback_enabled']) ? $data['radius_fallback_enabled'] : null;
        $this->container['radius_coa_enabled'] = isset($data['radius_coa_enabled']) ? $data['radius_coa_enabled'] : null;
        $this->container['radius_failover_policy'] = isset($data['radius_failover_policy']) ? $data['radius_failover_policy'] : null;
        $this->container['radius_load_balancing_policy'] = isset($data['radius_load_balancing_policy']) ? $data['radius_load_balancing_policy'] : null;
        $this->container['radius_accounting_enabled'] = isset($data['radius_accounting_enabled']) ? $data['radius_accounting_enabled'] : null;
        $this->container['radius_accounting_servers'] = isset($data['radius_accounting_servers']) ? $data['radius_accounting_servers'] : null;
        $this->container['radius_accounting_interim_interval'] = isset($data['radius_accounting_interim_interval']) ? $data['radius_accounting_interim_interval'] : null;
        $this->container['radius_attribute_for_group_policies'] = isset($data['radius_attribute_for_group_policies']) ? $data['radius_attribute_for_group_policies'] : null;
        $this->container['ip_assignment_mode'] = isset($data['ip_assignment_mode']) ? $data['ip_assignment_mode'] : null;
        $this->container['use_vlan_tagging'] = isset($data['use_vlan_tagging']) ? $data['use_vlan_tagging'] : null;
        $this->container['concentrator_network_id'] = isset($data['concentrator_network_id']) ? $data['concentrator_network_id'] : null;
        $this->container['vlan_id'] = isset($data['vlan_id']) ? $data['vlan_id'] : null;
        $this->container['default_vlan_id'] = isset($data['default_vlan_id']) ? $data['default_vlan_id'] : null;
        $this->container['ap_tags_and_vlan_ids'] = isset($data['ap_tags_and_vlan_ids']) ? $data['ap_tags_and_vlan_ids'] : null;
        $this->container['walled_garden_enabled'] = isset($data['walled_garden_enabled']) ? $data['walled_garden_enabled'] : null;
        $this->container['walled_garden_ranges'] = isset($data['walled_garden_ranges']) ? $data['walled_garden_ranges'] : null;
        $this->container['radius_override'] = isset($data['radius_override']) ? $data['radius_override'] : null;
        $this->container['radius_guest_vlan_enabled'] = isset($data['radius_guest_vlan_enabled']) ? $data['radius_guest_vlan_enabled'] : null;
        $this->container['radius_guest_vlan_id'] = isset($data['radius_guest_vlan_id']) ? $data['radius_guest_vlan_id'] : null;
        $this->container['min_bitrate'] = isset($data['min_bitrate']) ? $data['min_bitrate'] : null;
        $this->container['band_selection'] = isset($data['band_selection']) ? $data['band_selection'] : null;
        $this->container['per_client_bandwidth_limit_up'] = isset($data['per_client_bandwidth_limit_up']) ? $data['per_client_bandwidth_limit_up'] : null;
        $this->container['per_client_bandwidth_limit_down'] = isset($data['per_client_bandwidth_limit_down']) ? $data['per_client_bandwidth_limit_down'] : null;
        $this->container['per_ssid_bandwidth_limit_up'] = isset($data['per_ssid_bandwidth_limit_up']) ? $data['per_ssid_bandwidth_limit_up'] : null;
        $this->container['per_ssid_bandwidth_limit_down'] = isset($data['per_ssid_bandwidth_limit_down']) ? $data['per_ssid_bandwidth_limit_down'] : null;
        $this->container['lan_isolation_enabled'] = isset($data['lan_isolation_enabled']) ? $data['lan_isolation_enabled'] : null;
        $this->container['visible'] = isset($data['visible']) ? $data['visible'] : null;
        $this->container['available_on_all_aps'] = isset($data['available_on_all_aps']) ? $data['available_on_all_aps'] : null;
        $this->container['availability_tags'] = isset($data['availability_tags']) ? $data['availability_tags'] : null;
        $this->container['mandatory_dhcp_enabled'] = isset($data['mandatory_dhcp_enabled']) ? $data['mandatory_dhcp_enabled'] : null;
        $this->container['adult_content_filtering_enabled'] = isset($data['adult_content_filtering_enabled']) ? $data['adult_content_filtering_enabled'] : null;
        $this->container['dns_rewrite'] = isset($data['dns_rewrite']) ? $data['dns_rewrite'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getAuthModeAllowableValues();
        if (!is_null($this->container['auth_mode']) && !in_array($this->container['auth_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'auth_mode', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getEnterpriseAdminAccessAllowableValues();
        if (!is_null($this->container['enterprise_admin_access']) && !in_array($this->container['enterprise_admin_access'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'enterprise_admin_access', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getEncryptionModeAllowableValues();
        if (!is_null($this->container['encryption_mode']) && !in_array($this->container['encryption_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'encryption_mode', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getWpaEncryptionModeAllowableValues();
        if (!is_null($this->container['wpa_encryption_mode']) && !in_array($this->container['wpa_encryption_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'wpa_encryption_mode', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getSplashPageAllowableValues();
        if (!is_null($this->container['splash_page']) && !in_array($this->container['splash_page'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'splash_page', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getRadiusFailoverPolicyAllowableValues();
        if (!is_null($this->container['radius_failover_policy']) && !in_array($this->container['radius_failover_policy'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'radius_failover_policy', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getRadiusLoadBalancingPolicyAllowableValues();
        if (!is_null($this->container['radius_load_balancing_policy']) && !in_array($this->container['radius_load_balancing_policy'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'radius_load_balancing_policy', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getRadiusAttributeForGroupPoliciesAllowableValues();
        if (!is_null($this->container['radius_attribute_for_group_policies']) && !in_array($this->container['radius_attribute_for_group_policies'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'radius_attribute_for_group_policies', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets name
     *
     * @return string
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string $name The name of the SSID
     *
     * @return $this
     */
    public function setName($name)
    {
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets enabled
     *
     * @return bool
     */
    public function getEnabled()
    {
        return $this->container['enabled'];
    }

    /**
     * Sets enabled
     *
     * @param bool $enabled Whether or not the SSID is enabled
     *
     * @return $this
     */
    public function setEnabled($enabled)
    {
        $this->container['enabled'] = $enabled;

        return $this;
    }

    /**
     * Gets auth_mode
     *
     * @return string
     */
    public function getAuthMode()
    {
        return $this->container['auth_mode'];
    }

    /**
     * Sets auth_mode
     *
     * @param string $auth_mode The association control method for the SSID ('open', 'psk', 'open-with-radius', '8021x-meraki', '8021x-radius', '8021x-google', '8021x-localradius', 'ipsk-with-radius' or 'ipsk-without-radius')
     *
     * @return $this
     */
    public function setAuthMode($auth_mode)
    {
        $allowedValues = $this->getAuthModeAllowableValues();
        if (!is_null($auth_mode) && !in_array($auth_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'auth_mode', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['auth_mode'] = $auth_mode;

        return $this;
    }

    /**
     * Gets enterprise_admin_access
     *
     * @return string
     */
    public function getEnterpriseAdminAccess()
    {
        return $this->container['enterprise_admin_access'];
    }

    /**
     * Sets enterprise_admin_access
     *
     * @param string $enterprise_admin_access Whether or not an SSID is accessible by 'enterprise' administrators ('access disabled' or 'access enabled')
     *
     * @return $this
     */
    public function setEnterpriseAdminAccess($enterprise_admin_access)
    {
        $allowedValues = $this->getEnterpriseAdminAccessAllowableValues();
        if (!is_null($enterprise_admin_access) && !in_array($enterprise_admin_access, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'enterprise_admin_access', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['enterprise_admin_access'] = $enterprise_admin_access;

        return $this;
    }

    /**
     * Gets encryption_mode
     *
     * @return string
     */
    public function getEncryptionMode()
    {
        return $this->container['encryption_mode'];
    }

    /**
     * Sets encryption_mode
     *
     * @param string $encryption_mode The psk encryption mode for the SSID ('wep' or 'wpa'). This param is only valid if the authMode is 'psk'
     *
     * @return $this
     */
    public function setEncryptionMode($encryption_mode)
    {
        $allowedValues = $this->getEncryptionModeAllowableValues();
        if (!is_null($encryption_mode) && !in_array($encryption_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'encryption_mode', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['encryption_mode'] = $encryption_mode;

        return $this;
    }

    /**
     * Gets psk
     *
     * @return string
     */
    public function getPsk()
    {
        return $this->container['psk'];
    }

    /**
     * Sets psk
     *
     * @param string $psk The passkey for the SSID. This param is only valid if the authMode is 'psk'
     *
     * @return $this
     */
    public function setPsk($psk)
    {
        $this->container['psk'] = $psk;

        return $this;
    }

    /**
     * Gets wpa_encryption_mode
     *
     * @return string
     */
    public function getWpaEncryptionMode()
    {
        return $this->container['wpa_encryption_mode'];
    }

    /**
     * Sets wpa_encryption_mode
     *
     * @param string $wpa_encryption_mode The types of WPA encryption. ('WPA1 only', 'WPA1 and WPA2', 'WPA2 only', 'WPA3 Transition Mode' or 'WPA3 only')
     *
     * @return $this
     */
    public function setWpaEncryptionMode($wpa_encryption_mode)
    {
        $allowedValues = $this->getWpaEncryptionModeAllowableValues();
        if (!is_null($wpa_encryption_mode) && !in_array($wpa_encryption_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'wpa_encryption_mode', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['wpa_encryption_mode'] = $wpa_encryption_mode;

        return $this;
    }

    /**
     * Gets dot11w
     *
     * @return \Swagger\Client\Model\NetworksnetworkIdwirelessssidsnumberDot11w
     */
    public function getDot11w()
    {
        return $this->container['dot11w'];
    }

    /**
     * Sets dot11w
     *
     * @param \Swagger\Client\Model\NetworksnetworkIdwirelessssidsnumberDot11w $dot11w dot11w
     *
     * @return $this
     */
    public function setDot11w($dot11w)
    {
        $this->container['dot11w'] = $dot11w;

        return $this;
    }

    /**
     * Gets dot11r
     *
     * @return \Swagger\Client\Model\NetworksnetworkIdwirelessssidsnumberDot11r
     */
    public function getDot11r()
    {
        return $this->container['dot11r'];
    }

    /**
     * Sets dot11r
     *
     * @param \Swagger\Client\Model\NetworksnetworkIdwirelessssidsnumberDot11r $dot11r dot11r
     *
     * @return $this
     */
    public function setDot11r($dot11r)
    {
        $this->container['dot11r'] = $dot11r;

        return $this;
    }

    /**
     * Gets splash_page
     *
     * @return string
     */
    public function getSplashPage()
    {
        return $this->container['splash_page'];
    }

    /**
     * Sets splash_page
     *
     * @param string $splash_page The type of splash page for the SSID ('None', 'Click-through splash page', 'Billing', 'Password-protected with Meraki RADIUS', 'Password-protected with custom RADIUS', 'Password-protected with Active Directory', 'Password-protected with LDAP', 'SMS authentication', 'Systems Manager Sentry', 'Facebook Wi-Fi', 'Google OAuth', 'Sponsored guest', 'Cisco ISE' or 'Google Apps domain'). This attribute is not supported for template children.
     *
     * @return $this
     */
    public function setSplashPage($splash_page)
    {
        $allowedValues = $this->getSplashPageAllowableValues();
        if (!is_null($splash_page) && !in_array($splash_page, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'splash_page', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['splash_page'] = $splash_page;

        return $this;
    }

    /**
     * Gets splash_guest_sponsor_domains
     *
     * @return string[]
     */
    public function getSplashGuestSponsorDomains()
    {
        return $this->container['splash_guest_sponsor_domains'];
    }

    /**
     * Sets splash_guest_sponsor_domains
     *
     * @param string[] $splash_guest_sponsor_domains Array of valid sponsor email domains for sponsored guest splash type.
     *
     * @return $this
     */
    public function setSplashGuestSponsorDomains($splash_guest_sponsor_domains)
    {
        $this->container['splash_guest_sponsor_domains'] = $splash_guest_sponsor_domains;

        return $this;
    }

    /**
     * Gets oauth
     *
     * @return \Swagger\Client\Model\NetworksnetworkIdwirelessssidsnumberOauth
     */
    public function getOauth()
    {
        return $this->container['oauth'];
    }

    /**
     * Sets oauth
     *
     * @param \Swagger\Client\Model\NetworksnetworkIdwirelessssidsnumberOauth $oauth oauth
     *
     * @return $this
     */
    public function setOauth($oauth)
    {
        $this->container['oauth'] = $oauth;

        return $this;
    }

    /**
     * Gets local_radius
     *
     * @return \Swagger\Client\Model\NetworksnetworkIdwirelessssidsnumberLocalRadius
     */
    public function getLocalRadius()
    {
        return $this->container['local_radius'];
    }

    /**
     * Sets local_radius
     *
     * @param \Swagger\Client\Model\NetworksnetworkIdwirelessssidsnumberLocalRadius $local_radius local_radius
     *
     * @return $this
     */
    public function setLocalRadius($local_radius)
    {
        $this->container['local_radius'] = $local_radius;

        return $this;
    }

    /**
     * Gets ldap
     *
     * @return \Swagger\Client\Model\NetworksnetworkIdwirelessssidsnumberLdap
     */
    public function getLdap()
    {
        return $this->container['ldap'];
    }

    /**
     * Sets ldap
     *
     * @param \Swagger\Client\Model\NetworksnetworkIdwirelessssidsnumberLdap $ldap ldap
     *
     * @return $this
     */
    public function setLdap($ldap)
    {
        $this->container['ldap'] = $ldap;

        return $this;
    }

    /**
     * Gets active_directory
     *
     * @return \Swagger\Client\Model\NetworksnetworkIdwirelessssidsnumberActiveDirectory
     */
    public function getActiveDirectory()
    {
        return $this->container['active_directory'];
    }

    /**
     * Sets active_directory
     *
     * @param \Swagger\Client\Model\NetworksnetworkIdwirelessssidsnumberActiveDirectory $active_directory active_directory
     *
     * @return $this
     */
    public function setActiveDirectory($active_directory)
    {
        $this->container['active_directory'] = $active_directory;

        return $this;
    }

    /**
     * Gets radius_servers
     *
     * @return \Swagger\Client\Model\NetworksnetworkIdwirelessssidsnumberRadiusServers[]
     */
    public function getRadiusServers()
    {
        return $this->container['radius_servers'];
    }

    /**
     * Sets radius_servers
     *
     * @param \Swagger\Client\Model\NetworksnetworkIdwirelessssidsnumberRadiusServers[] $radius_servers The RADIUS 802.1X servers to be used for authentication. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius'
     *
     * @return $this
     */
    public function setRadiusServers($radius_servers)
    {
        $this->container['radius_servers'] = $radius_servers;

        return $this;
    }

    /**
     * Gets radius_proxy_enabled
     *
     * @return bool
     */
    public function getRadiusProxyEnabled()
    {
        return $this->container['radius_proxy_enabled'];
    }

    /**
     * Sets radius_proxy_enabled
     *
     * @param bool $radius_proxy_enabled If true, Meraki devices will proxy RADIUS messages through the Meraki cloud to the configured RADIUS auth and accounting servers.
     *
     * @return $this
     */
    public function setRadiusProxyEnabled($radius_proxy_enabled)
    {
        $this->container['radius_proxy_enabled'] = $radius_proxy_enabled;

        return $this;
    }

    /**
     * Gets radius_testing_enabled
     *
     * @return bool
     */
    public function getRadiusTestingEnabled()
    {
        return $this->container['radius_testing_enabled'];
    }

    /**
     * Sets radius_testing_enabled
     *
     * @param bool $radius_testing_enabled If true, Meraki devices will periodically send Access-Request messages to configured RADIUS servers using identity 'meraki_8021x_test' to ensure that the RADIUS servers are reachable.
     *
     * @return $this
     */
    public function setRadiusTestingEnabled($radius_testing_enabled)
    {
        $this->container['radius_testing_enabled'] = $radius_testing_enabled;

        return $this;
    }

    /**
     * Gets radius_called_station_id
     *
     * @return string
     */
    public function getRadiusCalledStationId()
    {
        return $this->container['radius_called_station_id'];
    }

    /**
     * Sets radius_called_station_id
     *
     * @param string $radius_called_station_id The template of the called station identifier to be used for RADIUS (ex. $NODE_MAC$:$VAP_NUM$).
     *
     * @return $this
     */
    public function setRadiusCalledStationId($radius_called_station_id)
    {
        $this->container['radius_called_station_id'] = $radius_called_station_id;

        return $this;
    }

    /**
     * Gets radius_authentication_nas_id
     *
     * @return string
     */
    public function getRadiusAuthenticationNasId()
    {
        return $this->container['radius_authentication_nas_id'];
    }

    /**
     * Sets radius_authentication_nas_id
     *
     * @param string $radius_authentication_nas_id The template of the NAS identifier to be used for RADIUS authentication (ex. $NODE_MAC$:$VAP_NUM$).
     *
     * @return $this
     */
    public function setRadiusAuthenticationNasId($radius_authentication_nas_id)
    {
        $this->container['radius_authentication_nas_id'] = $radius_authentication_nas_id;

        return $this;
    }

    /**
     * Gets radius_server_timeout
     *
     * @return int
     */
    public function getRadiusServerTimeout()
    {
        return $this->container['radius_server_timeout'];
    }

    /**
     * Sets radius_server_timeout
     *
     * @param int $radius_server_timeout The amount of time for which a RADIUS client waits for a reply from the RADIUS server (must be between 1-10 seconds).
     *
     * @return $this
     */
    public function setRadiusServerTimeout($radius_server_timeout)
    {
        $this->container['radius_server_timeout'] = $radius_server_timeout;

        return $this;
    }

    /**
     * Gets radius_server_attempts_limit
     *
     * @return int
     */
    public function getRadiusServerAttemptsLimit()
    {
        return $this->container['radius_server_attempts_limit'];
    }

    /**
     * Sets radius_server_attempts_limit
     *
     * @param int $radius_server_attempts_limit The maximum number of transmit attempts after which a RADIUS server is failed over (must be between 1-5).
     *
     * @return $this
     */
    public function setRadiusServerAttemptsLimit($radius_server_attempts_limit)
    {
        $this->container['radius_server_attempts_limit'] = $radius_server_attempts_limit;

        return $this;
    }

    /**
     * Gets radius_fallback_enabled
     *
     * @return bool
     */
    public function getRadiusFallbackEnabled()
    {
        return $this->container['radius_fallback_enabled'];
    }

    /**
     * Sets radius_fallback_enabled
     *
     * @param bool $radius_fallback_enabled Whether or not higher priority RADIUS servers should be retried after 60 seconds.
     *
     * @return $this
     */
    public function setRadiusFallbackEnabled($radius_fallback_enabled)
    {
        $this->container['radius_fallback_enabled'] = $radius_fallback_enabled;

        return $this;
    }

    /**
     * Gets radius_coa_enabled
     *
     * @return bool
     */
    public function getRadiusCoaEnabled()
    {
        return $this->container['radius_coa_enabled'];
    }

    /**
     * Sets radius_coa_enabled
     *
     * @param bool $radius_coa_enabled If true, Meraki devices will act as a RADIUS Dynamic Authorization Server and will respond to RADIUS Change-of-Authorization and Disconnect messages sent by the RADIUS server.
     *
     * @return $this
     */
    public function setRadiusCoaEnabled($radius_coa_enabled)
    {
        $this->container['radius_coa_enabled'] = $radius_coa_enabled;

        return $this;
    }

    /**
     * Gets radius_failover_policy
     *
     * @return string
     */
    public function getRadiusFailoverPolicy()
    {
        return $this->container['radius_failover_policy'];
    }

    /**
     * Sets radius_failover_policy
     *
     * @param string $radius_failover_policy This policy determines how authentication requests should be handled in the event that all of the configured RADIUS servers are unreachable ('Deny access' or 'Allow access')
     *
     * @return $this
     */
    public function setRadiusFailoverPolicy($radius_failover_policy)
    {
        $allowedValues = $this->getRadiusFailoverPolicyAllowableValues();
        if (!is_null($radius_failover_policy) && !in_array($radius_failover_policy, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'radius_failover_policy', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['radius_failover_policy'] = $radius_failover_policy;

        return $this;
    }

    /**
     * Gets radius_load_balancing_policy
     *
     * @return string
     */
    public function getRadiusLoadBalancingPolicy()
    {
        return $this->container['radius_load_balancing_policy'];
    }

    /**
     * Sets radius_load_balancing_policy
     *
     * @param string $radius_load_balancing_policy This policy determines which RADIUS server will be contacted first in an authentication attempt and the ordering of any necessary retry attempts ('Strict priority order' or 'Round robin')
     *
     * @return $this
     */
    public function setRadiusLoadBalancingPolicy($radius_load_balancing_policy)
    {
        $allowedValues = $this->getRadiusLoadBalancingPolicyAllowableValues();
        if (!is_null($radius_load_balancing_policy) && !in_array($radius_load_balancing_policy, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'radius_load_balancing_policy', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['radius_load_balancing_policy'] = $radius_load_balancing_policy;

        return $this;
    }

    /**
     * Gets radius_accounting_enabled
     *
     * @return bool
     */
    public function getRadiusAccountingEnabled()
    {
        return $this->container['radius_accounting_enabled'];
    }

    /**
     * Sets radius_accounting_enabled
     *
     * @param bool $radius_accounting_enabled Whether or not RADIUS accounting is enabled. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius'
     *
     * @return $this
     */
    public function setRadiusAccountingEnabled($radius_accounting_enabled)
    {
        $this->container['radius_accounting_enabled'] = $radius_accounting_enabled;

        return $this;
    }

    /**
     * Gets radius_accounting_servers
     *
     * @return \Swagger\Client\Model\NetworksnetworkIdwirelessssidsnumberRadiusAccountingServers[]
     */
    public function getRadiusAccountingServers()
    {
        return $this->container['radius_accounting_servers'];
    }

    /**
     * Sets radius_accounting_servers
     *
     * @param \Swagger\Client\Model\NetworksnetworkIdwirelessssidsnumberRadiusAccountingServers[] $radius_accounting_servers The RADIUS accounting 802.1X servers to be used for authentication. This param is only valid if the authMode is 'open-with-radius', '8021x-radius' or 'ipsk-with-radius' and radiusAccountingEnabled is 'true'
     *
     * @return $this
     */
    public function setRadiusAccountingServers($radius_accounting_servers)
    {
        $this->container['radius_accounting_servers'] = $radius_accounting_servers;

        return $this;
    }

    /**
     * Gets radius_accounting_interim_interval
     *
     * @return int
     */
    public function getRadiusAccountingInterimInterval()
    {
        return $this->container['radius_accounting_interim_interval'];
    }

    /**
     * Sets radius_accounting_interim_interval
     *
     * @param int $radius_accounting_interim_interval The interval (in seconds) in which accounting information is updated and sent to the RADIUS accounting server.
     *
     * @return $this
     */
    public function setRadiusAccountingInterimInterval($radius_accounting_interim_interval)
    {
        $this->container['radius_accounting_interim_interval'] = $radius_accounting_interim_interval;

        return $this;
    }

    /**
     * Gets radius_attribute_for_group_policies
     *
     * @return string
     */
    public function getRadiusAttributeForGroupPolicies()
    {
        return $this->container['radius_attribute_for_group_policies'];
    }

    /**
     * Sets radius_attribute_for_group_policies
     *
     * @param string $radius_attribute_for_group_policies Specify the RADIUS attribute used to look up group policies ('Filter-Id', 'Reply-Message', 'Airespace-ACL-Name' or 'Aruba-User-Role'). Access points must receive this attribute in the RADIUS Access-Accept message
     *
     * @return $this
     */
    public function setRadiusAttributeForGroupPolicies($radius_attribute_for_group_policies)
    {
        $allowedValues = $this->getRadiusAttributeForGroupPoliciesAllowableValues();
        if (!is_null($radius_attribute_for_group_policies) && !in_array($radius_attribute_for_group_policies, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'radius_attribute_for_group_policies', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['radius_attribute_for_group_policies'] = $radius_attribute_for_group_policies;

        return $this;
    }

    /**
     * Gets ip_assignment_mode
     *
     * @return string
     */
    public function getIpAssignmentMode()
    {
        return $this->container['ip_assignment_mode'];
    }

    /**
     * Sets ip_assignment_mode
     *
     * @param string $ip_assignment_mode The client IP assignment mode ('NAT mode', 'Bridge mode', 'Layer 3 roaming', 'Layer 3 roaming with a concentrator' or 'VPN')
     *
     * @return $this
     */
    public function setIpAssignmentMode($ip_assignment_mode)
    {
        $this->container['ip_assignment_mode'] = $ip_assignment_mode;

        return $this;
    }

    /**
     * Gets use_vlan_tagging
     *
     * @return bool
     */
    public function getUseVlanTagging()
    {
        return $this->container['use_vlan_tagging'];
    }

    /**
     * Sets use_vlan_tagging
     *
     * @param bool $use_vlan_tagging Whether or not traffic should be directed to use specific VLANs. This param is only valid if the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
     *
     * @return $this
     */
    public function setUseVlanTagging($use_vlan_tagging)
    {
        $this->container['use_vlan_tagging'] = $use_vlan_tagging;

        return $this;
    }

    /**
     * Gets concentrator_network_id
     *
     * @return string
     */
    public function getConcentratorNetworkId()
    {
        return $this->container['concentrator_network_id'];
    }

    /**
     * Sets concentrator_network_id
     *
     * @param string $concentrator_network_id The concentrator to use when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN'.
     *
     * @return $this
     */
    public function setConcentratorNetworkId($concentrator_network_id)
    {
        $this->container['concentrator_network_id'] = $concentrator_network_id;

        return $this;
    }

    /**
     * Gets vlan_id
     *
     * @return int
     */
    public function getVlanId()
    {
        return $this->container['vlan_id'];
    }

    /**
     * Sets vlan_id
     *
     * @param int $vlan_id The VLAN ID used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Layer 3 roaming with a concentrator' or 'VPN'
     *
     * @return $this
     */
    public function setVlanId($vlan_id)
    {
        $this->container['vlan_id'] = $vlan_id;

        return $this;
    }

    /**
     * Gets default_vlan_id
     *
     * @return int
     */
    public function getDefaultVlanId()
    {
        return $this->container['default_vlan_id'];
    }

    /**
     * Sets default_vlan_id
     *
     * @param int $default_vlan_id The default VLAN ID used for 'all other APs'. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
     *
     * @return $this
     */
    public function setDefaultVlanId($default_vlan_id)
    {
        $this->container['default_vlan_id'] = $default_vlan_id;

        return $this;
    }

    /**
     * Gets ap_tags_and_vlan_ids
     *
     * @return \Swagger\Client\Model\NetworksnetworkIdwirelessssidsnumberApTagsAndVlanIds[]
     */
    public function getApTagsAndVlanIds()
    {
        return $this->container['ap_tags_and_vlan_ids'];
    }

    /**
     * Sets ap_tags_and_vlan_ids
     *
     * @param \Swagger\Client\Model\NetworksnetworkIdwirelessssidsnumberApTagsAndVlanIds[] $ap_tags_and_vlan_ids The list of tags and VLAN IDs used for VLAN tagging. This param is only valid when the ipAssignmentMode is 'Bridge mode' or 'Layer 3 roaming'
     *
     * @return $this
     */
    public function setApTagsAndVlanIds($ap_tags_and_vlan_ids)
    {
        $this->container['ap_tags_and_vlan_ids'] = $ap_tags_and_vlan_ids;

        return $this;
    }

    /**
     * Gets walled_garden_enabled
     *
     * @return bool
     */
    public function getWalledGardenEnabled()
    {
        return $this->container['walled_garden_enabled'];
    }

    /**
     * Sets walled_garden_enabled
     *
     * @param bool $walled_garden_enabled Allow access to a configurable list of IP ranges, which users may access prior to sign-on.
     *
     * @return $this
     */
    public function setWalledGardenEnabled($walled_garden_enabled)
    {
        $this->container['walled_garden_enabled'] = $walled_garden_enabled;

        return $this;
    }

    /**
     * Gets walled_garden_ranges
     *
     * @return string[]
     */
    public function getWalledGardenRanges()
    {
        return $this->container['walled_garden_ranges'];
    }

    /**
     * Sets walled_garden_ranges
     *
     * @param string[] $walled_garden_ranges Specify your walled garden by entering an array of addresses, ranges using CIDR notation, domain names, and domain wildcards (e.g. '192.168.1.1/24', '192.168.37.10/32', 'www.yahoo.com', '*.google.com']). Meraki's splash page is automatically included in your walled garden.
     *
     * @return $this
     */
    public function setWalledGardenRanges($walled_garden_ranges)
    {
        $this->container['walled_garden_ranges'] = $walled_garden_ranges;

        return $this;
    }

    /**
     * Gets radius_override
     *
     * @return bool
     */
    public function getRadiusOverride()
    {
        return $this->container['radius_override'];
    }

    /**
     * Sets radius_override
     *
     * @param bool $radius_override If true, the RADIUS response can override VLAN tag. This is not valid when ipAssignmentMode is 'NAT mode'.
     *
     * @return $this
     */
    public function setRadiusOverride($radius_override)
    {
        $this->container['radius_override'] = $radius_override;

        return $this;
    }

    /**
     * Gets radius_guest_vlan_enabled
     *
     * @return bool
     */
    public function getRadiusGuestVlanEnabled()
    {
        return $this->container['radius_guest_vlan_enabled'];
    }

    /**
     * Sets radius_guest_vlan_enabled
     *
     * @param bool $radius_guest_vlan_enabled Whether or not RADIUS Guest VLAN is enabled. This param is only valid if the authMode is 'open-with-radius' and addressing mode is not set to 'isolated' or 'nat' mode
     *
     * @return $this
     */
    public function setRadiusGuestVlanEnabled($radius_guest_vlan_enabled)
    {
        $this->container['radius_guest_vlan_enabled'] = $radius_guest_vlan_enabled;

        return $this;
    }

    /**
     * Gets radius_guest_vlan_id
     *
     * @return int
     */
    public function getRadiusGuestVlanId()
    {
        return $this->container['radius_guest_vlan_id'];
    }

    /**
     * Sets radius_guest_vlan_id
     *
     * @param int $radius_guest_vlan_id VLAN ID of the RADIUS Guest VLAN. This param is only valid if the authMode is 'open-with-radius' and addressing mode is not set to 'isolated' or 'nat' mode
     *
     * @return $this
     */
    public function setRadiusGuestVlanId($radius_guest_vlan_id)
    {
        $this->container['radius_guest_vlan_id'] = $radius_guest_vlan_id;

        return $this;
    }

    /**
     * Gets min_bitrate
     *
     * @return float
     */
    public function getMinBitrate()
    {
        return $this->container['min_bitrate'];
    }

    /**
     * Sets min_bitrate
     *
     * @param float $min_bitrate The minimum bitrate in Mbps. ('1', '2', '5.5', '6', '9', '11', '12', '18', '24', '36', '48' or '54')
     *
     * @return $this
     */
    public function setMinBitrate($min_bitrate)
    {
        $this->container['min_bitrate'] = $min_bitrate;

        return $this;
    }

    /**
     * Gets band_selection
     *
     * @return string
     */
    public function getBandSelection()
    {
        return $this->container['band_selection'];
    }

    /**
     * Sets band_selection
     *
     * @param string $band_selection The client-serving radio frequencies. ('Dual band operation', '5 GHz band only' or 'Dual band operation with Band Steering')
     *
     * @return $this
     */
    public function setBandSelection($band_selection)
    {
        $this->container['band_selection'] = $band_selection;

        return $this;
    }

    /**
     * Gets per_client_bandwidth_limit_up
     *
     * @return int
     */
    public function getPerClientBandwidthLimitUp()
    {
        return $this->container['per_client_bandwidth_limit_up'];
    }

    /**
     * Sets per_client_bandwidth_limit_up
     *
     * @param int $per_client_bandwidth_limit_up The upload bandwidth limit in Kbps. (0 represents no limit.)
     *
     * @return $this
     */
    public function setPerClientBandwidthLimitUp($per_client_bandwidth_limit_up)
    {
        $this->container['per_client_bandwidth_limit_up'] = $per_client_bandwidth_limit_up;

        return $this;
    }

    /**
     * Gets per_client_bandwidth_limit_down
     *
     * @return int
     */
    public function getPerClientBandwidthLimitDown()
    {
        return $this->container['per_client_bandwidth_limit_down'];
    }

    /**
     * Sets per_client_bandwidth_limit_down
     *
     * @param int $per_client_bandwidth_limit_down The download bandwidth limit in Kbps. (0 represents no limit.)
     *
     * @return $this
     */
    public function setPerClientBandwidthLimitDown($per_client_bandwidth_limit_down)
    {
        $this->container['per_client_bandwidth_limit_down'] = $per_client_bandwidth_limit_down;

        return $this;
    }

    /**
     * Gets per_ssid_bandwidth_limit_up
     *
     * @return int
     */
    public function getPerSsidBandwidthLimitUp()
    {
        return $this->container['per_ssid_bandwidth_limit_up'];
    }

    /**
     * Sets per_ssid_bandwidth_limit_up
     *
     * @param int $per_ssid_bandwidth_limit_up The total upload bandwidth limit in Kbps. (0 represents no limit.)
     *
     * @return $this
     */
    public function setPerSsidBandwidthLimitUp($per_ssid_bandwidth_limit_up)
    {
        $this->container['per_ssid_bandwidth_limit_up'] = $per_ssid_bandwidth_limit_up;

        return $this;
    }

    /**
     * Gets per_ssid_bandwidth_limit_down
     *
     * @return int
     */
    public function getPerSsidBandwidthLimitDown()
    {
        return $this->container['per_ssid_bandwidth_limit_down'];
    }

    /**
     * Sets per_ssid_bandwidth_limit_down
     *
     * @param int $per_ssid_bandwidth_limit_down The total download bandwidth limit in Kbps. (0 represents no limit.)
     *
     * @return $this
     */
    public function setPerSsidBandwidthLimitDown($per_ssid_bandwidth_limit_down)
    {
        $this->container['per_ssid_bandwidth_limit_down'] = $per_ssid_bandwidth_limit_down;

        return $this;
    }

    /**
     * Gets lan_isolation_enabled
     *
     * @return bool
     */
    public function getLanIsolationEnabled()
    {
        return $this->container['lan_isolation_enabled'];
    }

    /**
     * Sets lan_isolation_enabled
     *
     * @param bool $lan_isolation_enabled Boolean indicating whether Layer 2 LAN isolation should be enabled or disabled. Only configurable when ipAssignmentMode is 'Bridge mode'.
     *
     * @return $this
     */
    public function setLanIsolationEnabled($lan_isolation_enabled)
    {
        $this->container['lan_isolation_enabled'] = $lan_isolation_enabled;

        return $this;
    }

    /**
     * Gets visible
     *
     * @return bool
     */
    public function getVisible()
    {
        return $this->container['visible'];
    }

    /**
     * Sets visible
     *
     * @param bool $visible Boolean indicating whether APs should advertise or hide this SSID. APs will only broadcast this SSID if set to true
     *
     * @return $this
     */
    public function setVisible($visible)
    {
        $this->container['visible'] = $visible;

        return $this;
    }

    /**
     * Gets available_on_all_aps
     *
     * @return bool
     */
    public function getAvailableOnAllAps()
    {
        return $this->container['available_on_all_aps'];
    }

    /**
     * Sets available_on_all_aps
     *
     * @param bool $available_on_all_aps Boolean indicating whether all APs should broadcast the SSID or if it should be restricted to APs matching any availability tags. Can only be false if the SSID has availability tags.
     *
     * @return $this
     */
    public function setAvailableOnAllAps($available_on_all_aps)
    {
        $this->container['available_on_all_aps'] = $available_on_all_aps;

        return $this;
    }

    /**
     * Gets availability_tags
     *
     * @return string[]
     */
    public function getAvailabilityTags()
    {
        return $this->container['availability_tags'];
    }

    /**
     * Sets availability_tags
     *
     * @param string[] $availability_tags Accepts a list of tags for this SSID. If availableOnAllAps is false, then the SSID will only be broadcast by APs with tags matching any of the tags in this list.
     *
     * @return $this
     */
    public function setAvailabilityTags($availability_tags)
    {
        $this->container['availability_tags'] = $availability_tags;

        return $this;
    }

    /**
     * Gets mandatory_dhcp_enabled
     *
     * @return bool
     */
    public function getMandatoryDhcpEnabled()
    {
        return $this->container['mandatory_dhcp_enabled'];
    }

    /**
     * Sets mandatory_dhcp_enabled
     *
     * @param bool $mandatory_dhcp_enabled If true, Mandatory DHCP will enforce that clients connecting to this SSID must use the IP address assigned by the DHCP server. Clients who use a static IP address won't be able to associate.
     *
     * @return $this
     */
    public function setMandatoryDhcpEnabled($mandatory_dhcp_enabled)
    {
        $this->container['mandatory_dhcp_enabled'] = $mandatory_dhcp_enabled;

        return $this;
    }

    /**
     * Gets adult_content_filtering_enabled
     *
     * @return bool
     */
    public function getAdultContentFilteringEnabled()
    {
        return $this->container['adult_content_filtering_enabled'];
    }

    /**
     * Sets adult_content_filtering_enabled
     *
     * @param bool $adult_content_filtering_enabled Boolean indicating whether or not adult content will be blocked
     *
     * @return $this
     */
    public function setAdultContentFilteringEnabled($adult_content_filtering_enabled)
    {
        $this->container['adult_content_filtering_enabled'] = $adult_content_filtering_enabled;

        return $this;
    }

    /**
     * Gets dns_rewrite
     *
     * @return \Swagger\Client\Model\NetworksnetworkIdwirelessssidsnumberDnsRewrite
     */
    public function getDnsRewrite()
    {
        return $this->container['dns_rewrite'];
    }

    /**
     * Sets dns_rewrite
     *
     * @param \Swagger\Client\Model\NetworksnetworkIdwirelessssidsnumberDnsRewrite $dns_rewrite dns_rewrite
     *
     * @return $this
     */
    public function setDnsRewrite($dns_rewrite)
    {
        $this->container['dns_rewrite'] = $dns_rewrite;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


