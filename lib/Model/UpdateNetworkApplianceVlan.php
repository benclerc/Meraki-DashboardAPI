<?php
/**
 * UpdateNetworkApplianceVlan
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Meraki Dashboard API
 *
 * The Cisco Meraki Dashboard API is a modern REST API based on the OpenAPI specification.  > Date: 27 April, 2021 > > [What's New](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com)
 *
 * OpenAPI spec version: 1.0.0-streaming
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.19
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;
use \Swagger\Client\ObjectSerializer;

/**
 * UpdateNetworkApplianceVlan Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class UpdateNetworkApplianceVlan implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'updateNetworkApplianceVlan';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'name' => 'string',
        'subnet' => 'string',
        'appliance_ip' => 'string',
        'group_policy_id' => 'string',
        'vpn_nat_subnet' => 'string',
        'dhcp_handling' => 'string',
        'dhcp_relay_server_ips' => 'string[]',
        'dhcp_lease_time' => 'string',
        'dhcp_boot_options_enabled' => 'bool',
        'dhcp_boot_next_server' => 'string',
        'dhcp_boot_filename' => 'string',
        'fixed_ip_assignments' => 'object',
        'reserved_ip_ranges' => '\Swagger\Client\Model\NetworksnetworkIdappliancestaticRoutesstaticRouteIdReservedIpRanges[]',
        'dns_nameservers' => 'string',
        'dhcp_options' => '\Swagger\Client\Model\NetworksnetworkIdappliancevlansvlanIdDhcpOptions[]'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'name' => null,
        'subnet' => null,
        'appliance_ip' => null,
        'group_policy_id' => null,
        'vpn_nat_subnet' => null,
        'dhcp_handling' => null,
        'dhcp_relay_server_ips' => null,
        'dhcp_lease_time' => null,
        'dhcp_boot_options_enabled' => null,
        'dhcp_boot_next_server' => null,
        'dhcp_boot_filename' => null,
        'fixed_ip_assignments' => null,
        'reserved_ip_ranges' => null,
        'dns_nameservers' => null,
        'dhcp_options' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'name' => 'name',
        'subnet' => 'subnet',
        'appliance_ip' => 'applianceIp',
        'group_policy_id' => 'groupPolicyId',
        'vpn_nat_subnet' => 'vpnNatSubnet',
        'dhcp_handling' => 'dhcpHandling',
        'dhcp_relay_server_ips' => 'dhcpRelayServerIps',
        'dhcp_lease_time' => 'dhcpLeaseTime',
        'dhcp_boot_options_enabled' => 'dhcpBootOptionsEnabled',
        'dhcp_boot_next_server' => 'dhcpBootNextServer',
        'dhcp_boot_filename' => 'dhcpBootFilename',
        'fixed_ip_assignments' => 'fixedIpAssignments',
        'reserved_ip_ranges' => 'reservedIpRanges',
        'dns_nameservers' => 'dnsNameservers',
        'dhcp_options' => 'dhcpOptions'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'name' => 'setName',
        'subnet' => 'setSubnet',
        'appliance_ip' => 'setApplianceIp',
        'group_policy_id' => 'setGroupPolicyId',
        'vpn_nat_subnet' => 'setVpnNatSubnet',
        'dhcp_handling' => 'setDhcpHandling',
        'dhcp_relay_server_ips' => 'setDhcpRelayServerIps',
        'dhcp_lease_time' => 'setDhcpLeaseTime',
        'dhcp_boot_options_enabled' => 'setDhcpBootOptionsEnabled',
        'dhcp_boot_next_server' => 'setDhcpBootNextServer',
        'dhcp_boot_filename' => 'setDhcpBootFilename',
        'fixed_ip_assignments' => 'setFixedIpAssignments',
        'reserved_ip_ranges' => 'setReservedIpRanges',
        'dns_nameservers' => 'setDnsNameservers',
        'dhcp_options' => 'setDhcpOptions'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'name' => 'getName',
        'subnet' => 'getSubnet',
        'appliance_ip' => 'getApplianceIp',
        'group_policy_id' => 'getGroupPolicyId',
        'vpn_nat_subnet' => 'getVpnNatSubnet',
        'dhcp_handling' => 'getDhcpHandling',
        'dhcp_relay_server_ips' => 'getDhcpRelayServerIps',
        'dhcp_lease_time' => 'getDhcpLeaseTime',
        'dhcp_boot_options_enabled' => 'getDhcpBootOptionsEnabled',
        'dhcp_boot_next_server' => 'getDhcpBootNextServer',
        'dhcp_boot_filename' => 'getDhcpBootFilename',
        'fixed_ip_assignments' => 'getFixedIpAssignments',
        'reserved_ip_ranges' => 'getReservedIpRanges',
        'dns_nameservers' => 'getDnsNameservers',
        'dhcp_options' => 'getDhcpOptions'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const DHCP_HANDLING_RUN_A_DHCP_SERVER = 'Run a DHCP server';
    const DHCP_HANDLING_RELAY_DHCP_TO_ANOTHER_SERVER = 'Relay DHCP to another server';
    const DHCP_HANDLING_DO_NOT_RESPOND_TO_DHCP_REQUESTS = 'Do not respond to DHCP requests';
    const DHCP_LEASE_TIME__30_MINUTES = '30 minutes';
    const DHCP_LEASE_TIME__1_HOUR = '1 hour';
    const DHCP_LEASE_TIME__4_HOURS = '4 hours';
    const DHCP_LEASE_TIME__12_HOURS = '12 hours';
    const DHCP_LEASE_TIME__1_DAY = '1 day';
    const DHCP_LEASE_TIME__1_WEEK = '1 week';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getDhcpHandlingAllowableValues()
    {
        return [
            self::DHCP_HANDLING_RUN_A_DHCP_SERVER,
            self::DHCP_HANDLING_RELAY_DHCP_TO_ANOTHER_SERVER,
            self::DHCP_HANDLING_DO_NOT_RESPOND_TO_DHCP_REQUESTS,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getDhcpLeaseTimeAllowableValues()
    {
        return [
            self::DHCP_LEASE_TIME__30_MINUTES,
            self::DHCP_LEASE_TIME__1_HOUR,
            self::DHCP_LEASE_TIME__4_HOURS,
            self::DHCP_LEASE_TIME__12_HOURS,
            self::DHCP_LEASE_TIME__1_DAY,
            self::DHCP_LEASE_TIME__1_WEEK,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['name'] = isset($data['name']) ? $data['name'] : null;
        $this->container['subnet'] = isset($data['subnet']) ? $data['subnet'] : null;
        $this->container['appliance_ip'] = isset($data['appliance_ip']) ? $data['appliance_ip'] : null;
        $this->container['group_policy_id'] = isset($data['group_policy_id']) ? $data['group_policy_id'] : null;
        $this->container['vpn_nat_subnet'] = isset($data['vpn_nat_subnet']) ? $data['vpn_nat_subnet'] : null;
        $this->container['dhcp_handling'] = isset($data['dhcp_handling']) ? $data['dhcp_handling'] : null;
        $this->container['dhcp_relay_server_ips'] = isset($data['dhcp_relay_server_ips']) ? $data['dhcp_relay_server_ips'] : null;
        $this->container['dhcp_lease_time'] = isset($data['dhcp_lease_time']) ? $data['dhcp_lease_time'] : null;
        $this->container['dhcp_boot_options_enabled'] = isset($data['dhcp_boot_options_enabled']) ? $data['dhcp_boot_options_enabled'] : null;
        $this->container['dhcp_boot_next_server'] = isset($data['dhcp_boot_next_server']) ? $data['dhcp_boot_next_server'] : null;
        $this->container['dhcp_boot_filename'] = isset($data['dhcp_boot_filename']) ? $data['dhcp_boot_filename'] : null;
        $this->container['fixed_ip_assignments'] = isset($data['fixed_ip_assignments']) ? $data['fixed_ip_assignments'] : null;
        $this->container['reserved_ip_ranges'] = isset($data['reserved_ip_ranges']) ? $data['reserved_ip_ranges'] : null;
        $this->container['dns_nameservers'] = isset($data['dns_nameservers']) ? $data['dns_nameservers'] : null;
        $this->container['dhcp_options'] = isset($data['dhcp_options']) ? $data['dhcp_options'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getDhcpHandlingAllowableValues();
        if (!is_null($this->container['dhcp_handling']) && !in_array($this->container['dhcp_handling'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'dhcp_handling', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getDhcpLeaseTimeAllowableValues();
        if (!is_null($this->container['dhcp_lease_time']) && !in_array($this->container['dhcp_lease_time'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'dhcp_lease_time', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets name
     *
     * @return string
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string $name The name of the VLAN
     *
     * @return $this
     */
    public function setName($name)
    {
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets subnet
     *
     * @return string
     */
    public function getSubnet()
    {
        return $this->container['subnet'];
    }

    /**
     * Sets subnet
     *
     * @param string $subnet The subnet of the VLAN
     *
     * @return $this
     */
    public function setSubnet($subnet)
    {
        $this->container['subnet'] = $subnet;

        return $this;
    }

    /**
     * Gets appliance_ip
     *
     * @return string
     */
    public function getApplianceIp()
    {
        return $this->container['appliance_ip'];
    }

    /**
     * Sets appliance_ip
     *
     * @param string $appliance_ip The local IP of the appliance on the VLAN
     *
     * @return $this
     */
    public function setApplianceIp($appliance_ip)
    {
        $this->container['appliance_ip'] = $appliance_ip;

        return $this;
    }

    /**
     * Gets group_policy_id
     *
     * @return string
     */
    public function getGroupPolicyId()
    {
        return $this->container['group_policy_id'];
    }

    /**
     * Sets group_policy_id
     *
     * @param string $group_policy_id The id of the desired group policy to apply to the VLAN
     *
     * @return $this
     */
    public function setGroupPolicyId($group_policy_id)
    {
        $this->container['group_policy_id'] = $group_policy_id;

        return $this;
    }

    /**
     * Gets vpn_nat_subnet
     *
     * @return string
     */
    public function getVpnNatSubnet()
    {
        return $this->container['vpn_nat_subnet'];
    }

    /**
     * Sets vpn_nat_subnet
     *
     * @param string $vpn_nat_subnet The translated VPN subnet if VPN and VPN subnet translation are enabled on the VLAN
     *
     * @return $this
     */
    public function setVpnNatSubnet($vpn_nat_subnet)
    {
        $this->container['vpn_nat_subnet'] = $vpn_nat_subnet;

        return $this;
    }

    /**
     * Gets dhcp_handling
     *
     * @return string
     */
    public function getDhcpHandling()
    {
        return $this->container['dhcp_handling'];
    }

    /**
     * Sets dhcp_handling
     *
     * @param string $dhcp_handling The appliance's handling of DHCP requests on this VLAN. One of: 'Run a DHCP server', 'Relay DHCP to another server' or 'Do not respond to DHCP requests'
     *
     * @return $this
     */
    public function setDhcpHandling($dhcp_handling)
    {
        $allowedValues = $this->getDhcpHandlingAllowableValues();
        if (!is_null($dhcp_handling) && !in_array($dhcp_handling, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'dhcp_handling', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['dhcp_handling'] = $dhcp_handling;

        return $this;
    }

    /**
     * Gets dhcp_relay_server_ips
     *
     * @return string[]
     */
    public function getDhcpRelayServerIps()
    {
        return $this->container['dhcp_relay_server_ips'];
    }

    /**
     * Sets dhcp_relay_server_ips
     *
     * @param string[] $dhcp_relay_server_ips The IPs of the DHCP servers that DHCP requests should be relayed to
     *
     * @return $this
     */
    public function setDhcpRelayServerIps($dhcp_relay_server_ips)
    {
        $this->container['dhcp_relay_server_ips'] = $dhcp_relay_server_ips;

        return $this;
    }

    /**
     * Gets dhcp_lease_time
     *
     * @return string
     */
    public function getDhcpLeaseTime()
    {
        return $this->container['dhcp_lease_time'];
    }

    /**
     * Sets dhcp_lease_time
     *
     * @param string $dhcp_lease_time The term of DHCP leases if the appliance is running a DHCP server on this VLAN. One of: '30 minutes', '1 hour', '4 hours', '12 hours', '1 day' or '1 week'
     *
     * @return $this
     */
    public function setDhcpLeaseTime($dhcp_lease_time)
    {
        $allowedValues = $this->getDhcpLeaseTimeAllowableValues();
        if (!is_null($dhcp_lease_time) && !in_array($dhcp_lease_time, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'dhcp_lease_time', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['dhcp_lease_time'] = $dhcp_lease_time;

        return $this;
    }

    /**
     * Gets dhcp_boot_options_enabled
     *
     * @return bool
     */
    public function getDhcpBootOptionsEnabled()
    {
        return $this->container['dhcp_boot_options_enabled'];
    }

    /**
     * Sets dhcp_boot_options_enabled
     *
     * @param bool $dhcp_boot_options_enabled Use DHCP boot options specified in other properties
     *
     * @return $this
     */
    public function setDhcpBootOptionsEnabled($dhcp_boot_options_enabled)
    {
        $this->container['dhcp_boot_options_enabled'] = $dhcp_boot_options_enabled;

        return $this;
    }

    /**
     * Gets dhcp_boot_next_server
     *
     * @return string
     */
    public function getDhcpBootNextServer()
    {
        return $this->container['dhcp_boot_next_server'];
    }

    /**
     * Sets dhcp_boot_next_server
     *
     * @param string $dhcp_boot_next_server DHCP boot option to direct boot clients to the server to load the boot file from
     *
     * @return $this
     */
    public function setDhcpBootNextServer($dhcp_boot_next_server)
    {
        $this->container['dhcp_boot_next_server'] = $dhcp_boot_next_server;

        return $this;
    }

    /**
     * Gets dhcp_boot_filename
     *
     * @return string
     */
    public function getDhcpBootFilename()
    {
        return $this->container['dhcp_boot_filename'];
    }

    /**
     * Sets dhcp_boot_filename
     *
     * @param string $dhcp_boot_filename DHCP boot option for boot filename
     *
     * @return $this
     */
    public function setDhcpBootFilename($dhcp_boot_filename)
    {
        $this->container['dhcp_boot_filename'] = $dhcp_boot_filename;

        return $this;
    }

    /**
     * Gets fixed_ip_assignments
     *
     * @return object
     */
    public function getFixedIpAssignments()
    {
        return $this->container['fixed_ip_assignments'];
    }

    /**
     * Sets fixed_ip_assignments
     *
     * @param object $fixed_ip_assignments The DHCP fixed IP assignments on the VLAN. This should be an object that contains mappings from MAC addresses to objects that themselves each contain \"ip\" and \"name\" string fields. See the sample request/response for more details.
     *
     * @return $this
     */
    public function setFixedIpAssignments($fixed_ip_assignments)
    {
        $this->container['fixed_ip_assignments'] = $fixed_ip_assignments;

        return $this;
    }

    /**
     * Gets reserved_ip_ranges
     *
     * @return \Swagger\Client\Model\NetworksnetworkIdappliancestaticRoutesstaticRouteIdReservedIpRanges[]
     */
    public function getReservedIpRanges()
    {
        return $this->container['reserved_ip_ranges'];
    }

    /**
     * Sets reserved_ip_ranges
     *
     * @param \Swagger\Client\Model\NetworksnetworkIdappliancestaticRoutesstaticRouteIdReservedIpRanges[] $reserved_ip_ranges The DHCP reserved IP ranges on the VLAN
     *
     * @return $this
     */
    public function setReservedIpRanges($reserved_ip_ranges)
    {
        $this->container['reserved_ip_ranges'] = $reserved_ip_ranges;

        return $this;
    }

    /**
     * Gets dns_nameservers
     *
     * @return string
     */
    public function getDnsNameservers()
    {
        return $this->container['dns_nameservers'];
    }

    /**
     * Sets dns_nameservers
     *
     * @param string $dns_nameservers The DNS nameservers used for DHCP responses, either \"upstream_dns\", \"google_dns\", \"opendns\", or a newline seperated string of IP addresses or domain names
     *
     * @return $this
     */
    public function setDnsNameservers($dns_nameservers)
    {
        $this->container['dns_nameservers'] = $dns_nameservers;

        return $this;
    }

    /**
     * Gets dhcp_options
     *
     * @return \Swagger\Client\Model\NetworksnetworkIdappliancevlansvlanIdDhcpOptions[]
     */
    public function getDhcpOptions()
    {
        return $this->container['dhcp_options'];
    }

    /**
     * Sets dhcp_options
     *
     * @param \Swagger\Client\Model\NetworksnetworkIdappliancevlansvlanIdDhcpOptions[] $dhcp_options The list of DHCP options that will be included in DHCP responses. Each object in the list should have \"code\", \"type\", and \"value\" properties.
     *
     * @return $this
     */
    public function setDhcpOptions($dhcp_options)
    {
        $this->container['dhcp_options'] = $dhcp_options;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


