<?php
/**
 * MonitorApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Meraki Dashboard API
 *
 * The Cisco Meraki Dashboard API is a modern REST API based on the OpenAPI specification.  > Date: 07 July, 2021 > > [What's New](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com)
 *
 * OpenAPI spec version: 1.11.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.19
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * MonitorApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class MonitorApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation generateDeviceCameraSnapshot
     *
     * Generate a snapshot of what the camera sees at the specified time and return a link to that image.
     *
     * @param  string $serial serial (required)
     * @param  \Swagger\Client\Model\GenerateDeviceCameraSnapshot $generate_device_camera_snapshot generate_device_camera_snapshot (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function generateDeviceCameraSnapshot($serial, $generate_device_camera_snapshot = null)
    {
        list($response) = $this->generateDeviceCameraSnapshotWithHttpInfo($serial, $generate_device_camera_snapshot);
        return $response;
    }

    /**
     * Operation generateDeviceCameraSnapshotWithHttpInfo
     *
     * Generate a snapshot of what the camera sees at the specified time and return a link to that image.
     *
     * @param  string $serial (required)
     * @param  \Swagger\Client\Model\GenerateDeviceCameraSnapshot $generate_device_camera_snapshot (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function generateDeviceCameraSnapshotWithHttpInfo($serial, $generate_device_camera_snapshot = null)
    {
        $returnType = 'object';
        $request = $this->generateDeviceCameraSnapshotRequest($serial, $generate_device_camera_snapshot);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation generateDeviceCameraSnapshotAsync
     *
     * Generate a snapshot of what the camera sees at the specified time and return a link to that image.
     *
     * @param  string $serial (required)
     * @param  \Swagger\Client\Model\GenerateDeviceCameraSnapshot $generate_device_camera_snapshot (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateDeviceCameraSnapshotAsync($serial, $generate_device_camera_snapshot = null)
    {
        return $this->generateDeviceCameraSnapshotAsyncWithHttpInfo($serial, $generate_device_camera_snapshot)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation generateDeviceCameraSnapshotAsyncWithHttpInfo
     *
     * Generate a snapshot of what the camera sees at the specified time and return a link to that image.
     *
     * @param  string $serial (required)
     * @param  \Swagger\Client\Model\GenerateDeviceCameraSnapshot $generate_device_camera_snapshot (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function generateDeviceCameraSnapshotAsyncWithHttpInfo($serial, $generate_device_camera_snapshot = null)
    {
        $returnType = 'object';
        $request = $this->generateDeviceCameraSnapshotRequest($serial, $generate_device_camera_snapshot);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'generateDeviceCameraSnapshot'
     *
     * @param  string $serial (required)
     * @param  \Swagger\Client\Model\GenerateDeviceCameraSnapshot $generate_device_camera_snapshot (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function generateDeviceCameraSnapshotRequest($serial, $generate_device_camera_snapshot = null)
    {
        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling generateDeviceCameraSnapshot'
            );
        }

        $resourcePath = '/devices/{serial}/camera/generateSnapshot';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($generate_device_camera_snapshot)) {
            $_tempBody = $generate_device_camera_snapshot;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceApplianceDhcpSubnets
     *
     * Return the DHCP subnet information for an appliance
     *
     * @param  string $serial serial (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getDeviceApplianceDhcpSubnets($serial)
    {
        list($response) = $this->getDeviceApplianceDhcpSubnetsWithHttpInfo($serial);
        return $response;
    }

    /**
     * Operation getDeviceApplianceDhcpSubnetsWithHttpInfo
     *
     * Return the DHCP subnet information for an appliance
     *
     * @param  string $serial (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceApplianceDhcpSubnetsWithHttpInfo($serial)
    {
        $returnType = 'object';
        $request = $this->getDeviceApplianceDhcpSubnetsRequest($serial);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceApplianceDhcpSubnetsAsync
     *
     * Return the DHCP subnet information for an appliance
     *
     * @param  string $serial (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceApplianceDhcpSubnetsAsync($serial)
    {
        return $this->getDeviceApplianceDhcpSubnetsAsyncWithHttpInfo($serial)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceApplianceDhcpSubnetsAsyncWithHttpInfo
     *
     * Return the DHCP subnet information for an appliance
     *
     * @param  string $serial (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceApplianceDhcpSubnetsAsyncWithHttpInfo($serial)
    {
        $returnType = 'object';
        $request = $this->getDeviceApplianceDhcpSubnetsRequest($serial);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceApplianceDhcpSubnets'
     *
     * @param  string $serial (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeviceApplianceDhcpSubnetsRequest($serial)
    {
        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceApplianceDhcpSubnets'
            );
        }

        $resourcePath = '/devices/{serial}/appliance/dhcp/subnets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceAppliancePerformance
     *
     * Return the performance score for a single MX
     *
     * @param  string $serial serial (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getDeviceAppliancePerformance($serial)
    {
        list($response) = $this->getDeviceAppliancePerformanceWithHttpInfo($serial);
        return $response;
    }

    /**
     * Operation getDeviceAppliancePerformanceWithHttpInfo
     *
     * Return the performance score for a single MX
     *
     * @param  string $serial (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceAppliancePerformanceWithHttpInfo($serial)
    {
        $returnType = 'object';
        $request = $this->getDeviceAppliancePerformanceRequest($serial);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceAppliancePerformanceAsync
     *
     * Return the performance score for a single MX
     *
     * @param  string $serial (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceAppliancePerformanceAsync($serial)
    {
        return $this->getDeviceAppliancePerformanceAsyncWithHttpInfo($serial)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceAppliancePerformanceAsyncWithHttpInfo
     *
     * Return the performance score for a single MX
     *
     * @param  string $serial (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceAppliancePerformanceAsyncWithHttpInfo($serial)
    {
        $returnType = 'object';
        $request = $this->getDeviceAppliancePerformanceRequest($serial);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceAppliancePerformance'
     *
     * @param  string $serial (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeviceAppliancePerformanceRequest($serial)
    {
        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceAppliancePerformance'
            );
        }

        $resourcePath = '/devices/{serial}/appliance/performance';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceCameraAnalyticsLive
     *
     * Returns live state from camera of analytics zones
     *
     * @param  string $serial serial (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getDeviceCameraAnalyticsLive($serial)
    {
        list($response) = $this->getDeviceCameraAnalyticsLiveWithHttpInfo($serial);
        return $response;
    }

    /**
     * Operation getDeviceCameraAnalyticsLiveWithHttpInfo
     *
     * Returns live state from camera of analytics zones
     *
     * @param  string $serial (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceCameraAnalyticsLiveWithHttpInfo($serial)
    {
        $returnType = 'object';
        $request = $this->getDeviceCameraAnalyticsLiveRequest($serial);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceCameraAnalyticsLiveAsync
     *
     * Returns live state from camera of analytics zones
     *
     * @param  string $serial (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceCameraAnalyticsLiveAsync($serial)
    {
        return $this->getDeviceCameraAnalyticsLiveAsyncWithHttpInfo($serial)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceCameraAnalyticsLiveAsyncWithHttpInfo
     *
     * Returns live state from camera of analytics zones
     *
     * @param  string $serial (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceCameraAnalyticsLiveAsyncWithHttpInfo($serial)
    {
        $returnType = 'object';
        $request = $this->getDeviceCameraAnalyticsLiveRequest($serial);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceCameraAnalyticsLive'
     *
     * @param  string $serial (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeviceCameraAnalyticsLiveRequest($serial)
    {
        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceCameraAnalyticsLive'
            );
        }

        $resourcePath = '/devices/{serial}/camera/analytics/live';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceCameraAnalyticsOverview
     *
     * Returns an overview of aggregate analytics data for a timespan
     *
     * @param  string $serial serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. The default is 1 hour. (optional)
     * @param  string $object_type [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle]. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getDeviceCameraAnalyticsOverview($serial, $t0 = null, $t1 = null, $timespan = null, $object_type = null)
    {
        list($response) = $this->getDeviceCameraAnalyticsOverviewWithHttpInfo($serial, $t0, $t1, $timespan, $object_type);
        return $response;
    }

    /**
     * Operation getDeviceCameraAnalyticsOverviewWithHttpInfo
     *
     * Returns an overview of aggregate analytics data for a timespan
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. The default is 1 hour. (optional)
     * @param  string $object_type [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle]. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceCameraAnalyticsOverviewWithHttpInfo($serial, $t0 = null, $t1 = null, $timespan = null, $object_type = null)
    {
        $returnType = 'object';
        $request = $this->getDeviceCameraAnalyticsOverviewRequest($serial, $t0, $t1, $timespan, $object_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceCameraAnalyticsOverviewAsync
     *
     * Returns an overview of aggregate analytics data for a timespan
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. The default is 1 hour. (optional)
     * @param  string $object_type [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle]. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceCameraAnalyticsOverviewAsync($serial, $t0 = null, $t1 = null, $timespan = null, $object_type = null)
    {
        return $this->getDeviceCameraAnalyticsOverviewAsyncWithHttpInfo($serial, $t0, $t1, $timespan, $object_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceCameraAnalyticsOverviewAsyncWithHttpInfo
     *
     * Returns an overview of aggregate analytics data for a timespan
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. The default is 1 hour. (optional)
     * @param  string $object_type [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle]. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceCameraAnalyticsOverviewAsyncWithHttpInfo($serial, $t0 = null, $t1 = null, $timespan = null, $object_type = null)
    {
        $returnType = 'object';
        $request = $this->getDeviceCameraAnalyticsOverviewRequest($serial, $t0, $t1, $timespan, $object_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceCameraAnalyticsOverview'
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. The default is 1 hour. (optional)
     * @param  string $object_type [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle]. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeviceCameraAnalyticsOverviewRequest($serial, $t0 = null, $t1 = null, $timespan = null, $object_type = null)
    {
        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceCameraAnalyticsOverview'
            );
        }

        $resourcePath = '/devices/{serial}/camera/analytics/overview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($object_type !== null) {
            $queryParams['objectType'] = ObjectSerializer::toQueryValue($object_type);
        }

        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceCameraAnalyticsRecent
     *
     * Returns most recent record for analytics zones
     *
     * @param  string $serial serial (required)
     * @param  string $object_type [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle]. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getDeviceCameraAnalyticsRecent($serial, $object_type = null)
    {
        list($response) = $this->getDeviceCameraAnalyticsRecentWithHttpInfo($serial, $object_type);
        return $response;
    }

    /**
     * Operation getDeviceCameraAnalyticsRecentWithHttpInfo
     *
     * Returns most recent record for analytics zones
     *
     * @param  string $serial (required)
     * @param  string $object_type [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle]. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceCameraAnalyticsRecentWithHttpInfo($serial, $object_type = null)
    {
        $returnType = 'object';
        $request = $this->getDeviceCameraAnalyticsRecentRequest($serial, $object_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceCameraAnalyticsRecentAsync
     *
     * Returns most recent record for analytics zones
     *
     * @param  string $serial (required)
     * @param  string $object_type [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle]. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceCameraAnalyticsRecentAsync($serial, $object_type = null)
    {
        return $this->getDeviceCameraAnalyticsRecentAsyncWithHttpInfo($serial, $object_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceCameraAnalyticsRecentAsyncWithHttpInfo
     *
     * Returns most recent record for analytics zones
     *
     * @param  string $serial (required)
     * @param  string $object_type [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle]. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceCameraAnalyticsRecentAsyncWithHttpInfo($serial, $object_type = null)
    {
        $returnType = 'object';
        $request = $this->getDeviceCameraAnalyticsRecentRequest($serial, $object_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceCameraAnalyticsRecent'
     *
     * @param  string $serial (required)
     * @param  string $object_type [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle]. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeviceCameraAnalyticsRecentRequest($serial, $object_type = null)
    {
        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceCameraAnalyticsRecent'
            );
        }

        $resourcePath = '/devices/{serial}/camera/analytics/recent';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($object_type !== null) {
            $queryParams['objectType'] = ObjectSerializer::toQueryValue($object_type);
        }

        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceCameraAnalyticsZoneHistory
     *
     * Return historical records for analytic zones
     *
     * @param  string $serial serial (required)
     * @param  string $zone_id zone_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 14 hours after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 14 hours. The default is 1 hour. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 60. The default is 60. (optional)
     * @param  string $object_type [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle]. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getDeviceCameraAnalyticsZoneHistory($serial, $zone_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $object_type = null)
    {
        list($response) = $this->getDeviceCameraAnalyticsZoneHistoryWithHttpInfo($serial, $zone_id, $t0, $t1, $timespan, $resolution, $object_type);
        return $response;
    }

    /**
     * Operation getDeviceCameraAnalyticsZoneHistoryWithHttpInfo
     *
     * Return historical records for analytic zones
     *
     * @param  string $serial (required)
     * @param  string $zone_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 14 hours after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 14 hours. The default is 1 hour. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 60. The default is 60. (optional)
     * @param  string $object_type [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle]. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceCameraAnalyticsZoneHistoryWithHttpInfo($serial, $zone_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $object_type = null)
    {
        $returnType = 'object';
        $request = $this->getDeviceCameraAnalyticsZoneHistoryRequest($serial, $zone_id, $t0, $t1, $timespan, $resolution, $object_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceCameraAnalyticsZoneHistoryAsync
     *
     * Return historical records for analytic zones
     *
     * @param  string $serial (required)
     * @param  string $zone_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 14 hours after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 14 hours. The default is 1 hour. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 60. The default is 60. (optional)
     * @param  string $object_type [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle]. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceCameraAnalyticsZoneHistoryAsync($serial, $zone_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $object_type = null)
    {
        return $this->getDeviceCameraAnalyticsZoneHistoryAsyncWithHttpInfo($serial, $zone_id, $t0, $t1, $timespan, $resolution, $object_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceCameraAnalyticsZoneHistoryAsyncWithHttpInfo
     *
     * Return historical records for analytic zones
     *
     * @param  string $serial (required)
     * @param  string $zone_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 14 hours after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 14 hours. The default is 1 hour. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 60. The default is 60. (optional)
     * @param  string $object_type [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle]. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceCameraAnalyticsZoneHistoryAsyncWithHttpInfo($serial, $zone_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $object_type = null)
    {
        $returnType = 'object';
        $request = $this->getDeviceCameraAnalyticsZoneHistoryRequest($serial, $zone_id, $t0, $t1, $timespan, $resolution, $object_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceCameraAnalyticsZoneHistory'
     *
     * @param  string $serial (required)
     * @param  string $zone_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 14 hours after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 14 hours. The default is 1 hour. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 60. The default is 60. (optional)
     * @param  string $object_type [optional] The object type for which analytics will be retrieved. The default object type is person. The available types are [person, vehicle]. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeviceCameraAnalyticsZoneHistoryRequest($serial, $zone_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $object_type = null)
    {
        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceCameraAnalyticsZoneHistory'
            );
        }
        // verify the required parameter 'zone_id' is set
        if ($zone_id === null || (is_array($zone_id) && count($zone_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $zone_id when calling getDeviceCameraAnalyticsZoneHistory'
            );
        }

        $resourcePath = '/devices/{serial}/camera/analytics/zones/{zoneId}/history';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($resolution !== null) {
            $queryParams['resolution'] = ObjectSerializer::toQueryValue($resolution);
        }
        // query params
        if ($object_type !== null) {
            $queryParams['objectType'] = ObjectSerializer::toQueryValue($object_type);
        }

        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }
        // path params
        if ($zone_id !== null) {
            $resourcePath = str_replace(
                '{' . 'zoneId' . '}',
                ObjectSerializer::toPathValue($zone_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceCameraAnalyticsZones
     *
     * Returns all configured analytic zones for this camera
     *
     * @param  string $serial serial (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getDeviceCameraAnalyticsZones($serial)
    {
        list($response) = $this->getDeviceCameraAnalyticsZonesWithHttpInfo($serial);
        return $response;
    }

    /**
     * Operation getDeviceCameraAnalyticsZonesWithHttpInfo
     *
     * Returns all configured analytic zones for this camera
     *
     * @param  string $serial (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceCameraAnalyticsZonesWithHttpInfo($serial)
    {
        $returnType = 'object';
        $request = $this->getDeviceCameraAnalyticsZonesRequest($serial);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceCameraAnalyticsZonesAsync
     *
     * Returns all configured analytic zones for this camera
     *
     * @param  string $serial (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceCameraAnalyticsZonesAsync($serial)
    {
        return $this->getDeviceCameraAnalyticsZonesAsyncWithHttpInfo($serial)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceCameraAnalyticsZonesAsyncWithHttpInfo
     *
     * Returns all configured analytic zones for this camera
     *
     * @param  string $serial (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceCameraAnalyticsZonesAsyncWithHttpInfo($serial)
    {
        $returnType = 'object';
        $request = $this->getDeviceCameraAnalyticsZonesRequest($serial);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceCameraAnalyticsZones'
     *
     * @param  string $serial (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeviceCameraAnalyticsZonesRequest($serial)
    {
        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceCameraAnalyticsZones'
            );
        }

        $resourcePath = '/devices/{serial}/camera/analytics/zones';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceClients
     *
     * List the clients of a device, up to a maximum of a month ago
     *
     * @param  string $serial serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getDeviceClients($serial, $t0 = null, $timespan = null)
    {
        list($response) = $this->getDeviceClientsWithHttpInfo($serial, $t0, $timespan);
        return $response;
    }

    /**
     * Operation getDeviceClientsWithHttpInfo
     *
     * List the clients of a device, up to a maximum of a month ago
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceClientsWithHttpInfo($serial, $t0 = null, $timespan = null)
    {
        $returnType = 'object';
        $request = $this->getDeviceClientsRequest($serial, $t0, $timespan);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceClientsAsync
     *
     * List the clients of a device, up to a maximum of a month ago
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceClientsAsync($serial, $t0 = null, $timespan = null)
    {
        return $this->getDeviceClientsAsyncWithHttpInfo($serial, $t0, $timespan)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceClientsAsyncWithHttpInfo
     *
     * List the clients of a device, up to a maximum of a month ago
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceClientsAsyncWithHttpInfo($serial, $t0 = null, $timespan = null)
    {
        $returnType = 'object';
        $request = $this->getDeviceClientsRequest($serial, $t0, $timespan);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceClients'
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeviceClientsRequest($serial, $t0 = null, $timespan = null)
    {
        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceClients'
            );
        }

        $resourcePath = '/devices/{serial}/clients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }

        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceLldpCdp
     *
     * List LLDP and CDP information for a device
     *
     * @param  string $serial serial (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getDeviceLldpCdp($serial)
    {
        list($response) = $this->getDeviceLldpCdpWithHttpInfo($serial);
        return $response;
    }

    /**
     * Operation getDeviceLldpCdpWithHttpInfo
     *
     * List LLDP and CDP information for a device
     *
     * @param  string $serial (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceLldpCdpWithHttpInfo($serial)
    {
        $returnType = 'object';
        $request = $this->getDeviceLldpCdpRequest($serial);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceLldpCdpAsync
     *
     * List LLDP and CDP information for a device
     *
     * @param  string $serial (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceLldpCdpAsync($serial)
    {
        return $this->getDeviceLldpCdpAsyncWithHttpInfo($serial)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceLldpCdpAsyncWithHttpInfo
     *
     * List LLDP and CDP information for a device
     *
     * @param  string $serial (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceLldpCdpAsyncWithHttpInfo($serial)
    {
        $returnType = 'object';
        $request = $this->getDeviceLldpCdpRequest($serial);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceLldpCdp'
     *
     * @param  string $serial (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeviceLldpCdpRequest($serial)
    {
        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceLldpCdp'
            );
        }

        $resourcePath = '/devices/{serial}/lldpCdp';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceLossAndLatencyHistory
     *
     * Get the uplink loss percentage and latency in milliseconds, and goodput in kilobits per second for a wired network device.
     *
     * @param  string $serial serial (required)
     * @param  string $ip The destination IP used to obtain the requested stats. This is required. (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 600, 3600, 86400. The default is 60. (optional)
     * @param  string $uplink The WAN uplink used to obtain the requested stats. Valid uplinks are wan1, wan2, cellular. The default is wan1. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getDeviceLossAndLatencyHistory($serial, $ip, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $uplink = null)
    {
        list($response) = $this->getDeviceLossAndLatencyHistoryWithHttpInfo($serial, $ip, $t0, $t1, $timespan, $resolution, $uplink);
        return $response;
    }

    /**
     * Operation getDeviceLossAndLatencyHistoryWithHttpInfo
     *
     * Get the uplink loss percentage and latency in milliseconds, and goodput in kilobits per second for a wired network device.
     *
     * @param  string $serial (required)
     * @param  string $ip The destination IP used to obtain the requested stats. This is required. (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 600, 3600, 86400. The default is 60. (optional)
     * @param  string $uplink The WAN uplink used to obtain the requested stats. Valid uplinks are wan1, wan2, cellular. The default is wan1. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceLossAndLatencyHistoryWithHttpInfo($serial, $ip, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $uplink = null)
    {
        $returnType = 'object';
        $request = $this->getDeviceLossAndLatencyHistoryRequest($serial, $ip, $t0, $t1, $timespan, $resolution, $uplink);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceLossAndLatencyHistoryAsync
     *
     * Get the uplink loss percentage and latency in milliseconds, and goodput in kilobits per second for a wired network device.
     *
     * @param  string $serial (required)
     * @param  string $ip The destination IP used to obtain the requested stats. This is required. (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 600, 3600, 86400. The default is 60. (optional)
     * @param  string $uplink The WAN uplink used to obtain the requested stats. Valid uplinks are wan1, wan2, cellular. The default is wan1. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceLossAndLatencyHistoryAsync($serial, $ip, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $uplink = null)
    {
        return $this->getDeviceLossAndLatencyHistoryAsyncWithHttpInfo($serial, $ip, $t0, $t1, $timespan, $resolution, $uplink)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceLossAndLatencyHistoryAsyncWithHttpInfo
     *
     * Get the uplink loss percentage and latency in milliseconds, and goodput in kilobits per second for a wired network device.
     *
     * @param  string $serial (required)
     * @param  string $ip The destination IP used to obtain the requested stats. This is required. (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 600, 3600, 86400. The default is 60. (optional)
     * @param  string $uplink The WAN uplink used to obtain the requested stats. Valid uplinks are wan1, wan2, cellular. The default is wan1. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceLossAndLatencyHistoryAsyncWithHttpInfo($serial, $ip, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $uplink = null)
    {
        $returnType = 'object';
        $request = $this->getDeviceLossAndLatencyHistoryRequest($serial, $ip, $t0, $t1, $timespan, $resolution, $uplink);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceLossAndLatencyHistory'
     *
     * @param  string $serial (required)
     * @param  string $ip The destination IP used to obtain the requested stats. This is required. (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 600, 3600, 86400. The default is 60. (optional)
     * @param  string $uplink The WAN uplink used to obtain the requested stats. Valid uplinks are wan1, wan2, cellular. The default is wan1. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeviceLossAndLatencyHistoryRequest($serial, $ip, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $uplink = null)
    {
        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceLossAndLatencyHistory'
            );
        }
        // verify the required parameter 'ip' is set
        if ($ip === null || (is_array($ip) && count($ip) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ip when calling getDeviceLossAndLatencyHistory'
            );
        }

        $resourcePath = '/devices/{serial}/lossAndLatencyHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($resolution !== null) {
            $queryParams['resolution'] = ObjectSerializer::toQueryValue($resolution);
        }
        // query params
        if ($uplink !== null) {
            $queryParams['uplink'] = ObjectSerializer::toQueryValue($uplink);
        }
        // query params
        if ($ip !== null) {
            $queryParams['ip'] = ObjectSerializer::toQueryValue($ip);
        }

        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceSwitchPortsStatuses
     *
     * Return the status for all the ports of a switch
     *
     * @param  string $serial serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getDeviceSwitchPortsStatuses($serial, $t0 = null, $timespan = null)
    {
        list($response) = $this->getDeviceSwitchPortsStatusesWithHttpInfo($serial, $t0, $timespan);
        return $response;
    }

    /**
     * Operation getDeviceSwitchPortsStatusesWithHttpInfo
     *
     * Return the status for all the ports of a switch
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceSwitchPortsStatusesWithHttpInfo($serial, $t0 = null, $timespan = null)
    {
        $returnType = 'object';
        $request = $this->getDeviceSwitchPortsStatusesRequest($serial, $t0, $timespan);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceSwitchPortsStatusesAsync
     *
     * Return the status for all the ports of a switch
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceSwitchPortsStatusesAsync($serial, $t0 = null, $timespan = null)
    {
        return $this->getDeviceSwitchPortsStatusesAsyncWithHttpInfo($serial, $t0, $timespan)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceSwitchPortsStatusesAsyncWithHttpInfo
     *
     * Return the status for all the ports of a switch
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceSwitchPortsStatusesAsyncWithHttpInfo($serial, $t0 = null, $timespan = null)
    {
        $returnType = 'object';
        $request = $this->getDeviceSwitchPortsStatusesRequest($serial, $t0, $timespan);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceSwitchPortsStatuses'
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeviceSwitchPortsStatusesRequest($serial, $t0 = null, $timespan = null)
    {
        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceSwitchPortsStatuses'
            );
        }

        $resourcePath = '/devices/{serial}/switch/ports/statuses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }

        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceSwitchPortsStatusesPackets
     *
     * Return the packet counters for all the ports of a switch
     *
     * @param  string $serial serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 1 day from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 1 day. The default is 1 day. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getDeviceSwitchPortsStatusesPackets($serial, $t0 = null, $timespan = null)
    {
        list($response) = $this->getDeviceSwitchPortsStatusesPacketsWithHttpInfo($serial, $t0, $timespan);
        return $response;
    }

    /**
     * Operation getDeviceSwitchPortsStatusesPacketsWithHttpInfo
     *
     * Return the packet counters for all the ports of a switch
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 1 day from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 1 day. The default is 1 day. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceSwitchPortsStatusesPacketsWithHttpInfo($serial, $t0 = null, $timespan = null)
    {
        $returnType = 'object';
        $request = $this->getDeviceSwitchPortsStatusesPacketsRequest($serial, $t0, $timespan);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceSwitchPortsStatusesPacketsAsync
     *
     * Return the packet counters for all the ports of a switch
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 1 day from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 1 day. The default is 1 day. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceSwitchPortsStatusesPacketsAsync($serial, $t0 = null, $timespan = null)
    {
        return $this->getDeviceSwitchPortsStatusesPacketsAsyncWithHttpInfo($serial, $t0, $timespan)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceSwitchPortsStatusesPacketsAsyncWithHttpInfo
     *
     * Return the packet counters for all the ports of a switch
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 1 day from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 1 day. The default is 1 day. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceSwitchPortsStatusesPacketsAsyncWithHttpInfo($serial, $t0 = null, $timespan = null)
    {
        $returnType = 'object';
        $request = $this->getDeviceSwitchPortsStatusesPacketsRequest($serial, $t0, $timespan);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceSwitchPortsStatusesPackets'
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 1 day from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 1 day. The default is 1 day. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeviceSwitchPortsStatusesPacketsRequest($serial, $t0 = null, $timespan = null)
    {
        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceSwitchPortsStatusesPackets'
            );
        }

        $resourcePath = '/devices/{serial}/switch/ports/statuses/packets';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }

        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceWirelessConnectionStats
     *
     * Aggregated connectivity info for a given AP on this network
     *
     * @param  string $serial serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getDeviceWirelessConnectionStats($serial, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        list($response) = $this->getDeviceWirelessConnectionStatsWithHttpInfo($serial, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag);
        return $response;
    }

    /**
     * Operation getDeviceWirelessConnectionStatsWithHttpInfo
     *
     * Aggregated connectivity info for a given AP on this network
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceWirelessConnectionStatsWithHttpInfo($serial, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        $returnType = 'object';
        $request = $this->getDeviceWirelessConnectionStatsRequest($serial, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceWirelessConnectionStatsAsync
     *
     * Aggregated connectivity info for a given AP on this network
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceWirelessConnectionStatsAsync($serial, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        return $this->getDeviceWirelessConnectionStatsAsyncWithHttpInfo($serial, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceWirelessConnectionStatsAsyncWithHttpInfo
     *
     * Aggregated connectivity info for a given AP on this network
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceWirelessConnectionStatsAsyncWithHttpInfo($serial, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        $returnType = 'object';
        $request = $this->getDeviceWirelessConnectionStatsRequest($serial, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceWirelessConnectionStats'
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeviceWirelessConnectionStatsRequest($serial, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceWirelessConnectionStats'
            );
        }

        $resourcePath = '/devices/{serial}/wireless/connectionStats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }
        // query params
        if ($vlan !== null) {
            $queryParams['vlan'] = ObjectSerializer::toQueryValue($vlan);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }

        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceWirelessLatencyStats
     *
     * Aggregated latency info for a given AP on this network
     *
     * @param  string $serial serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getDeviceWirelessLatencyStats($serial, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        list($response) = $this->getDeviceWirelessLatencyStatsWithHttpInfo($serial, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields);
        return $response;
    }

    /**
     * Operation getDeviceWirelessLatencyStatsWithHttpInfo
     *
     * Aggregated latency info for a given AP on this network
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceWirelessLatencyStatsWithHttpInfo($serial, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        $returnType = 'object';
        $request = $this->getDeviceWirelessLatencyStatsRequest($serial, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceWirelessLatencyStatsAsync
     *
     * Aggregated latency info for a given AP on this network
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceWirelessLatencyStatsAsync($serial, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        return $this->getDeviceWirelessLatencyStatsAsyncWithHttpInfo($serial, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceWirelessLatencyStatsAsyncWithHttpInfo
     *
     * Aggregated latency info for a given AP on this network
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceWirelessLatencyStatsAsyncWithHttpInfo($serial, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        $returnType = 'object';
        $request = $this->getDeviceWirelessLatencyStatsRequest($serial, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceWirelessLatencyStats'
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeviceWirelessLatencyStatsRequest($serial, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceWirelessLatencyStats'
            );
        }

        $resourcePath = '/devices/{serial}/wireless/latencyStats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }
        // query params
        if ($vlan !== null) {
            $queryParams['vlan'] = ObjectSerializer::toQueryValue($vlan);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceWirelessStatus
     *
     * Return the SSID statuses of an access point
     *
     * @param  string $serial serial (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getDeviceWirelessStatus($serial)
    {
        list($response) = $this->getDeviceWirelessStatusWithHttpInfo($serial);
        return $response;
    }

    /**
     * Operation getDeviceWirelessStatusWithHttpInfo
     *
     * Return the SSID statuses of an access point
     *
     * @param  string $serial (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceWirelessStatusWithHttpInfo($serial)
    {
        $returnType = 'object';
        $request = $this->getDeviceWirelessStatusRequest($serial);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceWirelessStatusAsync
     *
     * Return the SSID statuses of an access point
     *
     * @param  string $serial (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceWirelessStatusAsync($serial)
    {
        return $this->getDeviceWirelessStatusAsyncWithHttpInfo($serial)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceWirelessStatusAsyncWithHttpInfo
     *
     * Return the SSID statuses of an access point
     *
     * @param  string $serial (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceWirelessStatusAsyncWithHttpInfo($serial)
    {
        $returnType = 'object';
        $request = $this->getDeviceWirelessStatusRequest($serial);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceWirelessStatus'
     *
     * @param  string $serial (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeviceWirelessStatusRequest($serial)
    {
        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceWirelessStatus'
            );
        }

        $resourcePath = '/devices/{serial}/wireless/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceClientSecurityEvents
     *
     * List the security events for a client
     *
     * @param  string $network_id network_id (required)
     * @param  string $client_id client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 791 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 31 days. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkApplianceClientSecurityEvents($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null)
    {
        list($response) = $this->getNetworkApplianceClientSecurityEventsWithHttpInfo($network_id, $client_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $sort_order);
        return $response;
    }

    /**
     * Operation getNetworkApplianceClientSecurityEventsWithHttpInfo
     *
     * List the security events for a client
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 791 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 31 days. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceClientSecurityEventsWithHttpInfo($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkApplianceClientSecurityEventsRequest($network_id, $client_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $sort_order);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceClientSecurityEventsAsync
     *
     * List the security events for a client
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 791 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 31 days. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceClientSecurityEventsAsync($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null)
    {
        return $this->getNetworkApplianceClientSecurityEventsAsyncWithHttpInfo($network_id, $client_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $sort_order)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceClientSecurityEventsAsyncWithHttpInfo
     *
     * List the security events for a client
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 791 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 31 days. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceClientSecurityEventsAsyncWithHttpInfo($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkApplianceClientSecurityEventsRequest($network_id, $client_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $sort_order);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceClientSecurityEvents'
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 791 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 31 days. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkApplianceClientSecurityEventsRequest($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceClientSecurityEvents'
            );
        }
        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling getNetworkApplianceClientSecurityEvents'
            );
        }

        $resourcePath = '/networks/{networkId}/appliance/clients/{clientId}/security/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['perPage'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($starting_after !== null) {
            $queryParams['startingAfter'] = ObjectSerializer::toQueryValue($starting_after);
        }
        // query params
        if ($ending_before !== null) {
            $queryParams['endingBefore'] = ObjectSerializer::toQueryValue($ending_before);
        }
        // query params
        if ($sort_order !== null) {
            $queryParams['sortOrder'] = ObjectSerializer::toQueryValue($sort_order);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkApplianceSecurityEvents
     *
     * List the security events for a network
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 365 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkApplianceSecurityEvents($network_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null)
    {
        list($response) = $this->getNetworkApplianceSecurityEventsWithHttpInfo($network_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $sort_order);
        return $response;
    }

    /**
     * Operation getNetworkApplianceSecurityEventsWithHttpInfo
     *
     * List the security events for a network
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 365 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkApplianceSecurityEventsWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkApplianceSecurityEventsRequest($network_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $sort_order);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkApplianceSecurityEventsAsync
     *
     * List the security events for a network
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 365 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceSecurityEventsAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null)
    {
        return $this->getNetworkApplianceSecurityEventsAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $sort_order)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkApplianceSecurityEventsAsyncWithHttpInfo
     *
     * List the security events for a network
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 365 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkApplianceSecurityEventsAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkApplianceSecurityEventsRequest($network_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $sort_order);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkApplianceSecurityEvents'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 365 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkApplianceSecurityEventsRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkApplianceSecurityEvents'
            );
        }

        $resourcePath = '/networks/{networkId}/appliance/security/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['perPage'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($starting_after !== null) {
            $queryParams['startingAfter'] = ObjectSerializer::toQueryValue($starting_after);
        }
        // query params
        if ($ending_before !== null) {
            $queryParams['endingBefore'] = ObjectSerializer::toQueryValue($ending_before);
        }
        // query params
        if ($sort_order !== null) {
            $queryParams['sortOrder'] = ObjectSerializer::toQueryValue($sort_order);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkBluetoothClient
     *
     * Return a Bluetooth client
     *
     * @param  string $network_id network_id (required)
     * @param  string $bluetooth_client_id bluetooth_client_id (required)
     * @param  bool $include_connectivity_history Include the connectivity history for this client (optional)
     * @param  int $connectivity_history_timespan The timespan, in seconds, for the connectivityHistory data. By default 1 day, 86400, will be used. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkBluetoothClient($network_id, $bluetooth_client_id, $include_connectivity_history = null, $connectivity_history_timespan = null)
    {
        list($response) = $this->getNetworkBluetoothClientWithHttpInfo($network_id, $bluetooth_client_id, $include_connectivity_history, $connectivity_history_timespan);
        return $response;
    }

    /**
     * Operation getNetworkBluetoothClientWithHttpInfo
     *
     * Return a Bluetooth client
     *
     * @param  string $network_id (required)
     * @param  string $bluetooth_client_id (required)
     * @param  bool $include_connectivity_history Include the connectivity history for this client (optional)
     * @param  int $connectivity_history_timespan The timespan, in seconds, for the connectivityHistory data. By default 1 day, 86400, will be used. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkBluetoothClientWithHttpInfo($network_id, $bluetooth_client_id, $include_connectivity_history = null, $connectivity_history_timespan = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkBluetoothClientRequest($network_id, $bluetooth_client_id, $include_connectivity_history, $connectivity_history_timespan);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkBluetoothClientAsync
     *
     * Return a Bluetooth client
     *
     * @param  string $network_id (required)
     * @param  string $bluetooth_client_id (required)
     * @param  bool $include_connectivity_history Include the connectivity history for this client (optional)
     * @param  int $connectivity_history_timespan The timespan, in seconds, for the connectivityHistory data. By default 1 day, 86400, will be used. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkBluetoothClientAsync($network_id, $bluetooth_client_id, $include_connectivity_history = null, $connectivity_history_timespan = null)
    {
        return $this->getNetworkBluetoothClientAsyncWithHttpInfo($network_id, $bluetooth_client_id, $include_connectivity_history, $connectivity_history_timespan)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkBluetoothClientAsyncWithHttpInfo
     *
     * Return a Bluetooth client
     *
     * @param  string $network_id (required)
     * @param  string $bluetooth_client_id (required)
     * @param  bool $include_connectivity_history Include the connectivity history for this client (optional)
     * @param  int $connectivity_history_timespan The timespan, in seconds, for the connectivityHistory data. By default 1 day, 86400, will be used. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkBluetoothClientAsyncWithHttpInfo($network_id, $bluetooth_client_id, $include_connectivity_history = null, $connectivity_history_timespan = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkBluetoothClientRequest($network_id, $bluetooth_client_id, $include_connectivity_history, $connectivity_history_timespan);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkBluetoothClient'
     *
     * @param  string $network_id (required)
     * @param  string $bluetooth_client_id (required)
     * @param  bool $include_connectivity_history Include the connectivity history for this client (optional)
     * @param  int $connectivity_history_timespan The timespan, in seconds, for the connectivityHistory data. By default 1 day, 86400, will be used. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkBluetoothClientRequest($network_id, $bluetooth_client_id, $include_connectivity_history = null, $connectivity_history_timespan = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkBluetoothClient'
            );
        }
        // verify the required parameter 'bluetooth_client_id' is set
        if ($bluetooth_client_id === null || (is_array($bluetooth_client_id) && count($bluetooth_client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $bluetooth_client_id when calling getNetworkBluetoothClient'
            );
        }

        $resourcePath = '/networks/{networkId}/bluetoothClients/{bluetoothClientId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_connectivity_history !== null) {
            $queryParams['includeConnectivityHistory'] = ObjectSerializer::toQueryValue($include_connectivity_history);
        }
        // query params
        if ($connectivity_history_timespan !== null) {
            $queryParams['connectivityHistoryTimespan'] = ObjectSerializer::toQueryValue($connectivity_history_timespan);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($bluetooth_client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'bluetoothClientId' . '}',
                ObjectSerializer::toPathValue($bluetooth_client_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkBluetoothClients
     *
     * List the Bluetooth clients seen by APs in this network
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 7 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 7 days. The default is 1 day. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 5 - 1000. Default is 10. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  bool $include_connectivity_history Include the connectivity history for this client (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkBluetoothClients($network_id, $t0 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $include_connectivity_history = null)
    {
        list($response) = $this->getNetworkBluetoothClientsWithHttpInfo($network_id, $t0, $timespan, $per_page, $starting_after, $ending_before, $include_connectivity_history);
        return $response;
    }

    /**
     * Operation getNetworkBluetoothClientsWithHttpInfo
     *
     * List the Bluetooth clients seen by APs in this network
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 7 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 7 days. The default is 1 day. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 5 - 1000. Default is 10. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  bool $include_connectivity_history Include the connectivity history for this client (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkBluetoothClientsWithHttpInfo($network_id, $t0 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $include_connectivity_history = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkBluetoothClientsRequest($network_id, $t0, $timespan, $per_page, $starting_after, $ending_before, $include_connectivity_history);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkBluetoothClientsAsync
     *
     * List the Bluetooth clients seen by APs in this network
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 7 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 7 days. The default is 1 day. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 5 - 1000. Default is 10. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  bool $include_connectivity_history Include the connectivity history for this client (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkBluetoothClientsAsync($network_id, $t0 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $include_connectivity_history = null)
    {
        return $this->getNetworkBluetoothClientsAsyncWithHttpInfo($network_id, $t0, $timespan, $per_page, $starting_after, $ending_before, $include_connectivity_history)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkBluetoothClientsAsyncWithHttpInfo
     *
     * List the Bluetooth clients seen by APs in this network
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 7 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 7 days. The default is 1 day. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 5 - 1000. Default is 10. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  bool $include_connectivity_history Include the connectivity history for this client (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkBluetoothClientsAsyncWithHttpInfo($network_id, $t0 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $include_connectivity_history = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkBluetoothClientsRequest($network_id, $t0, $timespan, $per_page, $starting_after, $ending_before, $include_connectivity_history);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkBluetoothClients'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 7 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 7 days. The default is 1 day. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 5 - 1000. Default is 10. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  bool $include_connectivity_history Include the connectivity history for this client (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkBluetoothClientsRequest($network_id, $t0 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $include_connectivity_history = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkBluetoothClients'
            );
        }

        $resourcePath = '/networks/{networkId}/bluetoothClients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['perPage'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($starting_after !== null) {
            $queryParams['startingAfter'] = ObjectSerializer::toQueryValue($starting_after);
        }
        // query params
        if ($ending_before !== null) {
            $queryParams['endingBefore'] = ObjectSerializer::toQueryValue($ending_before);
        }
        // query params
        if ($include_connectivity_history !== null) {
            $queryParams['includeConnectivityHistory'] = ObjectSerializer::toQueryValue($include_connectivity_history);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkClient
     *
     * Return the client associated with the given identifier
     *
     * @param  string $network_id network_id (required)
     * @param  string $client_id client_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkClient($network_id, $client_id)
    {
        list($response) = $this->getNetworkClientWithHttpInfo($network_id, $client_id);
        return $response;
    }

    /**
     * Operation getNetworkClientWithHttpInfo
     *
     * Return the client associated with the given identifier
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkClientWithHttpInfo($network_id, $client_id)
    {
        $returnType = 'object';
        $request = $this->getNetworkClientRequest($network_id, $client_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkClientAsync
     *
     * Return the client associated with the given identifier
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientAsync($network_id, $client_id)
    {
        return $this->getNetworkClientAsyncWithHttpInfo($network_id, $client_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkClientAsyncWithHttpInfo
     *
     * Return the client associated with the given identifier
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientAsyncWithHttpInfo($network_id, $client_id)
    {
        $returnType = 'object';
        $request = $this->getNetworkClientRequest($network_id, $client_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkClient'
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkClientRequest($network_id, $client_id)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkClient'
            );
        }
        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling getNetworkClient'
            );
        }

        $resourcePath = '/networks/{networkId}/clients/{clientId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkClientTrafficHistory
     *
     * Return the client's network traffic data over time
     *
     * @param  string $network_id network_id (required)
     * @param  string $client_id client_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkClientTrafficHistory($network_id, $client_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        list($response) = $this->getNetworkClientTrafficHistoryWithHttpInfo($network_id, $client_id, $per_page, $starting_after, $ending_before);
        return $response;
    }

    /**
     * Operation getNetworkClientTrafficHistoryWithHttpInfo
     *
     * Return the client's network traffic data over time
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkClientTrafficHistoryWithHttpInfo($network_id, $client_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkClientTrafficHistoryRequest($network_id, $client_id, $per_page, $starting_after, $ending_before);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkClientTrafficHistoryAsync
     *
     * Return the client's network traffic data over time
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientTrafficHistoryAsync($network_id, $client_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        return $this->getNetworkClientTrafficHistoryAsyncWithHttpInfo($network_id, $client_id, $per_page, $starting_after, $ending_before)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkClientTrafficHistoryAsyncWithHttpInfo
     *
     * Return the client's network traffic data over time
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientTrafficHistoryAsyncWithHttpInfo($network_id, $client_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkClientTrafficHistoryRequest($network_id, $client_id, $per_page, $starting_after, $ending_before);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkClientTrafficHistory'
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkClientTrafficHistoryRequest($network_id, $client_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkClientTrafficHistory'
            );
        }
        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling getNetworkClientTrafficHistory'
            );
        }

        $resourcePath = '/networks/{networkId}/clients/{clientId}/trafficHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($per_page !== null) {
            $queryParams['perPage'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($starting_after !== null) {
            $queryParams['startingAfter'] = ObjectSerializer::toQueryValue($starting_after);
        }
        // query params
        if ($ending_before !== null) {
            $queryParams['endingBefore'] = ObjectSerializer::toQueryValue($ending_before);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkClientUsageHistory
     *
     * Return the client's daily usage history
     *
     * @param  string $network_id network_id (required)
     * @param  string $client_id client_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkClientUsageHistory($network_id, $client_id)
    {
        list($response) = $this->getNetworkClientUsageHistoryWithHttpInfo($network_id, $client_id);
        return $response;
    }

    /**
     * Operation getNetworkClientUsageHistoryWithHttpInfo
     *
     * Return the client's daily usage history
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkClientUsageHistoryWithHttpInfo($network_id, $client_id)
    {
        $returnType = 'object';
        $request = $this->getNetworkClientUsageHistoryRequest($network_id, $client_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkClientUsageHistoryAsync
     *
     * Return the client's daily usage history
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientUsageHistoryAsync($network_id, $client_id)
    {
        return $this->getNetworkClientUsageHistoryAsyncWithHttpInfo($network_id, $client_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkClientUsageHistoryAsyncWithHttpInfo
     *
     * Return the client's daily usage history
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientUsageHistoryAsyncWithHttpInfo($network_id, $client_id)
    {
        $returnType = 'object';
        $request = $this->getNetworkClientUsageHistoryRequest($network_id, $client_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkClientUsageHistory'
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkClientUsageHistoryRequest($network_id, $client_id)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkClientUsageHistory'
            );
        }
        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling getNetworkClientUsageHistory'
            );
        }

        $resourcePath = '/networks/{networkId}/clients/{clientId}/usageHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkClients
     *
     * List the clients that have used this network in the timespan
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[] $statuses Filters clients based on status. Can be one of &#39;Online&#39; or &#39;Offline&#39;. (optional)
     * @param  string $ip Filters clients based on a partial or full match for the ip address field. (optional)
     * @param  string $ip6 Filters clients based on a partial or full match for the ip6 address field. (optional)
     * @param  string $ip6_local Filters clients based on a partial or full match for the ip6Local address field. (optional)
     * @param  string $mac Filters clients based on a partial or full match for the mac address field. (optional)
     * @param  string $os Filters clients based on a partial or full match for the os (operating system) field. (optional)
     * @param  string $description Filters clients based on a partial or full match for the description field. (optional)
     * @param  string[] $recent_device_connections Filters clients based on recent connection type. Can be one of &#39;Wired&#39; or &#39;Wireless&#39;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkClients($network_id, $t0 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $statuses = null, $ip = null, $ip6 = null, $ip6_local = null, $mac = null, $os = null, $description = null, $recent_device_connections = null)
    {
        list($response) = $this->getNetworkClientsWithHttpInfo($network_id, $t0, $timespan, $per_page, $starting_after, $ending_before, $statuses, $ip, $ip6, $ip6_local, $mac, $os, $description, $recent_device_connections);
        return $response;
    }

    /**
     * Operation getNetworkClientsWithHttpInfo
     *
     * List the clients that have used this network in the timespan
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[] $statuses Filters clients based on status. Can be one of &#39;Online&#39; or &#39;Offline&#39;. (optional)
     * @param  string $ip Filters clients based on a partial or full match for the ip address field. (optional)
     * @param  string $ip6 Filters clients based on a partial or full match for the ip6 address field. (optional)
     * @param  string $ip6_local Filters clients based on a partial or full match for the ip6Local address field. (optional)
     * @param  string $mac Filters clients based on a partial or full match for the mac address field. (optional)
     * @param  string $os Filters clients based on a partial or full match for the os (operating system) field. (optional)
     * @param  string $description Filters clients based on a partial or full match for the description field. (optional)
     * @param  string[] $recent_device_connections Filters clients based on recent connection type. Can be one of &#39;Wired&#39; or &#39;Wireless&#39;. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkClientsWithHttpInfo($network_id, $t0 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $statuses = null, $ip = null, $ip6 = null, $ip6_local = null, $mac = null, $os = null, $description = null, $recent_device_connections = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkClientsRequest($network_id, $t0, $timespan, $per_page, $starting_after, $ending_before, $statuses, $ip, $ip6, $ip6_local, $mac, $os, $description, $recent_device_connections);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkClientsAsync
     *
     * List the clients that have used this network in the timespan
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[] $statuses Filters clients based on status. Can be one of &#39;Online&#39; or &#39;Offline&#39;. (optional)
     * @param  string $ip Filters clients based on a partial or full match for the ip address field. (optional)
     * @param  string $ip6 Filters clients based on a partial or full match for the ip6 address field. (optional)
     * @param  string $ip6_local Filters clients based on a partial or full match for the ip6Local address field. (optional)
     * @param  string $mac Filters clients based on a partial or full match for the mac address field. (optional)
     * @param  string $os Filters clients based on a partial or full match for the os (operating system) field. (optional)
     * @param  string $description Filters clients based on a partial or full match for the description field. (optional)
     * @param  string[] $recent_device_connections Filters clients based on recent connection type. Can be one of &#39;Wired&#39; or &#39;Wireless&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientsAsync($network_id, $t0 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $statuses = null, $ip = null, $ip6 = null, $ip6_local = null, $mac = null, $os = null, $description = null, $recent_device_connections = null)
    {
        return $this->getNetworkClientsAsyncWithHttpInfo($network_id, $t0, $timespan, $per_page, $starting_after, $ending_before, $statuses, $ip, $ip6, $ip6_local, $mac, $os, $description, $recent_device_connections)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkClientsAsyncWithHttpInfo
     *
     * List the clients that have used this network in the timespan
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[] $statuses Filters clients based on status. Can be one of &#39;Online&#39; or &#39;Offline&#39;. (optional)
     * @param  string $ip Filters clients based on a partial or full match for the ip address field. (optional)
     * @param  string $ip6 Filters clients based on a partial or full match for the ip6 address field. (optional)
     * @param  string $ip6_local Filters clients based on a partial or full match for the ip6Local address field. (optional)
     * @param  string $mac Filters clients based on a partial or full match for the mac address field. (optional)
     * @param  string $os Filters clients based on a partial or full match for the os (operating system) field. (optional)
     * @param  string $description Filters clients based on a partial or full match for the description field. (optional)
     * @param  string[] $recent_device_connections Filters clients based on recent connection type. Can be one of &#39;Wired&#39; or &#39;Wireless&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientsAsyncWithHttpInfo($network_id, $t0 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $statuses = null, $ip = null, $ip6 = null, $ip6_local = null, $mac = null, $os = null, $description = null, $recent_device_connections = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkClientsRequest($network_id, $t0, $timespan, $per_page, $starting_after, $ending_before, $statuses, $ip, $ip6, $ip6_local, $mac, $os, $description, $recent_device_connections);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkClients'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[] $statuses Filters clients based on status. Can be one of &#39;Online&#39; or &#39;Offline&#39;. (optional)
     * @param  string $ip Filters clients based on a partial or full match for the ip address field. (optional)
     * @param  string $ip6 Filters clients based on a partial or full match for the ip6 address field. (optional)
     * @param  string $ip6_local Filters clients based on a partial or full match for the ip6Local address field. (optional)
     * @param  string $mac Filters clients based on a partial or full match for the mac address field. (optional)
     * @param  string $os Filters clients based on a partial or full match for the os (operating system) field. (optional)
     * @param  string $description Filters clients based on a partial or full match for the description field. (optional)
     * @param  string[] $recent_device_connections Filters clients based on recent connection type. Can be one of &#39;Wired&#39; or &#39;Wireless&#39;. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkClientsRequest($network_id, $t0 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $statuses = null, $ip = null, $ip6 = null, $ip6_local = null, $mac = null, $os = null, $description = null, $recent_device_connections = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkClients'
            );
        }

        $resourcePath = '/networks/{networkId}/clients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['perPage'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($starting_after !== null) {
            $queryParams['startingAfter'] = ObjectSerializer::toQueryValue($starting_after);
        }
        // query params
        if ($ending_before !== null) {
            $queryParams['endingBefore'] = ObjectSerializer::toQueryValue($ending_before);
        }
        // query params
        if (is_array($statuses)) {
            $queryParams['statuses'] = $statuses;
        } else
        if ($statuses !== null) {
            $queryParams['statuses'] = ObjectSerializer::toQueryValue($statuses);
        }
        // query params
        if ($ip !== null) {
            $queryParams['ip'] = ObjectSerializer::toQueryValue($ip);
        }
        // query params
        if ($ip6 !== null) {
            $queryParams['ip6'] = ObjectSerializer::toQueryValue($ip6);
        }
        // query params
        if ($ip6_local !== null) {
            $queryParams['ip6Local'] = ObjectSerializer::toQueryValue($ip6_local);
        }
        // query params
        if ($mac !== null) {
            $queryParams['mac'] = ObjectSerializer::toQueryValue($mac);
        }
        // query params
        if ($os !== null) {
            $queryParams['os'] = ObjectSerializer::toQueryValue($os);
        }
        // query params
        if ($description !== null) {
            $queryParams['description'] = ObjectSerializer::toQueryValue($description);
        }
        // query params
        if (is_array($recent_device_connections)) {
            $queryParams['recentDeviceConnections'] = $recent_device_connections;
        } else
        if ($recent_device_connections !== null) {
            $queryParams['recentDeviceConnections'] = ObjectSerializer::toQueryValue($recent_device_connections);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkClientsApplicationUsage
     *
     * Return the application usage data for clients
     *
     * @param  string $network_id network_id (required)
     * @param  string $clients A list of client keys, MACs or IPs separated by comma. (required)
     * @param  int $ssid_number An SSID number to include. If not specified, eveusage histories application usagents for all SSIDs will be returned. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkClientsApplicationUsage($network_id, $clients, $ssid_number = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null)
    {
        list($response) = $this->getNetworkClientsApplicationUsageWithHttpInfo($network_id, $clients, $ssid_number, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan);
        return $response;
    }

    /**
     * Operation getNetworkClientsApplicationUsageWithHttpInfo
     *
     * Return the application usage data for clients
     *
     * @param  string $network_id (required)
     * @param  string $clients A list of client keys, MACs or IPs separated by comma. (required)
     * @param  int $ssid_number An SSID number to include. If not specified, eveusage histories application usagents for all SSIDs will be returned. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkClientsApplicationUsageWithHttpInfo($network_id, $clients, $ssid_number = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkClientsApplicationUsageRequest($network_id, $clients, $ssid_number, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkClientsApplicationUsageAsync
     *
     * Return the application usage data for clients
     *
     * @param  string $network_id (required)
     * @param  string $clients A list of client keys, MACs or IPs separated by comma. (required)
     * @param  int $ssid_number An SSID number to include. If not specified, eveusage histories application usagents for all SSIDs will be returned. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientsApplicationUsageAsync($network_id, $clients, $ssid_number = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null)
    {
        return $this->getNetworkClientsApplicationUsageAsyncWithHttpInfo($network_id, $clients, $ssid_number, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkClientsApplicationUsageAsyncWithHttpInfo
     *
     * Return the application usage data for clients
     *
     * @param  string $network_id (required)
     * @param  string $clients A list of client keys, MACs or IPs separated by comma. (required)
     * @param  int $ssid_number An SSID number to include. If not specified, eveusage histories application usagents for all SSIDs will be returned. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientsApplicationUsageAsyncWithHttpInfo($network_id, $clients, $ssid_number = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkClientsApplicationUsageRequest($network_id, $clients, $ssid_number, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkClientsApplicationUsage'
     *
     * @param  string $network_id (required)
     * @param  string $clients A list of client keys, MACs or IPs separated by comma. (required)
     * @param  int $ssid_number An SSID number to include. If not specified, eveusage histories application usagents for all SSIDs will be returned. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkClientsApplicationUsageRequest($network_id, $clients, $ssid_number = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkClientsApplicationUsage'
            );
        }
        // verify the required parameter 'clients' is set
        if ($clients === null || (is_array($clients) && count($clients) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $clients when calling getNetworkClientsApplicationUsage'
            );
        }

        $resourcePath = '/networks/{networkId}/clients/applicationUsage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($clients !== null) {
            $queryParams['clients'] = ObjectSerializer::toQueryValue($clients);
        }
        // query params
        if ($ssid_number !== null) {
            $queryParams['ssidNumber'] = ObjectSerializer::toQueryValue($ssid_number);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['perPage'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($starting_after !== null) {
            $queryParams['startingAfter'] = ObjectSerializer::toQueryValue($starting_after);
        }
        // query params
        if ($ending_before !== null) {
            $queryParams['endingBefore'] = ObjectSerializer::toQueryValue($ending_before);
        }
        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkClientsOverview
     *
     * Return overview statistics for network clients
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 7200, 86400, 604800, 2592000. The default is 604800. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkClientsOverview($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null)
    {
        list($response) = $this->getNetworkClientsOverviewWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution);
        return $response;
    }

    /**
     * Operation getNetworkClientsOverviewWithHttpInfo
     *
     * Return overview statistics for network clients
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 7200, 86400, 604800, 2592000. The default is 604800. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkClientsOverviewWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkClientsOverviewRequest($network_id, $t0, $t1, $timespan, $resolution);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkClientsOverviewAsync
     *
     * Return overview statistics for network clients
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 7200, 86400, 604800, 2592000. The default is 604800. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientsOverviewAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null)
    {
        return $this->getNetworkClientsOverviewAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkClientsOverviewAsyncWithHttpInfo
     *
     * Return overview statistics for network clients
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 7200, 86400, 604800, 2592000. The default is 604800. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientsOverviewAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkClientsOverviewRequest($network_id, $t0, $t1, $timespan, $resolution);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkClientsOverview'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 7200, 86400, 604800, 2592000. The default is 604800. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkClientsOverviewRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkClientsOverview'
            );
        }

        $resourcePath = '/networks/{networkId}/clients/overview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($resolution !== null) {
            $queryParams['resolution'] = ObjectSerializer::toQueryValue($resolution);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkClientsUsageHistories
     *
     * Return the usage histories for clients
     *
     * @param  string $network_id network_id (required)
     * @param  string $clients A list of client keys, MACs or IPs separated by comma. (required)
     * @param  int $ssid_number An SSID number to include. If not specified, events for all SSIDs will be returned. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkClientsUsageHistories($network_id, $clients, $ssid_number = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null)
    {
        list($response) = $this->getNetworkClientsUsageHistoriesWithHttpInfo($network_id, $clients, $ssid_number, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan);
        return $response;
    }

    /**
     * Operation getNetworkClientsUsageHistoriesWithHttpInfo
     *
     * Return the usage histories for clients
     *
     * @param  string $network_id (required)
     * @param  string $clients A list of client keys, MACs or IPs separated by comma. (required)
     * @param  int $ssid_number An SSID number to include. If not specified, events for all SSIDs will be returned. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkClientsUsageHistoriesWithHttpInfo($network_id, $clients, $ssid_number = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkClientsUsageHistoriesRequest($network_id, $clients, $ssid_number, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkClientsUsageHistoriesAsync
     *
     * Return the usage histories for clients
     *
     * @param  string $network_id (required)
     * @param  string $clients A list of client keys, MACs or IPs separated by comma. (required)
     * @param  int $ssid_number An SSID number to include. If not specified, events for all SSIDs will be returned. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientsUsageHistoriesAsync($network_id, $clients, $ssid_number = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null)
    {
        return $this->getNetworkClientsUsageHistoriesAsyncWithHttpInfo($network_id, $clients, $ssid_number, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkClientsUsageHistoriesAsyncWithHttpInfo
     *
     * Return the usage histories for clients
     *
     * @param  string $network_id (required)
     * @param  string $clients A list of client keys, MACs or IPs separated by comma. (required)
     * @param  int $ssid_number An SSID number to include. If not specified, events for all SSIDs will be returned. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkClientsUsageHistoriesAsyncWithHttpInfo($network_id, $clients, $ssid_number = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkClientsUsageHistoriesRequest($network_id, $clients, $ssid_number, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkClientsUsageHistories'
     *
     * @param  string $network_id (required)
     * @param  string $clients A list of client keys, MACs or IPs separated by comma. (required)
     * @param  int $ssid_number An SSID number to include. If not specified, events for all SSIDs will be returned. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkClientsUsageHistoriesRequest($network_id, $clients, $ssid_number = null, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkClientsUsageHistories'
            );
        }
        // verify the required parameter 'clients' is set
        if ($clients === null || (is_array($clients) && count($clients) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $clients when calling getNetworkClientsUsageHistories'
            );
        }

        $resourcePath = '/networks/{networkId}/clients/usageHistories';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($clients !== null) {
            $queryParams['clients'] = ObjectSerializer::toQueryValue($clients);
        }
        // query params
        if ($ssid_number !== null) {
            $queryParams['ssidNumber'] = ObjectSerializer::toQueryValue($ssid_number);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['perPage'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($starting_after !== null) {
            $queryParams['startingAfter'] = ObjectSerializer::toQueryValue($starting_after);
        }
        // query params
        if ($ending_before !== null) {
            $queryParams['endingBefore'] = ObjectSerializer::toQueryValue($ending_before);
        }
        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkEvents
     *
     * List the events for the network
     *
     * @param  string $network_id network_id (required)
     * @param  string $product_type The product type to fetch events for. This parameter is required for networks with multiple device types. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, and environmental (optional)
     * @param  string[] $included_event_types A list of event types. The returned events will be filtered to only include events with these types. (optional)
     * @param  string[] $excluded_event_types A list of event types. The returned events will be filtered to exclude events with these types. (optional)
     * @param  string $device_mac The MAC address of the Meraki device which the list of events will be filtered with (optional)
     * @param  string $device_serial The serial of the Meraki device which the list of events will be filtered with (optional)
     * @param  string $device_name The name of the Meraki device which the list of events will be filtered with (optional)
     * @param  string $client_ip The IP of the client which the list of events will be filtered with. Only supported for track-by-IP networks. (optional)
     * @param  string $client_mac The MAC address of the client which the list of events will be filtered with. Only supported for track-by-MAC networks. (optional)
     * @param  string $client_name The name, or partial name, of the client which the list of events will be filtered with (optional)
     * @param  string $sm_device_mac The MAC address of the Systems Manager device which the list of events will be filtered with (optional)
     * @param  string $sm_device_name The name of the Systems Manager device which the list of events will be filtered with (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkEvents($network_id, $product_type = null, $included_event_types = null, $excluded_event_types = null, $device_mac = null, $device_serial = null, $device_name = null, $client_ip = null, $client_mac = null, $client_name = null, $sm_device_mac = null, $sm_device_name = null, $per_page = null, $starting_after = null, $ending_before = null)
    {
        list($response) = $this->getNetworkEventsWithHttpInfo($network_id, $product_type, $included_event_types, $excluded_event_types, $device_mac, $device_serial, $device_name, $client_ip, $client_mac, $client_name, $sm_device_mac, $sm_device_name, $per_page, $starting_after, $ending_before);
        return $response;
    }

    /**
     * Operation getNetworkEventsWithHttpInfo
     *
     * List the events for the network
     *
     * @param  string $network_id (required)
     * @param  string $product_type The product type to fetch events for. This parameter is required for networks with multiple device types. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, and environmental (optional)
     * @param  string[] $included_event_types A list of event types. The returned events will be filtered to only include events with these types. (optional)
     * @param  string[] $excluded_event_types A list of event types. The returned events will be filtered to exclude events with these types. (optional)
     * @param  string $device_mac The MAC address of the Meraki device which the list of events will be filtered with (optional)
     * @param  string $device_serial The serial of the Meraki device which the list of events will be filtered with (optional)
     * @param  string $device_name The name of the Meraki device which the list of events will be filtered with (optional)
     * @param  string $client_ip The IP of the client which the list of events will be filtered with. Only supported for track-by-IP networks. (optional)
     * @param  string $client_mac The MAC address of the client which the list of events will be filtered with. Only supported for track-by-MAC networks. (optional)
     * @param  string $client_name The name, or partial name, of the client which the list of events will be filtered with (optional)
     * @param  string $sm_device_mac The MAC address of the Systems Manager device which the list of events will be filtered with (optional)
     * @param  string $sm_device_name The name of the Systems Manager device which the list of events will be filtered with (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkEventsWithHttpInfo($network_id, $product_type = null, $included_event_types = null, $excluded_event_types = null, $device_mac = null, $device_serial = null, $device_name = null, $client_ip = null, $client_mac = null, $client_name = null, $sm_device_mac = null, $sm_device_name = null, $per_page = null, $starting_after = null, $ending_before = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkEventsRequest($network_id, $product_type, $included_event_types, $excluded_event_types, $device_mac, $device_serial, $device_name, $client_ip, $client_mac, $client_name, $sm_device_mac, $sm_device_name, $per_page, $starting_after, $ending_before);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkEventsAsync
     *
     * List the events for the network
     *
     * @param  string $network_id (required)
     * @param  string $product_type The product type to fetch events for. This parameter is required for networks with multiple device types. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, and environmental (optional)
     * @param  string[] $included_event_types A list of event types. The returned events will be filtered to only include events with these types. (optional)
     * @param  string[] $excluded_event_types A list of event types. The returned events will be filtered to exclude events with these types. (optional)
     * @param  string $device_mac The MAC address of the Meraki device which the list of events will be filtered with (optional)
     * @param  string $device_serial The serial of the Meraki device which the list of events will be filtered with (optional)
     * @param  string $device_name The name of the Meraki device which the list of events will be filtered with (optional)
     * @param  string $client_ip The IP of the client which the list of events will be filtered with. Only supported for track-by-IP networks. (optional)
     * @param  string $client_mac The MAC address of the client which the list of events will be filtered with. Only supported for track-by-MAC networks. (optional)
     * @param  string $client_name The name, or partial name, of the client which the list of events will be filtered with (optional)
     * @param  string $sm_device_mac The MAC address of the Systems Manager device which the list of events will be filtered with (optional)
     * @param  string $sm_device_name The name of the Systems Manager device which the list of events will be filtered with (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkEventsAsync($network_id, $product_type = null, $included_event_types = null, $excluded_event_types = null, $device_mac = null, $device_serial = null, $device_name = null, $client_ip = null, $client_mac = null, $client_name = null, $sm_device_mac = null, $sm_device_name = null, $per_page = null, $starting_after = null, $ending_before = null)
    {
        return $this->getNetworkEventsAsyncWithHttpInfo($network_id, $product_type, $included_event_types, $excluded_event_types, $device_mac, $device_serial, $device_name, $client_ip, $client_mac, $client_name, $sm_device_mac, $sm_device_name, $per_page, $starting_after, $ending_before)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkEventsAsyncWithHttpInfo
     *
     * List the events for the network
     *
     * @param  string $network_id (required)
     * @param  string $product_type The product type to fetch events for. This parameter is required for networks with multiple device types. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, and environmental (optional)
     * @param  string[] $included_event_types A list of event types. The returned events will be filtered to only include events with these types. (optional)
     * @param  string[] $excluded_event_types A list of event types. The returned events will be filtered to exclude events with these types. (optional)
     * @param  string $device_mac The MAC address of the Meraki device which the list of events will be filtered with (optional)
     * @param  string $device_serial The serial of the Meraki device which the list of events will be filtered with (optional)
     * @param  string $device_name The name of the Meraki device which the list of events will be filtered with (optional)
     * @param  string $client_ip The IP of the client which the list of events will be filtered with. Only supported for track-by-IP networks. (optional)
     * @param  string $client_mac The MAC address of the client which the list of events will be filtered with. Only supported for track-by-MAC networks. (optional)
     * @param  string $client_name The name, or partial name, of the client which the list of events will be filtered with (optional)
     * @param  string $sm_device_mac The MAC address of the Systems Manager device which the list of events will be filtered with (optional)
     * @param  string $sm_device_name The name of the Systems Manager device which the list of events will be filtered with (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkEventsAsyncWithHttpInfo($network_id, $product_type = null, $included_event_types = null, $excluded_event_types = null, $device_mac = null, $device_serial = null, $device_name = null, $client_ip = null, $client_mac = null, $client_name = null, $sm_device_mac = null, $sm_device_name = null, $per_page = null, $starting_after = null, $ending_before = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkEventsRequest($network_id, $product_type, $included_event_types, $excluded_event_types, $device_mac, $device_serial, $device_name, $client_ip, $client_mac, $client_name, $sm_device_mac, $sm_device_name, $per_page, $starting_after, $ending_before);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkEvents'
     *
     * @param  string $network_id (required)
     * @param  string $product_type The product type to fetch events for. This parameter is required for networks with multiple device types. Valid types are wireless, appliance, switch, systemsManager, camera, cellularGateway, and environmental (optional)
     * @param  string[] $included_event_types A list of event types. The returned events will be filtered to only include events with these types. (optional)
     * @param  string[] $excluded_event_types A list of event types. The returned events will be filtered to exclude events with these types. (optional)
     * @param  string $device_mac The MAC address of the Meraki device which the list of events will be filtered with (optional)
     * @param  string $device_serial The serial of the Meraki device which the list of events will be filtered with (optional)
     * @param  string $device_name The name of the Meraki device which the list of events will be filtered with (optional)
     * @param  string $client_ip The IP of the client which the list of events will be filtered with. Only supported for track-by-IP networks. (optional)
     * @param  string $client_mac The MAC address of the client which the list of events will be filtered with. Only supported for track-by-MAC networks. (optional)
     * @param  string $client_name The name, or partial name, of the client which the list of events will be filtered with (optional)
     * @param  string $sm_device_mac The MAC address of the Systems Manager device which the list of events will be filtered with (optional)
     * @param  string $sm_device_name The name of the Systems Manager device which the list of events will be filtered with (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 10. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkEventsRequest($network_id, $product_type = null, $included_event_types = null, $excluded_event_types = null, $device_mac = null, $device_serial = null, $device_name = null, $client_ip = null, $client_mac = null, $client_name = null, $sm_device_mac = null, $sm_device_name = null, $per_page = null, $starting_after = null, $ending_before = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkEvents'
            );
        }

        $resourcePath = '/networks/{networkId}/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($product_type !== null) {
            $queryParams['productType'] = ObjectSerializer::toQueryValue($product_type);
        }
        // query params
        if (is_array($included_event_types)) {
            $queryParams['includedEventTypes'] = $included_event_types;
        } else
        if ($included_event_types !== null) {
            $queryParams['includedEventTypes'] = ObjectSerializer::toQueryValue($included_event_types);
        }
        // query params
        if (is_array($excluded_event_types)) {
            $queryParams['excludedEventTypes'] = $excluded_event_types;
        } else
        if ($excluded_event_types !== null) {
            $queryParams['excludedEventTypes'] = ObjectSerializer::toQueryValue($excluded_event_types);
        }
        // query params
        if ($device_mac !== null) {
            $queryParams['deviceMac'] = ObjectSerializer::toQueryValue($device_mac);
        }
        // query params
        if ($device_serial !== null) {
            $queryParams['deviceSerial'] = ObjectSerializer::toQueryValue($device_serial);
        }
        // query params
        if ($device_name !== null) {
            $queryParams['deviceName'] = ObjectSerializer::toQueryValue($device_name);
        }
        // query params
        if ($client_ip !== null) {
            $queryParams['clientIp'] = ObjectSerializer::toQueryValue($client_ip);
        }
        // query params
        if ($client_mac !== null) {
            $queryParams['clientMac'] = ObjectSerializer::toQueryValue($client_mac);
        }
        // query params
        if ($client_name !== null) {
            $queryParams['clientName'] = ObjectSerializer::toQueryValue($client_name);
        }
        // query params
        if ($sm_device_mac !== null) {
            $queryParams['smDeviceMac'] = ObjectSerializer::toQueryValue($sm_device_mac);
        }
        // query params
        if ($sm_device_name !== null) {
            $queryParams['smDeviceName'] = ObjectSerializer::toQueryValue($sm_device_name);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['perPage'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($starting_after !== null) {
            $queryParams['startingAfter'] = ObjectSerializer::toQueryValue($starting_after);
        }
        // query params
        if ($ending_before !== null) {
            $queryParams['endingBefore'] = ObjectSerializer::toQueryValue($ending_before);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkEventsEventTypes
     *
     * List the event type to human-readable description
     *
     * @param  string $network_id network_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkEventsEventTypes($network_id)
    {
        list($response) = $this->getNetworkEventsEventTypesWithHttpInfo($network_id);
        return $response;
    }

    /**
     * Operation getNetworkEventsEventTypesWithHttpInfo
     *
     * List the event type to human-readable description
     *
     * @param  string $network_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkEventsEventTypesWithHttpInfo($network_id)
    {
        $returnType = 'object';
        $request = $this->getNetworkEventsEventTypesRequest($network_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkEventsEventTypesAsync
     *
     * List the event type to human-readable description
     *
     * @param  string $network_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkEventsEventTypesAsync($network_id)
    {
        return $this->getNetworkEventsEventTypesAsyncWithHttpInfo($network_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkEventsEventTypesAsyncWithHttpInfo
     *
     * List the event type to human-readable description
     *
     * @param  string $network_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkEventsEventTypesAsyncWithHttpInfo($network_id)
    {
        $returnType = 'object';
        $request = $this->getNetworkEventsEventTypesRequest($network_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkEventsEventTypes'
     *
     * @param  string $network_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkEventsEventTypesRequest($network_id)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkEventsEventTypes'
            );
        }

        $resourcePath = '/networks/{networkId}/events/eventTypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkInsightApplicationHealthByTime
     *
     * Get application health by time
     *
     * @param  string $network_id network_id (required)
     * @param  string $application_id application_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 7 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. The default is 2 hours. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 300, 3600, 86400. The default is 300. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkInsightApplicationHealthByTime($network_id, $application_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null)
    {
        list($response) = $this->getNetworkInsightApplicationHealthByTimeWithHttpInfo($network_id, $application_id, $t0, $t1, $timespan, $resolution);
        return $response;
    }

    /**
     * Operation getNetworkInsightApplicationHealthByTimeWithHttpInfo
     *
     * Get application health by time
     *
     * @param  string $network_id (required)
     * @param  string $application_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 7 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. The default is 2 hours. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 300, 3600, 86400. The default is 300. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkInsightApplicationHealthByTimeWithHttpInfo($network_id, $application_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkInsightApplicationHealthByTimeRequest($network_id, $application_id, $t0, $t1, $timespan, $resolution);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkInsightApplicationHealthByTimeAsync
     *
     * Get application health by time
     *
     * @param  string $network_id (required)
     * @param  string $application_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 7 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. The default is 2 hours. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 300, 3600, 86400. The default is 300. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkInsightApplicationHealthByTimeAsync($network_id, $application_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null)
    {
        return $this->getNetworkInsightApplicationHealthByTimeAsyncWithHttpInfo($network_id, $application_id, $t0, $t1, $timespan, $resolution)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkInsightApplicationHealthByTimeAsyncWithHttpInfo
     *
     * Get application health by time
     *
     * @param  string $network_id (required)
     * @param  string $application_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 7 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. The default is 2 hours. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 300, 3600, 86400. The default is 300. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkInsightApplicationHealthByTimeAsyncWithHttpInfo($network_id, $application_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkInsightApplicationHealthByTimeRequest($network_id, $application_id, $t0, $t1, $timespan, $resolution);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkInsightApplicationHealthByTime'
     *
     * @param  string $network_id (required)
     * @param  string $application_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 7 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. The default is 2 hours. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 60, 300, 3600, 86400. The default is 300. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkInsightApplicationHealthByTimeRequest($network_id, $application_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkInsightApplicationHealthByTime'
            );
        }
        // verify the required parameter 'application_id' is set
        if ($application_id === null || (is_array($application_id) && count($application_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $application_id when calling getNetworkInsightApplicationHealthByTime'
            );
        }

        $resourcePath = '/networks/{networkId}/insight/applications/{applicationId}/healthByTime';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($resolution !== null) {
            $queryParams['resolution'] = ObjectSerializer::toQueryValue($resolution);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($application_id !== null) {
            $resourcePath = str_replace(
                '{' . 'applicationId' . '}',
                ObjectSerializer::toPathValue($application_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkNetworkHealthChannelUtilization
     *
     * Get the channel utilization over each radio for all APs in a network.
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 600. The default is 600. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 100. Default is 10. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkNetworkHealthChannelUtilization($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $per_page = null, $starting_after = null, $ending_before = null)
    {
        list($response) = $this->getNetworkNetworkHealthChannelUtilizationWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $per_page, $starting_after, $ending_before);
        return $response;
    }

    /**
     * Operation getNetworkNetworkHealthChannelUtilizationWithHttpInfo
     *
     * Get the channel utilization over each radio for all APs in a network.
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 600. The default is 600. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 100. Default is 10. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkNetworkHealthChannelUtilizationWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $per_page = null, $starting_after = null, $ending_before = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkNetworkHealthChannelUtilizationRequest($network_id, $t0, $t1, $timespan, $resolution, $per_page, $starting_after, $ending_before);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkNetworkHealthChannelUtilizationAsync
     *
     * Get the channel utilization over each radio for all APs in a network.
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 600. The default is 600. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 100. Default is 10. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkNetworkHealthChannelUtilizationAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $per_page = null, $starting_after = null, $ending_before = null)
    {
        return $this->getNetworkNetworkHealthChannelUtilizationAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $per_page, $starting_after, $ending_before)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkNetworkHealthChannelUtilizationAsyncWithHttpInfo
     *
     * Get the channel utilization over each radio for all APs in a network.
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 600. The default is 600. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 100. Default is 10. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkNetworkHealthChannelUtilizationAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $per_page = null, $starting_after = null, $ending_before = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkNetworkHealthChannelUtilizationRequest($network_id, $t0, $t1, $timespan, $resolution, $per_page, $starting_after, $ending_before);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkNetworkHealthChannelUtilization'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 600. The default is 600. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 100. Default is 10. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkNetworkHealthChannelUtilizationRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $per_page = null, $starting_after = null, $ending_before = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkNetworkHealthChannelUtilization'
            );
        }

        $resourcePath = '/networks/{networkId}/networkHealth/channelUtilization';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($resolution !== null) {
            $queryParams['resolution'] = ObjectSerializer::toQueryValue($resolution);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['perPage'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($starting_after !== null) {
            $queryParams['startingAfter'] = ObjectSerializer::toQueryValue($starting_after);
        }
        // query params
        if ($ending_before !== null) {
            $queryParams['endingBefore'] = ObjectSerializer::toQueryValue($ending_before);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkSmDeviceCellularUsageHistory
     *
     * Return the client's daily cellular data usage history
     *
     * @param  string $network_id network_id (required)
     * @param  string $device_id device_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkSmDeviceCellularUsageHistory($network_id, $device_id)
    {
        list($response) = $this->getNetworkSmDeviceCellularUsageHistoryWithHttpInfo($network_id, $device_id);
        return $response;
    }

    /**
     * Operation getNetworkSmDeviceCellularUsageHistoryWithHttpInfo
     *
     * Return the client's daily cellular data usage history
     *
     * @param  string $network_id (required)
     * @param  string $device_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkSmDeviceCellularUsageHistoryWithHttpInfo($network_id, $device_id)
    {
        $returnType = 'object';
        $request = $this->getNetworkSmDeviceCellularUsageHistoryRequest($network_id, $device_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkSmDeviceCellularUsageHistoryAsync
     *
     * Return the client's daily cellular data usage history
     *
     * @param  string $network_id (required)
     * @param  string $device_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDeviceCellularUsageHistoryAsync($network_id, $device_id)
    {
        return $this->getNetworkSmDeviceCellularUsageHistoryAsyncWithHttpInfo($network_id, $device_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkSmDeviceCellularUsageHistoryAsyncWithHttpInfo
     *
     * Return the client's daily cellular data usage history
     *
     * @param  string $network_id (required)
     * @param  string $device_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDeviceCellularUsageHistoryAsyncWithHttpInfo($network_id, $device_id)
    {
        $returnType = 'object';
        $request = $this->getNetworkSmDeviceCellularUsageHistoryRequest($network_id, $device_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkSmDeviceCellularUsageHistory'
     *
     * @param  string $network_id (required)
     * @param  string $device_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkSmDeviceCellularUsageHistoryRequest($network_id, $device_id)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkSmDeviceCellularUsageHistory'
            );
        }
        // verify the required parameter 'device_id' is set
        if ($device_id === null || (is_array($device_id) && count($device_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $device_id when calling getNetworkSmDeviceCellularUsageHistory'
            );
        }

        $resourcePath = '/networks/{networkId}/sm/devices/{deviceId}/cellularUsageHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($device_id !== null) {
            $resourcePath = str_replace(
                '{' . 'deviceId' . '}',
                ObjectSerializer::toPathValue($device_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkSmDeviceConnectivity
     *
     * Returns historical connectivity data (whether a device is regularly checking in to Dashboard).
     *
     * @param  string $network_id network_id (required)
     * @param  string $device_id device_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkSmDeviceConnectivity($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        list($response) = $this->getNetworkSmDeviceConnectivityWithHttpInfo($network_id, $device_id, $per_page, $starting_after, $ending_before);
        return $response;
    }

    /**
     * Operation getNetworkSmDeviceConnectivityWithHttpInfo
     *
     * Returns historical connectivity data (whether a device is regularly checking in to Dashboard).
     *
     * @param  string $network_id (required)
     * @param  string $device_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkSmDeviceConnectivityWithHttpInfo($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkSmDeviceConnectivityRequest($network_id, $device_id, $per_page, $starting_after, $ending_before);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkSmDeviceConnectivityAsync
     *
     * Returns historical connectivity data (whether a device is regularly checking in to Dashboard).
     *
     * @param  string $network_id (required)
     * @param  string $device_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDeviceConnectivityAsync($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        return $this->getNetworkSmDeviceConnectivityAsyncWithHttpInfo($network_id, $device_id, $per_page, $starting_after, $ending_before)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkSmDeviceConnectivityAsyncWithHttpInfo
     *
     * Returns historical connectivity data (whether a device is regularly checking in to Dashboard).
     *
     * @param  string $network_id (required)
     * @param  string $device_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDeviceConnectivityAsyncWithHttpInfo($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkSmDeviceConnectivityRequest($network_id, $device_id, $per_page, $starting_after, $ending_before);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkSmDeviceConnectivity'
     *
     * @param  string $network_id (required)
     * @param  string $device_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkSmDeviceConnectivityRequest($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkSmDeviceConnectivity'
            );
        }
        // verify the required parameter 'device_id' is set
        if ($device_id === null || (is_array($device_id) && count($device_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $device_id when calling getNetworkSmDeviceConnectivity'
            );
        }

        $resourcePath = '/networks/{networkId}/sm/devices/{deviceId}/connectivity';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($per_page !== null) {
            $queryParams['perPage'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($starting_after !== null) {
            $queryParams['startingAfter'] = ObjectSerializer::toQueryValue($starting_after);
        }
        // query params
        if ($ending_before !== null) {
            $queryParams['endingBefore'] = ObjectSerializer::toQueryValue($ending_before);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($device_id !== null) {
            $resourcePath = str_replace(
                '{' . 'deviceId' . '}',
                ObjectSerializer::toPathValue($device_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkSmDeviceDesktopLogs
     *
     * Return historical records of various Systems Manager network connection details for desktop devices.
     *
     * @param  string $network_id network_id (required)
     * @param  string $device_id device_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkSmDeviceDesktopLogs($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        list($response) = $this->getNetworkSmDeviceDesktopLogsWithHttpInfo($network_id, $device_id, $per_page, $starting_after, $ending_before);
        return $response;
    }

    /**
     * Operation getNetworkSmDeviceDesktopLogsWithHttpInfo
     *
     * Return historical records of various Systems Manager network connection details for desktop devices.
     *
     * @param  string $network_id (required)
     * @param  string $device_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkSmDeviceDesktopLogsWithHttpInfo($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkSmDeviceDesktopLogsRequest($network_id, $device_id, $per_page, $starting_after, $ending_before);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkSmDeviceDesktopLogsAsync
     *
     * Return historical records of various Systems Manager network connection details for desktop devices.
     *
     * @param  string $network_id (required)
     * @param  string $device_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDeviceDesktopLogsAsync($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        return $this->getNetworkSmDeviceDesktopLogsAsyncWithHttpInfo($network_id, $device_id, $per_page, $starting_after, $ending_before)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkSmDeviceDesktopLogsAsyncWithHttpInfo
     *
     * Return historical records of various Systems Manager network connection details for desktop devices.
     *
     * @param  string $network_id (required)
     * @param  string $device_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDeviceDesktopLogsAsyncWithHttpInfo($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkSmDeviceDesktopLogsRequest($network_id, $device_id, $per_page, $starting_after, $ending_before);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkSmDeviceDesktopLogs'
     *
     * @param  string $network_id (required)
     * @param  string $device_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkSmDeviceDesktopLogsRequest($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkSmDeviceDesktopLogs'
            );
        }
        // verify the required parameter 'device_id' is set
        if ($device_id === null || (is_array($device_id) && count($device_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $device_id when calling getNetworkSmDeviceDesktopLogs'
            );
        }

        $resourcePath = '/networks/{networkId}/sm/devices/{deviceId}/desktopLogs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($per_page !== null) {
            $queryParams['perPage'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($starting_after !== null) {
            $queryParams['startingAfter'] = ObjectSerializer::toQueryValue($starting_after);
        }
        // query params
        if ($ending_before !== null) {
            $queryParams['endingBefore'] = ObjectSerializer::toQueryValue($ending_before);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($device_id !== null) {
            $resourcePath = str_replace(
                '{' . 'deviceId' . '}',
                ObjectSerializer::toPathValue($device_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkSmDeviceDeviceCommandLogs
     *
     * Return historical records of commands sent to Systems Manager devices
     *
     * @param  string $network_id network_id (required)
     * @param  string $device_id device_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkSmDeviceDeviceCommandLogs($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        list($response) = $this->getNetworkSmDeviceDeviceCommandLogsWithHttpInfo($network_id, $device_id, $per_page, $starting_after, $ending_before);
        return $response;
    }

    /**
     * Operation getNetworkSmDeviceDeviceCommandLogsWithHttpInfo
     *
     * Return historical records of commands sent to Systems Manager devices
     *
     * @param  string $network_id (required)
     * @param  string $device_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkSmDeviceDeviceCommandLogsWithHttpInfo($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkSmDeviceDeviceCommandLogsRequest($network_id, $device_id, $per_page, $starting_after, $ending_before);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkSmDeviceDeviceCommandLogsAsync
     *
     * Return historical records of commands sent to Systems Manager devices
     *
     * @param  string $network_id (required)
     * @param  string $device_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDeviceDeviceCommandLogsAsync($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        return $this->getNetworkSmDeviceDeviceCommandLogsAsyncWithHttpInfo($network_id, $device_id, $per_page, $starting_after, $ending_before)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkSmDeviceDeviceCommandLogsAsyncWithHttpInfo
     *
     * Return historical records of commands sent to Systems Manager devices
     *
     * @param  string $network_id (required)
     * @param  string $device_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDeviceDeviceCommandLogsAsyncWithHttpInfo($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkSmDeviceDeviceCommandLogsRequest($network_id, $device_id, $per_page, $starting_after, $ending_before);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkSmDeviceDeviceCommandLogs'
     *
     * @param  string $network_id (required)
     * @param  string $device_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkSmDeviceDeviceCommandLogsRequest($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkSmDeviceDeviceCommandLogs'
            );
        }
        // verify the required parameter 'device_id' is set
        if ($device_id === null || (is_array($device_id) && count($device_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $device_id when calling getNetworkSmDeviceDeviceCommandLogs'
            );
        }

        $resourcePath = '/networks/{networkId}/sm/devices/{deviceId}/deviceCommandLogs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($per_page !== null) {
            $queryParams['perPage'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($starting_after !== null) {
            $queryParams['startingAfter'] = ObjectSerializer::toQueryValue($starting_after);
        }
        // query params
        if ($ending_before !== null) {
            $queryParams['endingBefore'] = ObjectSerializer::toQueryValue($ending_before);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($device_id !== null) {
            $resourcePath = str_replace(
                '{' . 'deviceId' . '}',
                ObjectSerializer::toPathValue($device_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkSmDevicePerformanceHistory
     *
     * Return historical records of various Systems Manager client metrics for desktop devices.
     *
     * @param  string $network_id network_id (required)
     * @param  string $device_id device_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkSmDevicePerformanceHistory($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        list($response) = $this->getNetworkSmDevicePerformanceHistoryWithHttpInfo($network_id, $device_id, $per_page, $starting_after, $ending_before);
        return $response;
    }

    /**
     * Operation getNetworkSmDevicePerformanceHistoryWithHttpInfo
     *
     * Return historical records of various Systems Manager client metrics for desktop devices.
     *
     * @param  string $network_id (required)
     * @param  string $device_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkSmDevicePerformanceHistoryWithHttpInfo($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkSmDevicePerformanceHistoryRequest($network_id, $device_id, $per_page, $starting_after, $ending_before);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkSmDevicePerformanceHistoryAsync
     *
     * Return historical records of various Systems Manager client metrics for desktop devices.
     *
     * @param  string $network_id (required)
     * @param  string $device_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDevicePerformanceHistoryAsync($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        return $this->getNetworkSmDevicePerformanceHistoryAsyncWithHttpInfo($network_id, $device_id, $per_page, $starting_after, $ending_before)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkSmDevicePerformanceHistoryAsyncWithHttpInfo
     *
     * Return historical records of various Systems Manager client metrics for desktop devices.
     *
     * @param  string $network_id (required)
     * @param  string $device_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSmDevicePerformanceHistoryAsyncWithHttpInfo($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkSmDevicePerformanceHistoryRequest($network_id, $device_id, $per_page, $starting_after, $ending_before);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkSmDevicePerformanceHistory'
     *
     * @param  string $network_id (required)
     * @param  string $device_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkSmDevicePerformanceHistoryRequest($network_id, $device_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkSmDevicePerformanceHistory'
            );
        }
        // verify the required parameter 'device_id' is set
        if ($device_id === null || (is_array($device_id) && count($device_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $device_id when calling getNetworkSmDevicePerformanceHistory'
            );
        }

        $resourcePath = '/networks/{networkId}/sm/devices/{deviceId}/performanceHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($per_page !== null) {
            $queryParams['perPage'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($starting_after !== null) {
            $queryParams['startingAfter'] = ObjectSerializer::toQueryValue($starting_after);
        }
        // query params
        if ($ending_before !== null) {
            $queryParams['endingBefore'] = ObjectSerializer::toQueryValue($ending_before);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($device_id !== null) {
            $resourcePath = str_replace(
                '{' . 'deviceId' . '}',
                ObjectSerializer::toPathValue($device_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkSplashLoginAttempts
     *
     * List the splash login attempts for a network
     *
     * @param  string $network_id network_id (required)
     * @param  int $ssid_number Only return the login attempts for the specified SSID (optional)
     * @param  string $login_identifier The username, email, or phone number used during login (optional)
     * @param  int $timespan The timespan, in seconds, for the login attempts. The period will be from [timespan] seconds ago until now. The maximum timespan is 3 months (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkSplashLoginAttempts($network_id, $ssid_number = null, $login_identifier = null, $timespan = null)
    {
        list($response) = $this->getNetworkSplashLoginAttemptsWithHttpInfo($network_id, $ssid_number, $login_identifier, $timespan);
        return $response;
    }

    /**
     * Operation getNetworkSplashLoginAttemptsWithHttpInfo
     *
     * List the splash login attempts for a network
     *
     * @param  string $network_id (required)
     * @param  int $ssid_number Only return the login attempts for the specified SSID (optional)
     * @param  string $login_identifier The username, email, or phone number used during login (optional)
     * @param  int $timespan The timespan, in seconds, for the login attempts. The period will be from [timespan] seconds ago until now. The maximum timespan is 3 months (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkSplashLoginAttemptsWithHttpInfo($network_id, $ssid_number = null, $login_identifier = null, $timespan = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkSplashLoginAttemptsRequest($network_id, $ssid_number, $login_identifier, $timespan);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkSplashLoginAttemptsAsync
     *
     * List the splash login attempts for a network
     *
     * @param  string $network_id (required)
     * @param  int $ssid_number Only return the login attempts for the specified SSID (optional)
     * @param  string $login_identifier The username, email, or phone number used during login (optional)
     * @param  int $timespan The timespan, in seconds, for the login attempts. The period will be from [timespan] seconds ago until now. The maximum timespan is 3 months (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSplashLoginAttemptsAsync($network_id, $ssid_number = null, $login_identifier = null, $timespan = null)
    {
        return $this->getNetworkSplashLoginAttemptsAsyncWithHttpInfo($network_id, $ssid_number, $login_identifier, $timespan)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkSplashLoginAttemptsAsyncWithHttpInfo
     *
     * List the splash login attempts for a network
     *
     * @param  string $network_id (required)
     * @param  int $ssid_number Only return the login attempts for the specified SSID (optional)
     * @param  string $login_identifier The username, email, or phone number used during login (optional)
     * @param  int $timespan The timespan, in seconds, for the login attempts. The period will be from [timespan] seconds ago until now. The maximum timespan is 3 months (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkSplashLoginAttemptsAsyncWithHttpInfo($network_id, $ssid_number = null, $login_identifier = null, $timespan = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkSplashLoginAttemptsRequest($network_id, $ssid_number, $login_identifier, $timespan);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkSplashLoginAttempts'
     *
     * @param  string $network_id (required)
     * @param  int $ssid_number Only return the login attempts for the specified SSID (optional)
     * @param  string $login_identifier The username, email, or phone number used during login (optional)
     * @param  int $timespan The timespan, in seconds, for the login attempts. The period will be from [timespan] seconds ago until now. The maximum timespan is 3 months (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkSplashLoginAttemptsRequest($network_id, $ssid_number = null, $login_identifier = null, $timespan = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkSplashLoginAttempts'
            );
        }

        $resourcePath = '/networks/{networkId}/splashLoginAttempts';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($ssid_number !== null) {
            $queryParams['ssidNumber'] = ObjectSerializer::toQueryValue($ssid_number);
        }
        // query params
        if ($login_identifier !== null) {
            $queryParams['loginIdentifier'] = ObjectSerializer::toQueryValue($login_identifier);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkTraffic
     *
     * Return the traffic analysis data for this network
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 30 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 30 days. (optional)
     * @param  string $device_type Filter the data by device type: &#39;combined&#39;, &#39;wireless&#39;, &#39;switch&#39; or &#39;appliance&#39;. Defaults to &#39;combined&#39;. When using &#39;combined&#39;, for each rule the data will come from the device type with the most usage. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkTraffic($network_id, $t0 = null, $timespan = null, $device_type = null)
    {
        list($response) = $this->getNetworkTrafficWithHttpInfo($network_id, $t0, $timespan, $device_type);
        return $response;
    }

    /**
     * Operation getNetworkTrafficWithHttpInfo
     *
     * Return the traffic analysis data for this network
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 30 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 30 days. (optional)
     * @param  string $device_type Filter the data by device type: &#39;combined&#39;, &#39;wireless&#39;, &#39;switch&#39; or &#39;appliance&#39;. Defaults to &#39;combined&#39;. When using &#39;combined&#39;, for each rule the data will come from the device type with the most usage. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkTrafficWithHttpInfo($network_id, $t0 = null, $timespan = null, $device_type = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkTrafficRequest($network_id, $t0, $timespan, $device_type);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkTrafficAsync
     *
     * Return the traffic analysis data for this network
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 30 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 30 days. (optional)
     * @param  string $device_type Filter the data by device type: &#39;combined&#39;, &#39;wireless&#39;, &#39;switch&#39; or &#39;appliance&#39;. Defaults to &#39;combined&#39;. When using &#39;combined&#39;, for each rule the data will come from the device type with the most usage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkTrafficAsync($network_id, $t0 = null, $timespan = null, $device_type = null)
    {
        return $this->getNetworkTrafficAsyncWithHttpInfo($network_id, $t0, $timespan, $device_type)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkTrafficAsyncWithHttpInfo
     *
     * Return the traffic analysis data for this network
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 30 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 30 days. (optional)
     * @param  string $device_type Filter the data by device type: &#39;combined&#39;, &#39;wireless&#39;, &#39;switch&#39; or &#39;appliance&#39;. Defaults to &#39;combined&#39;. When using &#39;combined&#39;, for each rule the data will come from the device type with the most usage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkTrafficAsyncWithHttpInfo($network_id, $t0 = null, $timespan = null, $device_type = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkTrafficRequest($network_id, $t0, $timespan, $device_type);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkTraffic'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 30 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 30 days. (optional)
     * @param  string $device_type Filter the data by device type: &#39;combined&#39;, &#39;wireless&#39;, &#39;switch&#39; or &#39;appliance&#39;. Defaults to &#39;combined&#39;. When using &#39;combined&#39;, for each rule the data will come from the device type with the most usage. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkTrafficRequest($network_id, $t0 = null, $timespan = null, $device_type = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkTraffic'
            );
        }

        $resourcePath = '/networks/{networkId}/traffic';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($device_type !== null) {
            $queryParams['deviceType'] = ObjectSerializer::toQueryValue($device_type);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessAirMarshal
     *
     * List Air Marshal scan results from a network
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessAirMarshal($network_id, $t0 = null, $timespan = null)
    {
        list($response) = $this->getNetworkWirelessAirMarshalWithHttpInfo($network_id, $t0, $timespan);
        return $response;
    }

    /**
     * Operation getNetworkWirelessAirMarshalWithHttpInfo
     *
     * List Air Marshal scan results from a network
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessAirMarshalWithHttpInfo($network_id, $t0 = null, $timespan = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessAirMarshalRequest($network_id, $t0, $timespan);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessAirMarshalAsync
     *
     * List Air Marshal scan results from a network
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessAirMarshalAsync($network_id, $t0 = null, $timespan = null)
    {
        return $this->getNetworkWirelessAirMarshalAsyncWithHttpInfo($network_id, $t0, $timespan)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessAirMarshalAsyncWithHttpInfo
     *
     * List Air Marshal scan results from a network
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessAirMarshalAsyncWithHttpInfo($network_id, $t0 = null, $timespan = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessAirMarshalRequest($network_id, $t0, $timespan);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessAirMarshal'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessAirMarshalRequest($network_id, $t0 = null, $timespan = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessAirMarshal'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/airMarshal';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessChannelUtilizationHistory
     *
     * Return AP channel utilization over time for a device or network client
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client to return per-device, per-band AP channel utilization metrics inner joined by the queried client&#39;s connection history. (optional)
     * @param  string $device_serial Filter results by device to return AP channel utilization metrics for the queried device; either :band or :clientId must be jointly specified. (optional)
     * @param  string $ap_tag Filter results by AP tag to return AP channel utilization metrics for devices labeled with the given tag; either :clientId or :deviceSerial must be jointly specified. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessChannelUtilizationHistory($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null)
    {
        list($response) = $this->getNetworkWirelessChannelUtilizationHistoryWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band);
        return $response;
    }

    /**
     * Operation getNetworkWirelessChannelUtilizationHistoryWithHttpInfo
     *
     * Return AP channel utilization over time for a device or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client to return per-device, per-band AP channel utilization metrics inner joined by the queried client&#39;s connection history. (optional)
     * @param  string $device_serial Filter results by device to return AP channel utilization metrics for the queried device; either :band or :clientId must be jointly specified. (optional)
     * @param  string $ap_tag Filter results by AP tag to return AP channel utilization metrics for devices labeled with the given tag; either :clientId or :deviceSerial must be jointly specified. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessChannelUtilizationHistoryWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessChannelUtilizationHistoryRequest($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessChannelUtilizationHistoryAsync
     *
     * Return AP channel utilization over time for a device or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client to return per-device, per-band AP channel utilization metrics inner joined by the queried client&#39;s connection history. (optional)
     * @param  string $device_serial Filter results by device to return AP channel utilization metrics for the queried device; either :band or :clientId must be jointly specified. (optional)
     * @param  string $ap_tag Filter results by AP tag to return AP channel utilization metrics for devices labeled with the given tag; either :clientId or :deviceSerial must be jointly specified. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessChannelUtilizationHistoryAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null)
    {
        return $this->getNetworkWirelessChannelUtilizationHistoryAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessChannelUtilizationHistoryAsyncWithHttpInfo
     *
     * Return AP channel utilization over time for a device or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client to return per-device, per-band AP channel utilization metrics inner joined by the queried client&#39;s connection history. (optional)
     * @param  string $device_serial Filter results by device to return AP channel utilization metrics for the queried device; either :band or :clientId must be jointly specified. (optional)
     * @param  string $ap_tag Filter results by AP tag to return AP channel utilization metrics for devices labeled with the given tag; either :clientId or :deviceSerial must be jointly specified. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessChannelUtilizationHistoryAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessChannelUtilizationHistoryRequest($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessChannelUtilizationHistory'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client to return per-device, per-band AP channel utilization metrics inner joined by the queried client&#39;s connection history. (optional)
     * @param  string $device_serial Filter results by device to return AP channel utilization metrics for the queried device; either :band or :clientId must be jointly specified. (optional)
     * @param  string $ap_tag Filter results by AP tag to return AP channel utilization metrics for devices labeled with the given tag; either :clientId or :deviceSerial must be jointly specified. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessChannelUtilizationHistoryRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessChannelUtilizationHistory'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/channelUtilizationHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($resolution !== null) {
            $queryParams['resolution'] = ObjectSerializer::toQueryValue($resolution);
        }
        // query params
        if ($auto_resolution !== null) {
            $queryParams['autoResolution'] = ObjectSerializer::toQueryValue($auto_resolution);
        }
        // query params
        if ($client_id !== null) {
            $queryParams['clientId'] = ObjectSerializer::toQueryValue($client_id);
        }
        // query params
        if ($device_serial !== null) {
            $queryParams['deviceSerial'] = ObjectSerializer::toQueryValue($device_serial);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessClientConnectionStats
     *
     * Aggregated connectivity info for a given client on this network
     *
     * @param  string $network_id network_id (required)
     * @param  string $client_id client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessClientConnectionStats($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        list($response) = $this->getNetworkWirelessClientConnectionStatsWithHttpInfo($network_id, $client_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag);
        return $response;
    }

    /**
     * Operation getNetworkWirelessClientConnectionStatsWithHttpInfo
     *
     * Aggregated connectivity info for a given client on this network
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessClientConnectionStatsWithHttpInfo($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessClientConnectionStatsRequest($network_id, $client_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessClientConnectionStatsAsync
     *
     * Aggregated connectivity info for a given client on this network
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientConnectionStatsAsync($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        return $this->getNetworkWirelessClientConnectionStatsAsyncWithHttpInfo($network_id, $client_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessClientConnectionStatsAsyncWithHttpInfo
     *
     * Aggregated connectivity info for a given client on this network
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientConnectionStatsAsyncWithHttpInfo($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessClientConnectionStatsRequest($network_id, $client_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessClientConnectionStats'
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessClientConnectionStatsRequest($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessClientConnectionStats'
            );
        }
        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling getNetworkWirelessClientConnectionStats'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/clients/{clientId}/connectionStats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }
        // query params
        if ($vlan !== null) {
            $queryParams['vlan'] = ObjectSerializer::toQueryValue($vlan);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessClientConnectivityEvents
     *
     * List the wireless connectivity events for a client within a network in the timespan.
     *
     * @param  string $network_id network_id (required)
     * @param  string $client_id client_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string[] $types A list of event types to include. If not specified, events of all types will be returned. Valid types are &#39;assoc&#39;, &#39;disassoc&#39;, &#39;auth&#39;, &#39;deauth&#39;, &#39;dns&#39;, &#39;dhcp&#39;, &#39;roam&#39;, &#39;connection&#39; and/or &#39;sticky&#39;. (optional)
     * @param  string[] $included_severities A list of severities to include. If not specified, events of all severities will be returned. Valid severities are &#39;good&#39;, &#39;info&#39;, &#39;warn&#39; and/or &#39;bad&#39;. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid_number An SSID number to include. If not specified, events for all SSIDs will be returned. (optional)
     * @param  string $device_serial Filter results by an AP&#39;s serial number. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessClientConnectivityEvents($network_id, $client_id, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $types = null, $included_severities = null, $band = null, $ssid_number = null, $device_serial = null)
    {
        list($response) = $this->getNetworkWirelessClientConnectivityEventsWithHttpInfo($network_id, $client_id, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $types, $included_severities, $band, $ssid_number, $device_serial);
        return $response;
    }

    /**
     * Operation getNetworkWirelessClientConnectivityEventsWithHttpInfo
     *
     * List the wireless connectivity events for a client within a network in the timespan.
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string[] $types A list of event types to include. If not specified, events of all types will be returned. Valid types are &#39;assoc&#39;, &#39;disassoc&#39;, &#39;auth&#39;, &#39;deauth&#39;, &#39;dns&#39;, &#39;dhcp&#39;, &#39;roam&#39;, &#39;connection&#39; and/or &#39;sticky&#39;. (optional)
     * @param  string[] $included_severities A list of severities to include. If not specified, events of all severities will be returned. Valid severities are &#39;good&#39;, &#39;info&#39;, &#39;warn&#39; and/or &#39;bad&#39;. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid_number An SSID number to include. If not specified, events for all SSIDs will be returned. (optional)
     * @param  string $device_serial Filter results by an AP&#39;s serial number. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessClientConnectivityEventsWithHttpInfo($network_id, $client_id, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $types = null, $included_severities = null, $band = null, $ssid_number = null, $device_serial = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessClientConnectivityEventsRequest($network_id, $client_id, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $types, $included_severities, $band, $ssid_number, $device_serial);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessClientConnectivityEventsAsync
     *
     * List the wireless connectivity events for a client within a network in the timespan.
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string[] $types A list of event types to include. If not specified, events of all types will be returned. Valid types are &#39;assoc&#39;, &#39;disassoc&#39;, &#39;auth&#39;, &#39;deauth&#39;, &#39;dns&#39;, &#39;dhcp&#39;, &#39;roam&#39;, &#39;connection&#39; and/or &#39;sticky&#39;. (optional)
     * @param  string[] $included_severities A list of severities to include. If not specified, events of all severities will be returned. Valid severities are &#39;good&#39;, &#39;info&#39;, &#39;warn&#39; and/or &#39;bad&#39;. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid_number An SSID number to include. If not specified, events for all SSIDs will be returned. (optional)
     * @param  string $device_serial Filter results by an AP&#39;s serial number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientConnectivityEventsAsync($network_id, $client_id, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $types = null, $included_severities = null, $band = null, $ssid_number = null, $device_serial = null)
    {
        return $this->getNetworkWirelessClientConnectivityEventsAsyncWithHttpInfo($network_id, $client_id, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $types, $included_severities, $band, $ssid_number, $device_serial)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessClientConnectivityEventsAsyncWithHttpInfo
     *
     * List the wireless connectivity events for a client within a network in the timespan.
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string[] $types A list of event types to include. If not specified, events of all types will be returned. Valid types are &#39;assoc&#39;, &#39;disassoc&#39;, &#39;auth&#39;, &#39;deauth&#39;, &#39;dns&#39;, &#39;dhcp&#39;, &#39;roam&#39;, &#39;connection&#39; and/or &#39;sticky&#39;. (optional)
     * @param  string[] $included_severities A list of severities to include. If not specified, events of all severities will be returned. Valid severities are &#39;good&#39;, &#39;info&#39;, &#39;warn&#39; and/or &#39;bad&#39;. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid_number An SSID number to include. If not specified, events for all SSIDs will be returned. (optional)
     * @param  string $device_serial Filter results by an AP&#39;s serial number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientConnectivityEventsAsyncWithHttpInfo($network_id, $client_id, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $types = null, $included_severities = null, $band = null, $ssid_number = null, $device_serial = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessClientConnectivityEventsRequest($network_id, $client_id, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $types, $included_severities, $band, $ssid_number, $device_serial);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessClientConnectivityEvents'
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string[] $types A list of event types to include. If not specified, events of all types will be returned. Valid types are &#39;assoc&#39;, &#39;disassoc&#39;, &#39;auth&#39;, &#39;deauth&#39;, &#39;dns&#39;, &#39;dhcp&#39;, &#39;roam&#39;, &#39;connection&#39; and/or &#39;sticky&#39;. (optional)
     * @param  string[] $included_severities A list of severities to include. If not specified, events of all severities will be returned. Valid severities are &#39;good&#39;, &#39;info&#39;, &#39;warn&#39; and/or &#39;bad&#39;. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid_number An SSID number to include. If not specified, events for all SSIDs will be returned. (optional)
     * @param  string $device_serial Filter results by an AP&#39;s serial number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessClientConnectivityEventsRequest($network_id, $client_id, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $types = null, $included_severities = null, $band = null, $ssid_number = null, $device_serial = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessClientConnectivityEvents'
            );
        }
        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling getNetworkWirelessClientConnectivityEvents'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/clients/{clientId}/connectivityEvents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($per_page !== null) {
            $queryParams['perPage'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($starting_after !== null) {
            $queryParams['startingAfter'] = ObjectSerializer::toQueryValue($starting_after);
        }
        // query params
        if ($ending_before !== null) {
            $queryParams['endingBefore'] = ObjectSerializer::toQueryValue($ending_before);
        }
        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if (is_array($types)) {
            $queryParams['types'] = $types;
        } else
        if ($types !== null) {
            $queryParams['types'] = ObjectSerializer::toQueryValue($types);
        }
        // query params
        if (is_array($included_severities)) {
            $queryParams['includedSeverities'] = $included_severities;
        } else
        if ($included_severities !== null) {
            $queryParams['includedSeverities'] = ObjectSerializer::toQueryValue($included_severities);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid_number !== null) {
            $queryParams['ssidNumber'] = ObjectSerializer::toQueryValue($ssid_number);
        }
        // query params
        if ($device_serial !== null) {
            $queryParams['deviceSerial'] = ObjectSerializer::toQueryValue($device_serial);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessClientCountHistory
     *
     * Return wireless client counts over time for a network, device, or network client
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client to return per-device client counts over time inner joined by the queried client&#39;s connection history. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessClientCountHistory($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        list($response) = $this->getNetworkWirelessClientCountHistoryWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid);
        return $response;
    }

    /**
     * Operation getNetworkWirelessClientCountHistoryWithHttpInfo
     *
     * Return wireless client counts over time for a network, device, or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client to return per-device client counts over time inner joined by the queried client&#39;s connection history. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessClientCountHistoryWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessClientCountHistoryRequest($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessClientCountHistoryAsync
     *
     * Return wireless client counts over time for a network, device, or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client to return per-device client counts over time inner joined by the queried client&#39;s connection history. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientCountHistoryAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        return $this->getNetworkWirelessClientCountHistoryAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessClientCountHistoryAsyncWithHttpInfo
     *
     * Return wireless client counts over time for a network, device, or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client to return per-device client counts over time inner joined by the queried client&#39;s connection history. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientCountHistoryAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessClientCountHistoryRequest($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessClientCountHistory'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client to return per-device client counts over time inner joined by the queried client&#39;s connection history. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessClientCountHistoryRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessClientCountHistory'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/clientCountHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($resolution !== null) {
            $queryParams['resolution'] = ObjectSerializer::toQueryValue($resolution);
        }
        // query params
        if ($auto_resolution !== null) {
            $queryParams['autoResolution'] = ObjectSerializer::toQueryValue($auto_resolution);
        }
        // query params
        if ($client_id !== null) {
            $queryParams['clientId'] = ObjectSerializer::toQueryValue($client_id);
        }
        // query params
        if ($device_serial !== null) {
            $queryParams['deviceSerial'] = ObjectSerializer::toQueryValue($device_serial);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessClientLatencyHistory
     *
     * Return the latency history for a client
     *
     * @param  string $network_id network_id (required)
     * @param  string $client_id client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 791 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 1 day. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 86400. The default is 86400. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessClientLatencyHistory($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null)
    {
        list($response) = $this->getNetworkWirelessClientLatencyHistoryWithHttpInfo($network_id, $client_id, $t0, $t1, $timespan, $resolution);
        return $response;
    }

    /**
     * Operation getNetworkWirelessClientLatencyHistoryWithHttpInfo
     *
     * Return the latency history for a client
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 791 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 1 day. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 86400. The default is 86400. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessClientLatencyHistoryWithHttpInfo($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessClientLatencyHistoryRequest($network_id, $client_id, $t0, $t1, $timespan, $resolution);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessClientLatencyHistoryAsync
     *
     * Return the latency history for a client
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 791 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 1 day. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 86400. The default is 86400. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientLatencyHistoryAsync($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null)
    {
        return $this->getNetworkWirelessClientLatencyHistoryAsyncWithHttpInfo($network_id, $client_id, $t0, $t1, $timespan, $resolution)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessClientLatencyHistoryAsyncWithHttpInfo
     *
     * Return the latency history for a client
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 791 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 1 day. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 86400. The default is 86400. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientLatencyHistoryAsyncWithHttpInfo($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessClientLatencyHistoryRequest($network_id, $client_id, $t0, $t1, $timespan, $resolution);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessClientLatencyHistory'
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 791 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 1 day. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 86400. The default is 86400. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessClientLatencyHistoryRequest($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessClientLatencyHistory'
            );
        }
        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling getNetworkWirelessClientLatencyHistory'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/clients/{clientId}/latencyHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($resolution !== null) {
            $queryParams['resolution'] = ObjectSerializer::toQueryValue($resolution);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessClientLatencyStats
     *
     * Aggregated latency info for a given client on this network
     *
     * @param  string $network_id network_id (required)
     * @param  string $client_id client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessClientLatencyStats($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        list($response) = $this->getNetworkWirelessClientLatencyStatsWithHttpInfo($network_id, $client_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields);
        return $response;
    }

    /**
     * Operation getNetworkWirelessClientLatencyStatsWithHttpInfo
     *
     * Aggregated latency info for a given client on this network
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessClientLatencyStatsWithHttpInfo($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessClientLatencyStatsRequest($network_id, $client_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessClientLatencyStatsAsync
     *
     * Aggregated latency info for a given client on this network
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientLatencyStatsAsync($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        return $this->getNetworkWirelessClientLatencyStatsAsyncWithHttpInfo($network_id, $client_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessClientLatencyStatsAsyncWithHttpInfo
     *
     * Aggregated latency info for a given client on this network
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientLatencyStatsAsyncWithHttpInfo($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessClientLatencyStatsRequest($network_id, $client_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessClientLatencyStats'
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessClientLatencyStatsRequest($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessClientLatencyStats'
            );
        }
        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling getNetworkWirelessClientLatencyStats'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/clients/{clientId}/latencyStats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }
        // query params
        if ($vlan !== null) {
            $queryParams['vlan'] = ObjectSerializer::toQueryValue($vlan);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessClientsConnectionStats
     *
     * Aggregated connectivity info for this network, grouped by clients
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessClientsConnectionStats($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        list($response) = $this->getNetworkWirelessClientsConnectionStatsWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag);
        return $response;
    }

    /**
     * Operation getNetworkWirelessClientsConnectionStatsWithHttpInfo
     *
     * Aggregated connectivity info for this network, grouped by clients
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessClientsConnectionStatsWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessClientsConnectionStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessClientsConnectionStatsAsync
     *
     * Aggregated connectivity info for this network, grouped by clients
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientsConnectionStatsAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        return $this->getNetworkWirelessClientsConnectionStatsAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessClientsConnectionStatsAsyncWithHttpInfo
     *
     * Aggregated connectivity info for this network, grouped by clients
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientsConnectionStatsAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessClientsConnectionStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessClientsConnectionStats'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessClientsConnectionStatsRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessClientsConnectionStats'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/clients/connectionStats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }
        // query params
        if ($vlan !== null) {
            $queryParams['vlan'] = ObjectSerializer::toQueryValue($vlan);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessClientsLatencyStats
     *
     * Aggregated latency info for this network, grouped by clients
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessClientsLatencyStats($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        list($response) = $this->getNetworkWirelessClientsLatencyStatsWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields);
        return $response;
    }

    /**
     * Operation getNetworkWirelessClientsLatencyStatsWithHttpInfo
     *
     * Aggregated latency info for this network, grouped by clients
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessClientsLatencyStatsWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessClientsLatencyStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessClientsLatencyStatsAsync
     *
     * Aggregated latency info for this network, grouped by clients
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientsLatencyStatsAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        return $this->getNetworkWirelessClientsLatencyStatsAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessClientsLatencyStatsAsyncWithHttpInfo
     *
     * Aggregated latency info for this network, grouped by clients
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientsLatencyStatsAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessClientsLatencyStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessClientsLatencyStats'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessClientsLatencyStatsRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessClientsLatencyStats'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/clients/latencyStats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }
        // query params
        if ($vlan !== null) {
            $queryParams['vlan'] = ObjectSerializer::toQueryValue($vlan);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessConnectionStats
     *
     * Aggregated connectivity info for this network
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessConnectionStats($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        list($response) = $this->getNetworkWirelessConnectionStatsWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag);
        return $response;
    }

    /**
     * Operation getNetworkWirelessConnectionStatsWithHttpInfo
     *
     * Aggregated connectivity info for this network
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessConnectionStatsWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessConnectionStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessConnectionStatsAsync
     *
     * Aggregated connectivity info for this network
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessConnectionStatsAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        return $this->getNetworkWirelessConnectionStatsAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessConnectionStatsAsyncWithHttpInfo
     *
     * Aggregated connectivity info for this network
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessConnectionStatsAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessConnectionStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessConnectionStats'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessConnectionStatsRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessConnectionStats'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/connectionStats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }
        // query params
        if ($vlan !== null) {
            $queryParams['vlan'] = ObjectSerializer::toQueryValue($vlan);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessDataRateHistory
     *
     * Return PHY data rates over time for a network, device, or network client
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessDataRateHistory($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        list($response) = $this->getNetworkWirelessDataRateHistoryWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid);
        return $response;
    }

    /**
     * Operation getNetworkWirelessDataRateHistoryWithHttpInfo
     *
     * Return PHY data rates over time for a network, device, or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessDataRateHistoryWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessDataRateHistoryRequest($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessDataRateHistoryAsync
     *
     * Return PHY data rates over time for a network, device, or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessDataRateHistoryAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        return $this->getNetworkWirelessDataRateHistoryAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessDataRateHistoryAsyncWithHttpInfo
     *
     * Return PHY data rates over time for a network, device, or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessDataRateHistoryAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessDataRateHistoryRequest($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessDataRateHistory'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessDataRateHistoryRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessDataRateHistory'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/dataRateHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($resolution !== null) {
            $queryParams['resolution'] = ObjectSerializer::toQueryValue($resolution);
        }
        // query params
        if ($auto_resolution !== null) {
            $queryParams['autoResolution'] = ObjectSerializer::toQueryValue($auto_resolution);
        }
        // query params
        if ($client_id !== null) {
            $queryParams['clientId'] = ObjectSerializer::toQueryValue($client_id);
        }
        // query params
        if ($device_serial !== null) {
            $queryParams['deviceSerial'] = ObjectSerializer::toQueryValue($device_serial);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessDevicesConnectionStats
     *
     * Aggregated connectivity info for this network, grouped by node
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessDevicesConnectionStats($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        list($response) = $this->getNetworkWirelessDevicesConnectionStatsWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag);
        return $response;
    }

    /**
     * Operation getNetworkWirelessDevicesConnectionStatsWithHttpInfo
     *
     * Aggregated connectivity info for this network, grouped by node
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessDevicesConnectionStatsWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessDevicesConnectionStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessDevicesConnectionStatsAsync
     *
     * Aggregated connectivity info for this network, grouped by node
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessDevicesConnectionStatsAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        return $this->getNetworkWirelessDevicesConnectionStatsAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessDevicesConnectionStatsAsyncWithHttpInfo
     *
     * Aggregated connectivity info for this network, grouped by node
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessDevicesConnectionStatsAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessDevicesConnectionStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessDevicesConnectionStats'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessDevicesConnectionStatsRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessDevicesConnectionStats'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/devices/connectionStats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }
        // query params
        if ($vlan !== null) {
            $queryParams['vlan'] = ObjectSerializer::toQueryValue($vlan);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessDevicesLatencyStats
     *
     * Aggregated latency info for this network, grouped by node
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessDevicesLatencyStats($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        list($response) = $this->getNetworkWirelessDevicesLatencyStatsWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields);
        return $response;
    }

    /**
     * Operation getNetworkWirelessDevicesLatencyStatsWithHttpInfo
     *
     * Aggregated latency info for this network, grouped by node
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessDevicesLatencyStatsWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessDevicesLatencyStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessDevicesLatencyStatsAsync
     *
     * Aggregated latency info for this network, grouped by node
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessDevicesLatencyStatsAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        return $this->getNetworkWirelessDevicesLatencyStatsAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessDevicesLatencyStatsAsyncWithHttpInfo
     *
     * Aggregated latency info for this network, grouped by node
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessDevicesLatencyStatsAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessDevicesLatencyStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessDevicesLatencyStats'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessDevicesLatencyStatsRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessDevicesLatencyStats'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/devices/latencyStats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }
        // query params
        if ($vlan !== null) {
            $queryParams['vlan'] = ObjectSerializer::toQueryValue($vlan);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessFailedConnections
     *
     * List of all failed client connection events on this network in a given time range
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $serial Filter by AP (optional)
     * @param  string $client_id Filter by client MAC (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessFailedConnections($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $serial = null, $client_id = null)
    {
        list($response) = $this->getNetworkWirelessFailedConnectionsWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $serial, $client_id);
        return $response;
    }

    /**
     * Operation getNetworkWirelessFailedConnectionsWithHttpInfo
     *
     * List of all failed client connection events on this network in a given time range
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $serial Filter by AP (optional)
     * @param  string $client_id Filter by client MAC (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessFailedConnectionsWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $serial = null, $client_id = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessFailedConnectionsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $serial, $client_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessFailedConnectionsAsync
     *
     * List of all failed client connection events on this network in a given time range
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $serial Filter by AP (optional)
     * @param  string $client_id Filter by client MAC (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessFailedConnectionsAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $serial = null, $client_id = null)
    {
        return $this->getNetworkWirelessFailedConnectionsAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $serial, $client_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessFailedConnectionsAsyncWithHttpInfo
     *
     * List of all failed client connection events on this network in a given time range
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $serial Filter by AP (optional)
     * @param  string $client_id Filter by client MAC (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessFailedConnectionsAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $serial = null, $client_id = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessFailedConnectionsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $serial, $client_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessFailedConnections'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $serial Filter by AP (optional)
     * @param  string $client_id Filter by client MAC (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessFailedConnectionsRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $serial = null, $client_id = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessFailedConnections'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/failedConnections';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }
        // query params
        if ($vlan !== null) {
            $queryParams['vlan'] = ObjectSerializer::toQueryValue($vlan);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }
        // query params
        if ($serial !== null) {
            $queryParams['serial'] = ObjectSerializer::toQueryValue($serial);
        }
        // query params
        if ($client_id !== null) {
            $queryParams['clientId'] = ObjectSerializer::toQueryValue($client_id);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessLatencyHistory
     *
     * Return average wireless latency over time for a network, device, or network client
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     * @param  string $access_category Filter by access category. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessLatencyHistory($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null, $access_category = null)
    {
        list($response) = $this->getNetworkWirelessLatencyHistoryWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid, $access_category);
        return $response;
    }

    /**
     * Operation getNetworkWirelessLatencyHistoryWithHttpInfo
     *
     * Return average wireless latency over time for a network, device, or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     * @param  string $access_category Filter by access category. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessLatencyHistoryWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null, $access_category = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessLatencyHistoryRequest($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid, $access_category);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessLatencyHistoryAsync
     *
     * Return average wireless latency over time for a network, device, or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     * @param  string $access_category Filter by access category. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessLatencyHistoryAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null, $access_category = null)
    {
        return $this->getNetworkWirelessLatencyHistoryAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid, $access_category)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessLatencyHistoryAsyncWithHttpInfo
     *
     * Return average wireless latency over time for a network, device, or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     * @param  string $access_category Filter by access category. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessLatencyHistoryAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null, $access_category = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessLatencyHistoryRequest($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid, $access_category);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessLatencyHistory'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     * @param  string $access_category Filter by access category. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessLatencyHistoryRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null, $access_category = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessLatencyHistory'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/latencyHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($resolution !== null) {
            $queryParams['resolution'] = ObjectSerializer::toQueryValue($resolution);
        }
        // query params
        if ($auto_resolution !== null) {
            $queryParams['autoResolution'] = ObjectSerializer::toQueryValue($auto_resolution);
        }
        // query params
        if ($client_id !== null) {
            $queryParams['clientId'] = ObjectSerializer::toQueryValue($client_id);
        }
        // query params
        if ($device_serial !== null) {
            $queryParams['deviceSerial'] = ObjectSerializer::toQueryValue($device_serial);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }
        // query params
        if ($access_category !== null) {
            $queryParams['accessCategory'] = ObjectSerializer::toQueryValue($access_category);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessLatencyStats
     *
     * Aggregated latency info for this network
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessLatencyStats($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        list($response) = $this->getNetworkWirelessLatencyStatsWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields);
        return $response;
    }

    /**
     * Operation getNetworkWirelessLatencyStatsWithHttpInfo
     *
     * Aggregated latency info for this network
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessLatencyStatsWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessLatencyStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessLatencyStatsAsync
     *
     * Aggregated latency info for this network
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessLatencyStatsAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        return $this->getNetworkWirelessLatencyStatsAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessLatencyStatsAsyncWithHttpInfo
     *
     * Aggregated latency info for this network
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessLatencyStatsAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessLatencyStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessLatencyStats'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessLatencyStatsRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessLatencyStats'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/latencyStats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }
        // query params
        if ($vlan !== null) {
            $queryParams['vlan'] = ObjectSerializer::toQueryValue($vlan);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessMeshStatuses
     *
     * List wireless mesh statuses for repeaters
     *
     * @param  string $network_id network_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 500. Default is 50. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessMeshStatuses($network_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        list($response) = $this->getNetworkWirelessMeshStatusesWithHttpInfo($network_id, $per_page, $starting_after, $ending_before);
        return $response;
    }

    /**
     * Operation getNetworkWirelessMeshStatusesWithHttpInfo
     *
     * List wireless mesh statuses for repeaters
     *
     * @param  string $network_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 500. Default is 50. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessMeshStatusesWithHttpInfo($network_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessMeshStatusesRequest($network_id, $per_page, $starting_after, $ending_before);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessMeshStatusesAsync
     *
     * List wireless mesh statuses for repeaters
     *
     * @param  string $network_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 500. Default is 50. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessMeshStatusesAsync($network_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        return $this->getNetworkWirelessMeshStatusesAsyncWithHttpInfo($network_id, $per_page, $starting_after, $ending_before)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessMeshStatusesAsyncWithHttpInfo
     *
     * List wireless mesh statuses for repeaters
     *
     * @param  string $network_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 500. Default is 50. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessMeshStatusesAsyncWithHttpInfo($network_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessMeshStatusesRequest($network_id, $per_page, $starting_after, $ending_before);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessMeshStatuses'
     *
     * @param  string $network_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 500. Default is 50. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessMeshStatusesRequest($network_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessMeshStatuses'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/meshStatuses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($per_page !== null) {
            $queryParams['perPage'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($starting_after !== null) {
            $queryParams['startingAfter'] = ObjectSerializer::toQueryValue($starting_after);
        }
        // query params
        if ($ending_before !== null) {
            $queryParams['endingBefore'] = ObjectSerializer::toQueryValue($ending_before);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessSignalQualityHistory
     *
     * Return signal quality (SNR/RSSI) over time for a device or network client
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessSignalQualityHistory($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        list($response) = $this->getNetworkWirelessSignalQualityHistoryWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid);
        return $response;
    }

    /**
     * Operation getNetworkWirelessSignalQualityHistoryWithHttpInfo
     *
     * Return signal quality (SNR/RSSI) over time for a device or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessSignalQualityHistoryWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSignalQualityHistoryRequest($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessSignalQualityHistoryAsync
     *
     * Return signal quality (SNR/RSSI) over time for a device or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSignalQualityHistoryAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        return $this->getNetworkWirelessSignalQualityHistoryAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessSignalQualityHistoryAsyncWithHttpInfo
     *
     * Return signal quality (SNR/RSSI) over time for a device or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSignalQualityHistoryAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSignalQualityHistoryRequest($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessSignalQualityHistory'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessSignalQualityHistoryRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessSignalQualityHistory'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/signalQualityHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($resolution !== null) {
            $queryParams['resolution'] = ObjectSerializer::toQueryValue($resolution);
        }
        // query params
        if ($auto_resolution !== null) {
            $queryParams['autoResolution'] = ObjectSerializer::toQueryValue($auto_resolution);
        }
        // query params
        if ($client_id !== null) {
            $queryParams['clientId'] = ObjectSerializer::toQueryValue($client_id);
        }
        // query params
        if ($device_serial !== null) {
            $queryParams['deviceSerial'] = ObjectSerializer::toQueryValue($device_serial);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessUsageHistory
     *
     * Return AP usage over time for a device or network client
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client to return per-device AP usage over time inner joined by the queried client&#39;s connection history. (optional)
     * @param  string $device_serial Filter results by device. Requires :band. (optional)
     * @param  string $ap_tag Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessUsageHistory($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        list($response) = $this->getNetworkWirelessUsageHistoryWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid);
        return $response;
    }

    /**
     * Operation getNetworkWirelessUsageHistoryWithHttpInfo
     *
     * Return AP usage over time for a device or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client to return per-device AP usage over time inner joined by the queried client&#39;s connection history. (optional)
     * @param  string $device_serial Filter results by device. Requires :band. (optional)
     * @param  string $ap_tag Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessUsageHistoryWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessUsageHistoryRequest($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessUsageHistoryAsync
     *
     * Return AP usage over time for a device or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client to return per-device AP usage over time inner joined by the queried client&#39;s connection history. (optional)
     * @param  string $device_serial Filter results by device. Requires :band. (optional)
     * @param  string $ap_tag Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessUsageHistoryAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        return $this->getNetworkWirelessUsageHistoryAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessUsageHistoryAsyncWithHttpInfo
     *
     * Return AP usage over time for a device or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client to return per-device AP usage over time inner joined by the queried client&#39;s connection history. (optional)
     * @param  string $device_serial Filter results by device. Requires :band. (optional)
     * @param  string $ap_tag Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessUsageHistoryAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessUsageHistoryRequest($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessUsageHistory'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client to return per-device AP usage over time inner joined by the queried client&#39;s connection history. (optional)
     * @param  string $device_serial Filter results by device. Requires :band. (optional)
     * @param  string $ap_tag Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessUsageHistoryRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessUsageHistory'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/usageHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($resolution !== null) {
            $queryParams['resolution'] = ObjectSerializer::toQueryValue($resolution);
        }
        // query params
        if ($auto_resolution !== null) {
            $queryParams['autoResolution'] = ObjectSerializer::toQueryValue($auto_resolution);
        }
        // query params
        if ($client_id !== null) {
            $queryParams['clientId'] = ObjectSerializer::toQueryValue($client_id);
        }
        // query params
        if ($device_serial !== null) {
            $queryParams['deviceSerial'] = ObjectSerializer::toQueryValue($device_serial);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationApiRequests
     *
     * List the API requests made by an organization
     *
     * @param  string $organization_id organization_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 31 days. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $admin_id Filter the results by the ID of the admin who made the API requests (optional)
     * @param  string $path Filter the results by the path of the API requests (optional)
     * @param  string $method Filter the results by the method of the API requests (must be &#39;GET&#39;, &#39;PUT&#39;, &#39;POST&#39; or &#39;DELETE&#39;) (optional)
     * @param  int $response_code Filter the results by the response code of the API requests (optional)
     * @param  string $source_ip Filter the results by the IP address of the originating API request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getOrganizationApiRequests($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $admin_id = null, $path = null, $method = null, $response_code = null, $source_ip = null)
    {
        list($response) = $this->getOrganizationApiRequestsWithHttpInfo($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $admin_id, $path, $method, $response_code, $source_ip);
        return $response;
    }

    /**
     * Operation getOrganizationApiRequestsWithHttpInfo
     *
     * List the API requests made by an organization
     *
     * @param  string $organization_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 31 days. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $admin_id Filter the results by the ID of the admin who made the API requests (optional)
     * @param  string $path Filter the results by the path of the API requests (optional)
     * @param  string $method Filter the results by the method of the API requests (must be &#39;GET&#39;, &#39;PUT&#39;, &#39;POST&#39; or &#39;DELETE&#39;) (optional)
     * @param  int $response_code Filter the results by the response code of the API requests (optional)
     * @param  string $source_ip Filter the results by the IP address of the originating API request (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationApiRequestsWithHttpInfo($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $admin_id = null, $path = null, $method = null, $response_code = null, $source_ip = null)
    {
        $returnType = 'object';
        $request = $this->getOrganizationApiRequestsRequest($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $admin_id, $path, $method, $response_code, $source_ip);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationApiRequestsAsync
     *
     * List the API requests made by an organization
     *
     * @param  string $organization_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 31 days. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $admin_id Filter the results by the ID of the admin who made the API requests (optional)
     * @param  string $path Filter the results by the path of the API requests (optional)
     * @param  string $method Filter the results by the method of the API requests (must be &#39;GET&#39;, &#39;PUT&#39;, &#39;POST&#39; or &#39;DELETE&#39;) (optional)
     * @param  int $response_code Filter the results by the response code of the API requests (optional)
     * @param  string $source_ip Filter the results by the IP address of the originating API request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApiRequestsAsync($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $admin_id = null, $path = null, $method = null, $response_code = null, $source_ip = null)
    {
        return $this->getOrganizationApiRequestsAsyncWithHttpInfo($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $admin_id, $path, $method, $response_code, $source_ip)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationApiRequestsAsyncWithHttpInfo
     *
     * List the API requests made by an organization
     *
     * @param  string $organization_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 31 days. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $admin_id Filter the results by the ID of the admin who made the API requests (optional)
     * @param  string $path Filter the results by the path of the API requests (optional)
     * @param  string $method Filter the results by the method of the API requests (must be &#39;GET&#39;, &#39;PUT&#39;, &#39;POST&#39; or &#39;DELETE&#39;) (optional)
     * @param  int $response_code Filter the results by the response code of the API requests (optional)
     * @param  string $source_ip Filter the results by the IP address of the originating API request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApiRequestsAsyncWithHttpInfo($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $admin_id = null, $path = null, $method = null, $response_code = null, $source_ip = null)
    {
        $returnType = 'object';
        $request = $this->getOrganizationApiRequestsRequest($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $admin_id, $path, $method, $response_code, $source_ip);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationApiRequests'
     *
     * @param  string $organization_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 31 days. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $admin_id Filter the results by the ID of the admin who made the API requests (optional)
     * @param  string $path Filter the results by the path of the API requests (optional)
     * @param  string $method Filter the results by the method of the API requests (must be &#39;GET&#39;, &#39;PUT&#39;, &#39;POST&#39; or &#39;DELETE&#39;) (optional)
     * @param  int $response_code Filter the results by the response code of the API requests (optional)
     * @param  string $source_ip Filter the results by the IP address of the originating API request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOrganizationApiRequestsRequest($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $admin_id = null, $path = null, $method = null, $response_code = null, $source_ip = null)
    {
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationApiRequests'
            );
        }

        $resourcePath = '/organizations/{organizationId}/apiRequests';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['perPage'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($starting_after !== null) {
            $queryParams['startingAfter'] = ObjectSerializer::toQueryValue($starting_after);
        }
        // query params
        if ($ending_before !== null) {
            $queryParams['endingBefore'] = ObjectSerializer::toQueryValue($ending_before);
        }
        // query params
        if ($admin_id !== null) {
            $queryParams['adminId'] = ObjectSerializer::toQueryValue($admin_id);
        }
        // query params
        if ($path !== null) {
            $queryParams['path'] = ObjectSerializer::toQueryValue($path);
        }
        // query params
        if ($method !== null) {
            $queryParams['method'] = ObjectSerializer::toQueryValue($method);
        }
        // query params
        if ($response_code !== null) {
            $queryParams['responseCode'] = ObjectSerializer::toQueryValue($response_code);
        }
        // query params
        if ($source_ip !== null) {
            $queryParams['sourceIp'] = ObjectSerializer::toQueryValue($source_ip);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationApiRequestsOverview
     *
     * Return an aggregated overview of API requests data
     *
     * @param  string $organization_id organization_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 31 days. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getOrganizationApiRequestsOverview($organization_id, $t0 = null, $t1 = null, $timespan = null)
    {
        list($response) = $this->getOrganizationApiRequestsOverviewWithHttpInfo($organization_id, $t0, $t1, $timespan);
        return $response;
    }

    /**
     * Operation getOrganizationApiRequestsOverviewWithHttpInfo
     *
     * Return an aggregated overview of API requests data
     *
     * @param  string $organization_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 31 days. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationApiRequestsOverviewWithHttpInfo($organization_id, $t0 = null, $t1 = null, $timespan = null)
    {
        $returnType = 'object';
        $request = $this->getOrganizationApiRequestsOverviewRequest($organization_id, $t0, $t1, $timespan);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationApiRequestsOverviewAsync
     *
     * Return an aggregated overview of API requests data
     *
     * @param  string $organization_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 31 days. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApiRequestsOverviewAsync($organization_id, $t0 = null, $t1 = null, $timespan = null)
    {
        return $this->getOrganizationApiRequestsOverviewAsyncWithHttpInfo($organization_id, $t0, $t1, $timespan)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationApiRequestsOverviewAsyncWithHttpInfo
     *
     * Return an aggregated overview of API requests data
     *
     * @param  string $organization_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 31 days. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApiRequestsOverviewAsyncWithHttpInfo($organization_id, $t0 = null, $t1 = null, $timespan = null)
    {
        $returnType = 'object';
        $request = $this->getOrganizationApiRequestsOverviewRequest($organization_id, $t0, $t1, $timespan);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationApiRequestsOverview'
     *
     * @param  string $organization_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 31 days. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOrganizationApiRequestsOverviewRequest($organization_id, $t0 = null, $t1 = null, $timespan = null)
    {
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationApiRequestsOverview'
            );
        }

        $resourcePath = '/organizations/{organizationId}/apiRequests/overview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationApplianceSecurityEvents
     *
     * List the security events for an organization
     *
     * @param  string $organization_id organization_id (required)
     * @param  string $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 365 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getOrganizationApplianceSecurityEvents($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null)
    {
        list($response) = $this->getOrganizationApplianceSecurityEventsWithHttpInfo($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $sort_order);
        return $response;
    }

    /**
     * Operation getOrganizationApplianceSecurityEventsWithHttpInfo
     *
     * List the security events for an organization
     *
     * @param  string $organization_id (required)
     * @param  string $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 365 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationApplianceSecurityEventsWithHttpInfo($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null)
    {
        $returnType = 'object';
        $request = $this->getOrganizationApplianceSecurityEventsRequest($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $sort_order);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationApplianceSecurityEventsAsync
     *
     * List the security events for an organization
     *
     * @param  string $organization_id (required)
     * @param  string $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 365 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceSecurityEventsAsync($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null)
    {
        return $this->getOrganizationApplianceSecurityEventsAsyncWithHttpInfo($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $sort_order)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationApplianceSecurityEventsAsyncWithHttpInfo
     *
     * List the security events for an organization
     *
     * @param  string $organization_id (required)
     * @param  string $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 365 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceSecurityEventsAsyncWithHttpInfo($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null)
    {
        $returnType = 'object';
        $request = $this->getOrganizationApplianceSecurityEventsRequest($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $sort_order);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationApplianceSecurityEvents'
     *
     * @param  string $organization_id (required)
     * @param  string $t0 The beginning of the timespan for the data. Data is gathered after the specified t0 value. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 365 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 31 days. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 100. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $sort_order Sorted order of security events based on event detection time. Order options are &#39;ascending&#39; or &#39;descending&#39;. Default is ascending order. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOrganizationApplianceSecurityEventsRequest($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $sort_order = null)
    {
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationApplianceSecurityEvents'
            );
        }

        $resourcePath = '/organizations/{organizationId}/appliance/security/events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['perPage'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($starting_after !== null) {
            $queryParams['startingAfter'] = ObjectSerializer::toQueryValue($starting_after);
        }
        // query params
        if ($ending_before !== null) {
            $queryParams['endingBefore'] = ObjectSerializer::toQueryValue($ending_before);
        }
        // query params
        if ($sort_order !== null) {
            $queryParams['sortOrder'] = ObjectSerializer::toQueryValue($sort_order);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationApplianceUplinkStatuses
     *
     * List the uplink status of every Meraki MX and Z series appliances in the organization
     *
     * @param  string $organization_id organization_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[] $network_ids A list of network IDs. The returned devices will be filtered to only include these networks. (optional)
     * @param  string[] $serials A list of serial numbers. The returned devices will be filtered to only include these serials. (optional)
     * @param  string[] $iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getOrganizationApplianceUplinkStatuses($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $iccids = null)
    {
        list($response) = $this->getOrganizationApplianceUplinkStatusesWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $serials, $iccids);
        return $response;
    }

    /**
     * Operation getOrganizationApplianceUplinkStatusesWithHttpInfo
     *
     * List the uplink status of every Meraki MX and Z series appliances in the organization
     *
     * @param  string $organization_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[] $network_ids A list of network IDs. The returned devices will be filtered to only include these networks. (optional)
     * @param  string[] $serials A list of serial numbers. The returned devices will be filtered to only include these serials. (optional)
     * @param  string[] $iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationApplianceUplinkStatusesWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $iccids = null)
    {
        $returnType = 'object';
        $request = $this->getOrganizationApplianceUplinkStatusesRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $serials, $iccids);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationApplianceUplinkStatusesAsync
     *
     * List the uplink status of every Meraki MX and Z series appliances in the organization
     *
     * @param  string $organization_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[] $network_ids A list of network IDs. The returned devices will be filtered to only include these networks. (optional)
     * @param  string[] $serials A list of serial numbers. The returned devices will be filtered to only include these serials. (optional)
     * @param  string[] $iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceUplinkStatusesAsync($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $iccids = null)
    {
        return $this->getOrganizationApplianceUplinkStatusesAsyncWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $serials, $iccids)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationApplianceUplinkStatusesAsyncWithHttpInfo
     *
     * List the uplink status of every Meraki MX and Z series appliances in the organization
     *
     * @param  string $organization_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[] $network_ids A list of network IDs. The returned devices will be filtered to only include these networks. (optional)
     * @param  string[] $serials A list of serial numbers. The returned devices will be filtered to only include these serials. (optional)
     * @param  string[] $iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceUplinkStatusesAsyncWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $iccids = null)
    {
        $returnType = 'object';
        $request = $this->getOrganizationApplianceUplinkStatusesRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $serials, $iccids);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationApplianceUplinkStatuses'
     *
     * @param  string $organization_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[] $network_ids A list of network IDs. The returned devices will be filtered to only include these networks. (optional)
     * @param  string[] $serials A list of serial numbers. The returned devices will be filtered to only include these serials. (optional)
     * @param  string[] $iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOrganizationApplianceUplinkStatusesRequest($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $iccids = null)
    {
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationApplianceUplinkStatuses'
            );
        }

        $resourcePath = '/organizations/{organizationId}/appliance/uplink/statuses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($per_page !== null) {
            $queryParams['perPage'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($starting_after !== null) {
            $queryParams['startingAfter'] = ObjectSerializer::toQueryValue($starting_after);
        }
        // query params
        if ($ending_before !== null) {
            $queryParams['endingBefore'] = ObjectSerializer::toQueryValue($ending_before);
        }
        // query params
        if (is_array($network_ids)) {
            $queryParams['networkIds'] = $network_ids;
        } else
        if ($network_ids !== null) {
            $queryParams['networkIds'] = ObjectSerializer::toQueryValue($network_ids);
        }
        // query params
        if (is_array($serials)) {
            $queryParams['serials'] = $serials;
        } else
        if ($serials !== null) {
            $queryParams['serials'] = ObjectSerializer::toQueryValue($serials);
        }
        // query params
        if (is_array($iccids)) {
            $queryParams['iccids'] = $iccids;
        } else
        if ($iccids !== null) {
            $queryParams['iccids'] = ObjectSerializer::toQueryValue($iccids);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationApplianceVpnStats
     *
     * Show VPN history stat for networks in an organization
     *
     * @param  string $organization_id organization_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 300. Default is 300. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[] $network_ids A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]&#x3D;N_12345678&amp;networkIds[]&#x3D;L_3456 (optional)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getOrganizationApplianceVpnStats($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $t0 = null, $t1 = null, $timespan = null)
    {
        list($response) = $this->getOrganizationApplianceVpnStatsWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $t0, $t1, $timespan);
        return $response;
    }

    /**
     * Operation getOrganizationApplianceVpnStatsWithHttpInfo
     *
     * Show VPN history stat for networks in an organization
     *
     * @param  string $organization_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 300. Default is 300. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[] $network_ids A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]&#x3D;N_12345678&amp;networkIds[]&#x3D;L_3456 (optional)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationApplianceVpnStatsWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $t0 = null, $t1 = null, $timespan = null)
    {
        $returnType = 'object';
        $request = $this->getOrganizationApplianceVpnStatsRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $t0, $t1, $timespan);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationApplianceVpnStatsAsync
     *
     * Show VPN history stat for networks in an organization
     *
     * @param  string $organization_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 300. Default is 300. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[] $network_ids A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]&#x3D;N_12345678&amp;networkIds[]&#x3D;L_3456 (optional)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceVpnStatsAsync($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $t0 = null, $t1 = null, $timespan = null)
    {
        return $this->getOrganizationApplianceVpnStatsAsyncWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $t0, $t1, $timespan)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationApplianceVpnStatsAsyncWithHttpInfo
     *
     * Show VPN history stat for networks in an organization
     *
     * @param  string $organization_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 300. Default is 300. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[] $network_ids A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]&#x3D;N_12345678&amp;networkIds[]&#x3D;L_3456 (optional)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceVpnStatsAsyncWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $t0 = null, $t1 = null, $timespan = null)
    {
        $returnType = 'object';
        $request = $this->getOrganizationApplianceVpnStatsRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $t0, $t1, $timespan);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationApplianceVpnStats'
     *
     * @param  string $organization_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 300. Default is 300. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[] $network_ids A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]&#x3D;N_12345678&amp;networkIds[]&#x3D;L_3456 (optional)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOrganizationApplianceVpnStatsRequest($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $t0 = null, $t1 = null, $timespan = null)
    {
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationApplianceVpnStats'
            );
        }

        $resourcePath = '/organizations/{organizationId}/appliance/vpn/stats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($per_page !== null) {
            $queryParams['perPage'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($starting_after !== null) {
            $queryParams['startingAfter'] = ObjectSerializer::toQueryValue($starting_after);
        }
        // query params
        if ($ending_before !== null) {
            $queryParams['endingBefore'] = ObjectSerializer::toQueryValue($ending_before);
        }
        // query params
        if (is_array($network_ids)) {
            $queryParams['networkIds'] = $network_ids;
        } else
        if ($network_ids !== null) {
            $queryParams['networkIds'] = ObjectSerializer::toQueryValue($network_ids);
        }
        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationApplianceVpnStatuses
     *
     * Show VPN status for networks in an organization
     *
     * @param  string $organization_id organization_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 300. Default is 300. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[] $network_ids A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]&#x3D;N_12345678&amp;networkIds[]&#x3D;L_3456 (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getOrganizationApplianceVpnStatuses($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null)
    {
        list($response) = $this->getOrganizationApplianceVpnStatusesWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids);
        return $response;
    }

    /**
     * Operation getOrganizationApplianceVpnStatusesWithHttpInfo
     *
     * Show VPN status for networks in an organization
     *
     * @param  string $organization_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 300. Default is 300. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[] $network_ids A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]&#x3D;N_12345678&amp;networkIds[]&#x3D;L_3456 (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationApplianceVpnStatusesWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null)
    {
        $returnType = 'object';
        $request = $this->getOrganizationApplianceVpnStatusesRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationApplianceVpnStatusesAsync
     *
     * Show VPN status for networks in an organization
     *
     * @param  string $organization_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 300. Default is 300. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[] $network_ids A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]&#x3D;N_12345678&amp;networkIds[]&#x3D;L_3456 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceVpnStatusesAsync($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null)
    {
        return $this->getOrganizationApplianceVpnStatusesAsyncWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationApplianceVpnStatusesAsyncWithHttpInfo
     *
     * Show VPN status for networks in an organization
     *
     * @param  string $organization_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 300. Default is 300. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[] $network_ids A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]&#x3D;N_12345678&amp;networkIds[]&#x3D;L_3456 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationApplianceVpnStatusesAsyncWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null)
    {
        $returnType = 'object';
        $request = $this->getOrganizationApplianceVpnStatusesRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationApplianceVpnStatuses'
     *
     * @param  string $organization_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 300. Default is 300. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[] $network_ids A list of Meraki network IDs to filter results to contain only specified networks. E.g.: networkIds[]&#x3D;N_12345678&amp;networkIds[]&#x3D;L_3456 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOrganizationApplianceVpnStatusesRequest($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null)
    {
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationApplianceVpnStatuses'
            );
        }

        $resourcePath = '/organizations/{organizationId}/appliance/vpn/statuses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($per_page !== null) {
            $queryParams['perPage'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($starting_after !== null) {
            $queryParams['startingAfter'] = ObjectSerializer::toQueryValue($starting_after);
        }
        // query params
        if ($ending_before !== null) {
            $queryParams['endingBefore'] = ObjectSerializer::toQueryValue($ending_before);
        }
        // query params
        if (is_array($network_ids)) {
            $queryParams['networkIds'] = $network_ids;
        } else
        if ($network_ids !== null) {
            $queryParams['networkIds'] = ObjectSerializer::toQueryValue($network_ids);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationCellularGatewayUplinkStatuses
     *
     * List the uplink status of every Meraki MG cellular gateway in the organization
     *
     * @param  string $organization_id organization_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[] $network_ids A list of network IDs. The returned devices will be filtered to only include these networks. (optional)
     * @param  string[] $serials A list of serial numbers. The returned devices will be filtered to only include these serials. (optional)
     * @param  string[] $iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getOrganizationCellularGatewayUplinkStatuses($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $iccids = null)
    {
        list($response) = $this->getOrganizationCellularGatewayUplinkStatusesWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $serials, $iccids);
        return $response;
    }

    /**
     * Operation getOrganizationCellularGatewayUplinkStatusesWithHttpInfo
     *
     * List the uplink status of every Meraki MG cellular gateway in the organization
     *
     * @param  string $organization_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[] $network_ids A list of network IDs. The returned devices will be filtered to only include these networks. (optional)
     * @param  string[] $serials A list of serial numbers. The returned devices will be filtered to only include these serials. (optional)
     * @param  string[] $iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationCellularGatewayUplinkStatusesWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $iccids = null)
    {
        $returnType = 'object';
        $request = $this->getOrganizationCellularGatewayUplinkStatusesRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $serials, $iccids);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationCellularGatewayUplinkStatusesAsync
     *
     * List the uplink status of every Meraki MG cellular gateway in the organization
     *
     * @param  string $organization_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[] $network_ids A list of network IDs. The returned devices will be filtered to only include these networks. (optional)
     * @param  string[] $serials A list of serial numbers. The returned devices will be filtered to only include these serials. (optional)
     * @param  string[] $iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationCellularGatewayUplinkStatusesAsync($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $iccids = null)
    {
        return $this->getOrganizationCellularGatewayUplinkStatusesAsyncWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $serials, $iccids)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationCellularGatewayUplinkStatusesAsyncWithHttpInfo
     *
     * List the uplink status of every Meraki MG cellular gateway in the organization
     *
     * @param  string $organization_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[] $network_ids A list of network IDs. The returned devices will be filtered to only include these networks. (optional)
     * @param  string[] $serials A list of serial numbers. The returned devices will be filtered to only include these serials. (optional)
     * @param  string[] $iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationCellularGatewayUplinkStatusesAsyncWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $iccids = null)
    {
        $returnType = 'object';
        $request = $this->getOrganizationCellularGatewayUplinkStatusesRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $serials, $iccids);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationCellularGatewayUplinkStatuses'
     *
     * @param  string $organization_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[] $network_ids A list of network IDs. The returned devices will be filtered to only include these networks. (optional)
     * @param  string[] $serials A list of serial numbers. The returned devices will be filtered to only include these serials. (optional)
     * @param  string[] $iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOrganizationCellularGatewayUplinkStatusesRequest($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $iccids = null)
    {
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationCellularGatewayUplinkStatuses'
            );
        }

        $resourcePath = '/organizations/{organizationId}/cellularGateway/uplink/statuses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($per_page !== null) {
            $queryParams['perPage'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($starting_after !== null) {
            $queryParams['startingAfter'] = ObjectSerializer::toQueryValue($starting_after);
        }
        // query params
        if ($ending_before !== null) {
            $queryParams['endingBefore'] = ObjectSerializer::toQueryValue($ending_before);
        }
        // query params
        if (is_array($network_ids)) {
            $queryParams['networkIds'] = $network_ids;
        } else
        if ($network_ids !== null) {
            $queryParams['networkIds'] = ObjectSerializer::toQueryValue($network_ids);
        }
        // query params
        if (is_array($serials)) {
            $queryParams['serials'] = $serials;
        } else
        if ($serials !== null) {
            $queryParams['serials'] = ObjectSerializer::toQueryValue($serials);
        }
        // query params
        if (is_array($iccids)) {
            $queryParams['iccids'] = $iccids;
        } else
        if ($iccids !== null) {
            $queryParams['iccids'] = ObjectSerializer::toQueryValue($iccids);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationConfigurationChanges
     *
     * View the Change Log for your organization
     *
     * @param  string $organization_id organization_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 365 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 365 days. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 5000. Default is 5000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $network_id Filters on the given network (optional)
     * @param  string $admin_id Filters on the given Admin (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getOrganizationConfigurationChanges($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $network_id = null, $admin_id = null)
    {
        list($response) = $this->getOrganizationConfigurationChangesWithHttpInfo($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $network_id, $admin_id);
        return $response;
    }

    /**
     * Operation getOrganizationConfigurationChangesWithHttpInfo
     *
     * View the Change Log for your organization
     *
     * @param  string $organization_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 365 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 365 days. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 5000. Default is 5000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $network_id Filters on the given network (optional)
     * @param  string $admin_id Filters on the given Admin (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationConfigurationChangesWithHttpInfo($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $network_id = null, $admin_id = null)
    {
        $returnType = 'object';
        $request = $this->getOrganizationConfigurationChangesRequest($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $network_id, $admin_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationConfigurationChangesAsync
     *
     * View the Change Log for your organization
     *
     * @param  string $organization_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 365 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 365 days. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 5000. Default is 5000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $network_id Filters on the given network (optional)
     * @param  string $admin_id Filters on the given Admin (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationConfigurationChangesAsync($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $network_id = null, $admin_id = null)
    {
        return $this->getOrganizationConfigurationChangesAsyncWithHttpInfo($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $network_id, $admin_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationConfigurationChangesAsyncWithHttpInfo
     *
     * View the Change Log for your organization
     *
     * @param  string $organization_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 365 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 365 days. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 5000. Default is 5000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $network_id Filters on the given network (optional)
     * @param  string $admin_id Filters on the given Admin (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationConfigurationChangesAsyncWithHttpInfo($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $network_id = null, $admin_id = null)
    {
        $returnType = 'object';
        $request = $this->getOrganizationConfigurationChangesRequest($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $network_id, $admin_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationConfigurationChanges'
     *
     * @param  string $organization_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 365 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 365 days. The default is 365 days. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 5000. Default is 5000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $network_id Filters on the given network (optional)
     * @param  string $admin_id Filters on the given Admin (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOrganizationConfigurationChangesRequest($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $network_id = null, $admin_id = null)
    {
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationConfigurationChanges'
            );
        }

        $resourcePath = '/organizations/{organizationId}/configurationChanges';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['perPage'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($starting_after !== null) {
            $queryParams['startingAfter'] = ObjectSerializer::toQueryValue($starting_after);
        }
        // query params
        if ($ending_before !== null) {
            $queryParams['endingBefore'] = ObjectSerializer::toQueryValue($ending_before);
        }
        // query params
        if ($network_id !== null) {
            $queryParams['networkId'] = ObjectSerializer::toQueryValue($network_id);
        }
        // query params
        if ($admin_id !== null) {
            $queryParams['adminId'] = ObjectSerializer::toQueryValue($admin_id);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationDevicesStatuses
     *
     * List the status of every Meraki device in the organization
     *
     * @param  string $organization_id organization_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getOrganizationDevicesStatuses($organization_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        list($response) = $this->getOrganizationDevicesStatusesWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before);
        return $response;
    }

    /**
     * Operation getOrganizationDevicesStatusesWithHttpInfo
     *
     * List the status of every Meraki device in the organization
     *
     * @param  string $organization_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationDevicesStatusesWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        $returnType = 'object';
        $request = $this->getOrganizationDevicesStatusesRequest($organization_id, $per_page, $starting_after, $ending_before);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationDevicesStatusesAsync
     *
     * List the status of every Meraki device in the organization
     *
     * @param  string $organization_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationDevicesStatusesAsync($organization_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        return $this->getOrganizationDevicesStatusesAsyncWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationDevicesStatusesAsyncWithHttpInfo
     *
     * List the status of every Meraki device in the organization
     *
     * @param  string $organization_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationDevicesStatusesAsyncWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        $returnType = 'object';
        $request = $this->getOrganizationDevicesStatusesRequest($organization_id, $per_page, $starting_after, $ending_before);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationDevicesStatuses'
     *
     * @param  string $organization_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOrganizationDevicesStatusesRequest($organization_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationDevicesStatuses'
            );
        }

        $resourcePath = '/organizations/{organizationId}/devices/statuses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($per_page !== null) {
            $queryParams['perPage'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($starting_after !== null) {
            $queryParams['startingAfter'] = ObjectSerializer::toQueryValue($starting_after);
        }
        // query params
        if ($ending_before !== null) {
            $queryParams['endingBefore'] = ObjectSerializer::toQueryValue($ending_before);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationDevicesUplinksLossAndLatency
     *
     * Return the uplink loss and latency for every MX in the organization from at latest 2 minutes ago
     *
     * @param  string $organization_id organization_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 5 minutes after t0. The latest possible time that t1 can be is 2 minutes into the past. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 5 minutes. The default is 5 minutes. (optional)
     * @param  string $uplink Optional filter for a specific WAN uplink. Valid uplinks are wan1, wan2, cellular. Default will return all uplinks. (optional)
     * @param  string $ip Optional filter for a specific destination IP. Default will return all destination IPs. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getOrganizationDevicesUplinksLossAndLatency($organization_id, $t0 = null, $t1 = null, $timespan = null, $uplink = null, $ip = null)
    {
        list($response) = $this->getOrganizationDevicesUplinksLossAndLatencyWithHttpInfo($organization_id, $t0, $t1, $timespan, $uplink, $ip);
        return $response;
    }

    /**
     * Operation getOrganizationDevicesUplinksLossAndLatencyWithHttpInfo
     *
     * Return the uplink loss and latency for every MX in the organization from at latest 2 minutes ago
     *
     * @param  string $organization_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 5 minutes after t0. The latest possible time that t1 can be is 2 minutes into the past. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 5 minutes. The default is 5 minutes. (optional)
     * @param  string $uplink Optional filter for a specific WAN uplink. Valid uplinks are wan1, wan2, cellular. Default will return all uplinks. (optional)
     * @param  string $ip Optional filter for a specific destination IP. Default will return all destination IPs. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationDevicesUplinksLossAndLatencyWithHttpInfo($organization_id, $t0 = null, $t1 = null, $timespan = null, $uplink = null, $ip = null)
    {
        $returnType = 'object';
        $request = $this->getOrganizationDevicesUplinksLossAndLatencyRequest($organization_id, $t0, $t1, $timespan, $uplink, $ip);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationDevicesUplinksLossAndLatencyAsync
     *
     * Return the uplink loss and latency for every MX in the organization from at latest 2 minutes ago
     *
     * @param  string $organization_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 5 minutes after t0. The latest possible time that t1 can be is 2 minutes into the past. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 5 minutes. The default is 5 minutes. (optional)
     * @param  string $uplink Optional filter for a specific WAN uplink. Valid uplinks are wan1, wan2, cellular. Default will return all uplinks. (optional)
     * @param  string $ip Optional filter for a specific destination IP. Default will return all destination IPs. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationDevicesUplinksLossAndLatencyAsync($organization_id, $t0 = null, $t1 = null, $timespan = null, $uplink = null, $ip = null)
    {
        return $this->getOrganizationDevicesUplinksLossAndLatencyAsyncWithHttpInfo($organization_id, $t0, $t1, $timespan, $uplink, $ip)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationDevicesUplinksLossAndLatencyAsyncWithHttpInfo
     *
     * Return the uplink loss and latency for every MX in the organization from at latest 2 minutes ago
     *
     * @param  string $organization_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 5 minutes after t0. The latest possible time that t1 can be is 2 minutes into the past. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 5 minutes. The default is 5 minutes. (optional)
     * @param  string $uplink Optional filter for a specific WAN uplink. Valid uplinks are wan1, wan2, cellular. Default will return all uplinks. (optional)
     * @param  string $ip Optional filter for a specific destination IP. Default will return all destination IPs. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationDevicesUplinksLossAndLatencyAsyncWithHttpInfo($organization_id, $t0 = null, $t1 = null, $timespan = null, $uplink = null, $ip = null)
    {
        $returnType = 'object';
        $request = $this->getOrganizationDevicesUplinksLossAndLatencyRequest($organization_id, $t0, $t1, $timespan, $uplink, $ip);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationDevicesUplinksLossAndLatency'
     *
     * @param  string $organization_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 365 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 5 minutes after t0. The latest possible time that t1 can be is 2 minutes into the past. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 5 minutes. The default is 5 minutes. (optional)
     * @param  string $uplink Optional filter for a specific WAN uplink. Valid uplinks are wan1, wan2, cellular. Default will return all uplinks. (optional)
     * @param  string $ip Optional filter for a specific destination IP. Default will return all destination IPs. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOrganizationDevicesUplinksLossAndLatencyRequest($organization_id, $t0 = null, $t1 = null, $timespan = null, $uplink = null, $ip = null)
    {
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationDevicesUplinksLossAndLatency'
            );
        }

        $resourcePath = '/organizations/{organizationId}/devices/uplinksLossAndLatency';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($uplink !== null) {
            $queryParams['uplink'] = ObjectSerializer::toQueryValue($uplink);
        }
        // query params
        if ($ip !== null) {
            $queryParams['ip'] = ObjectSerializer::toQueryValue($ip);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationLicensesOverview
     *
     * Return an overview of the license state for an organization
     *
     * @param  string $organization_id organization_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getOrganizationLicensesOverview($organization_id)
    {
        list($response) = $this->getOrganizationLicensesOverviewWithHttpInfo($organization_id);
        return $response;
    }

    /**
     * Operation getOrganizationLicensesOverviewWithHttpInfo
     *
     * Return an overview of the license state for an organization
     *
     * @param  string $organization_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationLicensesOverviewWithHttpInfo($organization_id)
    {
        $returnType = 'object';
        $request = $this->getOrganizationLicensesOverviewRequest($organization_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationLicensesOverviewAsync
     *
     * Return an overview of the license state for an organization
     *
     * @param  string $organization_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationLicensesOverviewAsync($organization_id)
    {
        return $this->getOrganizationLicensesOverviewAsyncWithHttpInfo($organization_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationLicensesOverviewAsyncWithHttpInfo
     *
     * Return an overview of the license state for an organization
     *
     * @param  string $organization_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationLicensesOverviewAsyncWithHttpInfo($organization_id)
    {
        $returnType = 'object';
        $request = $this->getOrganizationLicensesOverviewRequest($organization_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationLicensesOverview'
     *
     * @param  string $organization_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOrganizationLicensesOverviewRequest($organization_id)
    {
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationLicensesOverview'
            );
        }

        $resourcePath = '/organizations/{organizationId}/licenses/overview';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationOpenapiSpec
     *
     * Return the OpenAPI 2.0 Specification of the organization's API documentation in JSON
     *
     * @param  string $organization_id organization_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getOrganizationOpenapiSpec($organization_id)
    {
        list($response) = $this->getOrganizationOpenapiSpecWithHttpInfo($organization_id);
        return $response;
    }

    /**
     * Operation getOrganizationOpenapiSpecWithHttpInfo
     *
     * Return the OpenAPI 2.0 Specification of the organization's API documentation in JSON
     *
     * @param  string $organization_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationOpenapiSpecWithHttpInfo($organization_id)
    {
        $returnType = 'object';
        $request = $this->getOrganizationOpenapiSpecRequest($organization_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationOpenapiSpecAsync
     *
     * Return the OpenAPI 2.0 Specification of the organization's API documentation in JSON
     *
     * @param  string $organization_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationOpenapiSpecAsync($organization_id)
    {
        return $this->getOrganizationOpenapiSpecAsyncWithHttpInfo($organization_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationOpenapiSpecAsyncWithHttpInfo
     *
     * Return the OpenAPI 2.0 Specification of the organization's API documentation in JSON
     *
     * @param  string $organization_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationOpenapiSpecAsyncWithHttpInfo($organization_id)
    {
        $returnType = 'object';
        $request = $this->getOrganizationOpenapiSpecRequest($organization_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationOpenapiSpec'
     *
     * @param  string $organization_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOrganizationOpenapiSpecRequest($organization_id)
    {
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationOpenapiSpec'
            );
        }

        $resourcePath = '/organizations/{organizationId}/openapiSpec';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationUplinksStatuses
     *
     * List the uplink status of every Meraki MX, MG and Z series devices in the organization
     *
     * @param  string $organization_id organization_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[] $network_ids A list of network IDs. The returned devices will be filtered to only include these networks. (optional)
     * @param  string[] $serials A list of serial numbers. The returned devices will be filtered to only include these serials. (optional)
     * @param  string[] $iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getOrganizationUplinksStatuses($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $iccids = null)
    {
        list($response) = $this->getOrganizationUplinksStatusesWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $serials, $iccids);
        return $response;
    }

    /**
     * Operation getOrganizationUplinksStatusesWithHttpInfo
     *
     * List the uplink status of every Meraki MX, MG and Z series devices in the organization
     *
     * @param  string $organization_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[] $network_ids A list of network IDs. The returned devices will be filtered to only include these networks. (optional)
     * @param  string[] $serials A list of serial numbers. The returned devices will be filtered to only include these serials. (optional)
     * @param  string[] $iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationUplinksStatusesWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $iccids = null)
    {
        $returnType = 'object';
        $request = $this->getOrganizationUplinksStatusesRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $serials, $iccids);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationUplinksStatusesAsync
     *
     * List the uplink status of every Meraki MX, MG and Z series devices in the organization
     *
     * @param  string $organization_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[] $network_ids A list of network IDs. The returned devices will be filtered to only include these networks. (optional)
     * @param  string[] $serials A list of serial numbers. The returned devices will be filtered to only include these serials. (optional)
     * @param  string[] $iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationUplinksStatusesAsync($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $iccids = null)
    {
        return $this->getOrganizationUplinksStatusesAsyncWithHttpInfo($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $serials, $iccids)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationUplinksStatusesAsyncWithHttpInfo
     *
     * List the uplink status of every Meraki MX, MG and Z series devices in the organization
     *
     * @param  string $organization_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[] $network_ids A list of network IDs. The returned devices will be filtered to only include these networks. (optional)
     * @param  string[] $serials A list of serial numbers. The returned devices will be filtered to only include these serials. (optional)
     * @param  string[] $iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationUplinksStatusesAsyncWithHttpInfo($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $iccids = null)
    {
        $returnType = 'object';
        $request = $this->getOrganizationUplinksStatusesRequest($organization_id, $per_page, $starting_after, $ending_before, $network_ids, $serials, $iccids);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationUplinksStatuses'
     *
     * @param  string $organization_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string[] $network_ids A list of network IDs. The returned devices will be filtered to only include these networks. (optional)
     * @param  string[] $serials A list of serial numbers. The returned devices will be filtered to only include these serials. (optional)
     * @param  string[] $iccids A list of ICCIDs. The returned devices will be filtered to only include these ICCIDs. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOrganizationUplinksStatusesRequest($organization_id, $per_page = null, $starting_after = null, $ending_before = null, $network_ids = null, $serials = null, $iccids = null)
    {
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationUplinksStatuses'
            );
        }

        $resourcePath = '/organizations/{organizationId}/uplinks/statuses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($per_page !== null) {
            $queryParams['perPage'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($starting_after !== null) {
            $queryParams['startingAfter'] = ObjectSerializer::toQueryValue($starting_after);
        }
        // query params
        if ($ending_before !== null) {
            $queryParams['endingBefore'] = ObjectSerializer::toQueryValue($ending_before);
        }
        // query params
        if (is_array($network_ids)) {
            $queryParams['networkIds'] = $network_ids;
        } else
        if ($network_ids !== null) {
            $queryParams['networkIds'] = ObjectSerializer::toQueryValue($network_ids);
        }
        // query params
        if (is_array($serials)) {
            $queryParams['serials'] = $serials;
        } else
        if ($serials !== null) {
            $queryParams['serials'] = ObjectSerializer::toQueryValue($serials);
        }
        // query params
        if (is_array($iccids)) {
            $queryParams['iccids'] = $iccids;
        } else
        if ($iccids !== null) {
            $queryParams['iccids'] = ObjectSerializer::toQueryValue($iccids);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationWebhooksAlertTypes
     *
     * Return a list of alert types to be used with managing webhook alerts
     *
     * @param  string $organization_id organization_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getOrganizationWebhooksAlertTypes($organization_id)
    {
        list($response) = $this->getOrganizationWebhooksAlertTypesWithHttpInfo($organization_id);
        return $response;
    }

    /**
     * Operation getOrganizationWebhooksAlertTypesWithHttpInfo
     *
     * Return a list of alert types to be used with managing webhook alerts
     *
     * @param  string $organization_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationWebhooksAlertTypesWithHttpInfo($organization_id)
    {
        $returnType = 'object';
        $request = $this->getOrganizationWebhooksAlertTypesRequest($organization_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationWebhooksAlertTypesAsync
     *
     * Return a list of alert types to be used with managing webhook alerts
     *
     * @param  string $organization_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWebhooksAlertTypesAsync($organization_id)
    {
        return $this->getOrganizationWebhooksAlertTypesAsyncWithHttpInfo($organization_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationWebhooksAlertTypesAsyncWithHttpInfo
     *
     * Return a list of alert types to be used with managing webhook alerts
     *
     * @param  string $organization_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWebhooksAlertTypesAsyncWithHttpInfo($organization_id)
    {
        $returnType = 'object';
        $request = $this->getOrganizationWebhooksAlertTypesRequest($organization_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationWebhooksAlertTypes'
     *
     * @param  string $organization_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOrganizationWebhooksAlertTypesRequest($organization_id)
    {
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationWebhooksAlertTypes'
            );
        }

        $resourcePath = '/organizations/{organizationId}/webhooks/alertTypes';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getOrganizationWebhooksLogs
     *
     * Return the log of webhook POSTs sent
     *
     * @param  string $organization_id organization_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $url The URL the webhook was sent to (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getOrganizationWebhooksLogs($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $url = null)
    {
        list($response) = $this->getOrganizationWebhooksLogsWithHttpInfo($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $url);
        return $response;
    }

    /**
     * Operation getOrganizationWebhooksLogsWithHttpInfo
     *
     * Return the log of webhook POSTs sent
     *
     * @param  string $organization_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $url The URL the webhook was sent to (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getOrganizationWebhooksLogsWithHttpInfo($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $url = null)
    {
        $returnType = 'object';
        $request = $this->getOrganizationWebhooksLogsRequest($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $url);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getOrganizationWebhooksLogsAsync
     *
     * Return the log of webhook POSTs sent
     *
     * @param  string $organization_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $url The URL the webhook was sent to (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWebhooksLogsAsync($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $url = null)
    {
        return $this->getOrganizationWebhooksLogsAsyncWithHttpInfo($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $url)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getOrganizationWebhooksLogsAsyncWithHttpInfo
     *
     * Return the log of webhook POSTs sent
     *
     * @param  string $organization_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $url The URL the webhook was sent to (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getOrganizationWebhooksLogsAsyncWithHttpInfo($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $url = null)
    {
        $returnType = 'object';
        $request = $this->getOrganizationWebhooksLogsRequest($organization_id, $t0, $t1, $timespan, $per_page, $starting_after, $ending_before, $url);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getOrganizationWebhooksLogs'
     *
     * @param  string $organization_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 90 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. Default is 50. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $url The URL the webhook was sent to (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getOrganizationWebhooksLogsRequest($organization_id, $t0 = null, $t1 = null, $timespan = null, $per_page = null, $starting_after = null, $ending_before = null, $url = null)
    {
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling getOrganizationWebhooksLogs'
            );
        }

        $resourcePath = '/organizations/{organizationId}/webhooks/logs';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($per_page !== null) {
            $queryParams['perPage'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($starting_after !== null) {
            $queryParams['startingAfter'] = ObjectSerializer::toQueryValue($starting_after);
        }
        // query params
        if ($ending_before !== null) {
            $queryParams['endingBefore'] = ObjectSerializer::toQueryValue($ending_before);
        }
        // query params
        if ($url !== null) {
            $queryParams['url'] = ObjectSerializer::toQueryValue($url);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
