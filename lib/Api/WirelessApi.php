<?php
/**
 * WirelessApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Meraki Dashboard API
 *
 * The Cisco Meraki Dashboard API is a modern REST API based on the OpenAPI specification.  > Date: 07 July, 2021 > > [What's New](https://meraki.io/whats-new/)  ---  [API Documentation](https://meraki.io/api)  [Community Support](https://meraki.io/community)  [Meraki Homepage](https://www.meraki.com)
 *
 * OpenAPI spec version: 1.11.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.19
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * WirelessApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class WirelessApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createNetworkWirelessRfProfile
     *
     * Creates new RF profile for this network
     *
     * @param  string $network_id network_id (required)
     * @param  \Swagger\Client\Model\CreateNetworkWirelessRfProfile $create_network_wireless_rf_profile create_network_wireless_rf_profile (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function createNetworkWirelessRfProfile($network_id, $create_network_wireless_rf_profile)
    {
        list($response) = $this->createNetworkWirelessRfProfileWithHttpInfo($network_id, $create_network_wireless_rf_profile);
        return $response;
    }

    /**
     * Operation createNetworkWirelessRfProfileWithHttpInfo
     *
     * Creates new RF profile for this network
     *
     * @param  string $network_id (required)
     * @param  \Swagger\Client\Model\CreateNetworkWirelessRfProfile $create_network_wireless_rf_profile (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNetworkWirelessRfProfileWithHttpInfo($network_id, $create_network_wireless_rf_profile)
    {
        $returnType = 'object';
        $request = $this->createNetworkWirelessRfProfileRequest($network_id, $create_network_wireless_rf_profile);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNetworkWirelessRfProfileAsync
     *
     * Creates new RF profile for this network
     *
     * @param  string $network_id (required)
     * @param  \Swagger\Client\Model\CreateNetworkWirelessRfProfile $create_network_wireless_rf_profile (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkWirelessRfProfileAsync($network_id, $create_network_wireless_rf_profile)
    {
        return $this->createNetworkWirelessRfProfileAsyncWithHttpInfo($network_id, $create_network_wireless_rf_profile)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNetworkWirelessRfProfileAsyncWithHttpInfo
     *
     * Creates new RF profile for this network
     *
     * @param  string $network_id (required)
     * @param  \Swagger\Client\Model\CreateNetworkWirelessRfProfile $create_network_wireless_rf_profile (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkWirelessRfProfileAsyncWithHttpInfo($network_id, $create_network_wireless_rf_profile)
    {
        $returnType = 'object';
        $request = $this->createNetworkWirelessRfProfileRequest($network_id, $create_network_wireless_rf_profile);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNetworkWirelessRfProfile'
     *
     * @param  string $network_id (required)
     * @param  \Swagger\Client\Model\CreateNetworkWirelessRfProfile $create_network_wireless_rf_profile (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createNetworkWirelessRfProfileRequest($network_id, $create_network_wireless_rf_profile)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling createNetworkWirelessRfProfile'
            );
        }
        // verify the required parameter 'create_network_wireless_rf_profile' is set
        if ($create_network_wireless_rf_profile === null || (is_array($create_network_wireless_rf_profile) && count($create_network_wireless_rf_profile) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_network_wireless_rf_profile when calling createNetworkWirelessRfProfile'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/rfProfiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($create_network_wireless_rf_profile)) {
            $_tempBody = $create_network_wireless_rf_profile;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createNetworkWirelessSsidIdentityPsk
     *
     * Create an Identity PSK
     *
     * @param  string $network_id network_id (required)
     * @param  string $number number (required)
     * @param  \Swagger\Client\Model\CreateNetworkWirelessSsidIdentityPsk $create_network_wireless_ssid_identity_psk create_network_wireless_ssid_identity_psk (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function createNetworkWirelessSsidIdentityPsk($network_id, $number, $create_network_wireless_ssid_identity_psk)
    {
        list($response) = $this->createNetworkWirelessSsidIdentityPskWithHttpInfo($network_id, $number, $create_network_wireless_ssid_identity_psk);
        return $response;
    }

    /**
     * Operation createNetworkWirelessSsidIdentityPskWithHttpInfo
     *
     * Create an Identity PSK
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\CreateNetworkWirelessSsidIdentityPsk $create_network_wireless_ssid_identity_psk (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function createNetworkWirelessSsidIdentityPskWithHttpInfo($network_id, $number, $create_network_wireless_ssid_identity_psk)
    {
        $returnType = 'object';
        $request = $this->createNetworkWirelessSsidIdentityPskRequest($network_id, $number, $create_network_wireless_ssid_identity_psk);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createNetworkWirelessSsidIdentityPskAsync
     *
     * Create an Identity PSK
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\CreateNetworkWirelessSsidIdentityPsk $create_network_wireless_ssid_identity_psk (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkWirelessSsidIdentityPskAsync($network_id, $number, $create_network_wireless_ssid_identity_psk)
    {
        return $this->createNetworkWirelessSsidIdentityPskAsyncWithHttpInfo($network_id, $number, $create_network_wireless_ssid_identity_psk)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createNetworkWirelessSsidIdentityPskAsyncWithHttpInfo
     *
     * Create an Identity PSK
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\CreateNetworkWirelessSsidIdentityPsk $create_network_wireless_ssid_identity_psk (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createNetworkWirelessSsidIdentityPskAsyncWithHttpInfo($network_id, $number, $create_network_wireless_ssid_identity_psk)
    {
        $returnType = 'object';
        $request = $this->createNetworkWirelessSsidIdentityPskRequest($network_id, $number, $create_network_wireless_ssid_identity_psk);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createNetworkWirelessSsidIdentityPsk'
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\CreateNetworkWirelessSsidIdentityPsk $create_network_wireless_ssid_identity_psk (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createNetworkWirelessSsidIdentityPskRequest($network_id, $number, $create_network_wireless_ssid_identity_psk)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling createNetworkWirelessSsidIdentityPsk'
            );
        }
        // verify the required parameter 'number' is set
        if ($number === null || (is_array($number) && count($number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling createNetworkWirelessSsidIdentityPsk'
            );
        }
        // verify the required parameter 'create_network_wireless_ssid_identity_psk' is set
        if ($create_network_wireless_ssid_identity_psk === null || (is_array($create_network_wireless_ssid_identity_psk) && count($create_network_wireless_ssid_identity_psk) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $create_network_wireless_ssid_identity_psk when calling createNetworkWirelessSsidIdentityPsk'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/ssids/{number}/identityPsks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($number !== null) {
            $resourcePath = str_replace(
                '{' . 'number' . '}',
                ObjectSerializer::toPathValue($number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($create_network_wireless_ssid_identity_psk)) {
            $_tempBody = $create_network_wireless_ssid_identity_psk;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNetworkWirelessRfProfile
     *
     * Delete a RF Profile
     *
     * @param  string $network_id network_id (required)
     * @param  string $rf_profile_id rf_profile_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteNetworkWirelessRfProfile($network_id, $rf_profile_id)
    {
        $this->deleteNetworkWirelessRfProfileWithHttpInfo($network_id, $rf_profile_id);
    }

    /**
     * Operation deleteNetworkWirelessRfProfileWithHttpInfo
     *
     * Delete a RF Profile
     *
     * @param  string $network_id (required)
     * @param  string $rf_profile_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNetworkWirelessRfProfileWithHttpInfo($network_id, $rf_profile_id)
    {
        $returnType = '';
        $request = $this->deleteNetworkWirelessRfProfileRequest($network_id, $rf_profile_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNetworkWirelessRfProfileAsync
     *
     * Delete a RF Profile
     *
     * @param  string $network_id (required)
     * @param  string $rf_profile_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkWirelessRfProfileAsync($network_id, $rf_profile_id)
    {
        return $this->deleteNetworkWirelessRfProfileAsyncWithHttpInfo($network_id, $rf_profile_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNetworkWirelessRfProfileAsyncWithHttpInfo
     *
     * Delete a RF Profile
     *
     * @param  string $network_id (required)
     * @param  string $rf_profile_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkWirelessRfProfileAsyncWithHttpInfo($network_id, $rf_profile_id)
    {
        $returnType = '';
        $request = $this->deleteNetworkWirelessRfProfileRequest($network_id, $rf_profile_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNetworkWirelessRfProfile'
     *
     * @param  string $network_id (required)
     * @param  string $rf_profile_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteNetworkWirelessRfProfileRequest($network_id, $rf_profile_id)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling deleteNetworkWirelessRfProfile'
            );
        }
        // verify the required parameter 'rf_profile_id' is set
        if ($rf_profile_id === null || (is_array($rf_profile_id) && count($rf_profile_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rf_profile_id when calling deleteNetworkWirelessRfProfile'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/rfProfiles/{rfProfileId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($rf_profile_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rfProfileId' . '}',
                ObjectSerializer::toPathValue($rf_profile_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteNetworkWirelessSsidIdentityPsk
     *
     * Delete an Identity PSK
     *
     * @param  string $network_id network_id (required)
     * @param  string $number number (required)
     * @param  string $identity_psk_id identity_psk_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteNetworkWirelessSsidIdentityPsk($network_id, $number, $identity_psk_id)
    {
        $this->deleteNetworkWirelessSsidIdentityPskWithHttpInfo($network_id, $number, $identity_psk_id);
    }

    /**
     * Operation deleteNetworkWirelessSsidIdentityPskWithHttpInfo
     *
     * Delete an Identity PSK
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  string $identity_psk_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteNetworkWirelessSsidIdentityPskWithHttpInfo($network_id, $number, $identity_psk_id)
    {
        $returnType = '';
        $request = $this->deleteNetworkWirelessSsidIdentityPskRequest($network_id, $number, $identity_psk_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            return [null, $statusCode, $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
            }
            throw $e;
        }
    }

    /**
     * Operation deleteNetworkWirelessSsidIdentityPskAsync
     *
     * Delete an Identity PSK
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  string $identity_psk_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkWirelessSsidIdentityPskAsync($network_id, $number, $identity_psk_id)
    {
        return $this->deleteNetworkWirelessSsidIdentityPskAsyncWithHttpInfo($network_id, $number, $identity_psk_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteNetworkWirelessSsidIdentityPskAsyncWithHttpInfo
     *
     * Delete an Identity PSK
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  string $identity_psk_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteNetworkWirelessSsidIdentityPskAsyncWithHttpInfo($network_id, $number, $identity_psk_id)
    {
        $returnType = '';
        $request = $this->deleteNetworkWirelessSsidIdentityPskRequest($network_id, $number, $identity_psk_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteNetworkWirelessSsidIdentityPsk'
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  string $identity_psk_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteNetworkWirelessSsidIdentityPskRequest($network_id, $number, $identity_psk_id)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling deleteNetworkWirelessSsidIdentityPsk'
            );
        }
        // verify the required parameter 'number' is set
        if ($number === null || (is_array($number) && count($number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling deleteNetworkWirelessSsidIdentityPsk'
            );
        }
        // verify the required parameter 'identity_psk_id' is set
        if ($identity_psk_id === null || (is_array($identity_psk_id) && count($identity_psk_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identity_psk_id when calling deleteNetworkWirelessSsidIdentityPsk'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/ssids/{number}/identityPsks/{identityPskId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($number !== null) {
            $resourcePath = str_replace(
                '{' . 'number' . '}',
                ObjectSerializer::toPathValue($number),
                $resourcePath
            );
        }
        // path params
        if ($identity_psk_id !== null) {
            $resourcePath = str_replace(
                '{' . 'identityPskId' . '}',
                ObjectSerializer::toPathValue($identity_psk_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceWirelessBluetoothSettings
     *
     * Return the bluetooth settings for a wireless device
     *
     * @param  string $serial serial (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getDeviceWirelessBluetoothSettings($serial)
    {
        list($response) = $this->getDeviceWirelessBluetoothSettingsWithHttpInfo($serial);
        return $response;
    }

    /**
     * Operation getDeviceWirelessBluetoothSettingsWithHttpInfo
     *
     * Return the bluetooth settings for a wireless device
     *
     * @param  string $serial (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceWirelessBluetoothSettingsWithHttpInfo($serial)
    {
        $returnType = 'object';
        $request = $this->getDeviceWirelessBluetoothSettingsRequest($serial);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceWirelessBluetoothSettingsAsync
     *
     * Return the bluetooth settings for a wireless device
     *
     * @param  string $serial (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceWirelessBluetoothSettingsAsync($serial)
    {
        return $this->getDeviceWirelessBluetoothSettingsAsyncWithHttpInfo($serial)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceWirelessBluetoothSettingsAsyncWithHttpInfo
     *
     * Return the bluetooth settings for a wireless device
     *
     * @param  string $serial (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceWirelessBluetoothSettingsAsyncWithHttpInfo($serial)
    {
        $returnType = 'object';
        $request = $this->getDeviceWirelessBluetoothSettingsRequest($serial);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceWirelessBluetoothSettings'
     *
     * @param  string $serial (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeviceWirelessBluetoothSettingsRequest($serial)
    {
        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceWirelessBluetoothSettings'
            );
        }

        $resourcePath = '/devices/{serial}/wireless/bluetooth/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceWirelessConnectionStats
     *
     * Aggregated connectivity info for a given AP on this network
     *
     * @param  string $serial serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getDeviceWirelessConnectionStats($serial, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        list($response) = $this->getDeviceWirelessConnectionStatsWithHttpInfo($serial, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag);
        return $response;
    }

    /**
     * Operation getDeviceWirelessConnectionStatsWithHttpInfo
     *
     * Aggregated connectivity info for a given AP on this network
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceWirelessConnectionStatsWithHttpInfo($serial, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        $returnType = 'object';
        $request = $this->getDeviceWirelessConnectionStatsRequest($serial, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceWirelessConnectionStatsAsync
     *
     * Aggregated connectivity info for a given AP on this network
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceWirelessConnectionStatsAsync($serial, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        return $this->getDeviceWirelessConnectionStatsAsyncWithHttpInfo($serial, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceWirelessConnectionStatsAsyncWithHttpInfo
     *
     * Aggregated connectivity info for a given AP on this network
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceWirelessConnectionStatsAsyncWithHttpInfo($serial, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        $returnType = 'object';
        $request = $this->getDeviceWirelessConnectionStatsRequest($serial, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceWirelessConnectionStats'
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeviceWirelessConnectionStatsRequest($serial, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceWirelessConnectionStats'
            );
        }

        $resourcePath = '/devices/{serial}/wireless/connectionStats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }
        // query params
        if ($vlan !== null) {
            $queryParams['vlan'] = ObjectSerializer::toQueryValue($vlan);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }

        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceWirelessLatencyStats
     *
     * Aggregated latency info for a given AP on this network
     *
     * @param  string $serial serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getDeviceWirelessLatencyStats($serial, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        list($response) = $this->getDeviceWirelessLatencyStatsWithHttpInfo($serial, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields);
        return $response;
    }

    /**
     * Operation getDeviceWirelessLatencyStatsWithHttpInfo
     *
     * Aggregated latency info for a given AP on this network
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceWirelessLatencyStatsWithHttpInfo($serial, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        $returnType = 'object';
        $request = $this->getDeviceWirelessLatencyStatsRequest($serial, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceWirelessLatencyStatsAsync
     *
     * Aggregated latency info for a given AP on this network
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceWirelessLatencyStatsAsync($serial, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        return $this->getDeviceWirelessLatencyStatsAsyncWithHttpInfo($serial, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceWirelessLatencyStatsAsyncWithHttpInfo
     *
     * Aggregated latency info for a given AP on this network
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceWirelessLatencyStatsAsyncWithHttpInfo($serial, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        $returnType = 'object';
        $request = $this->getDeviceWirelessLatencyStatsRequest($serial, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceWirelessLatencyStats'
     *
     * @param  string $serial (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeviceWirelessLatencyStatsRequest($serial, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceWirelessLatencyStats'
            );
        }

        $resourcePath = '/devices/{serial}/wireless/latencyStats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }
        // query params
        if ($vlan !== null) {
            $queryParams['vlan'] = ObjectSerializer::toQueryValue($vlan);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceWirelessRadioSettings
     *
     * Return the radio settings of a device
     *
     * @param  string $serial serial (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getDeviceWirelessRadioSettings($serial)
    {
        list($response) = $this->getDeviceWirelessRadioSettingsWithHttpInfo($serial);
        return $response;
    }

    /**
     * Operation getDeviceWirelessRadioSettingsWithHttpInfo
     *
     * Return the radio settings of a device
     *
     * @param  string $serial (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceWirelessRadioSettingsWithHttpInfo($serial)
    {
        $returnType = 'object';
        $request = $this->getDeviceWirelessRadioSettingsRequest($serial);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceWirelessRadioSettingsAsync
     *
     * Return the radio settings of a device
     *
     * @param  string $serial (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceWirelessRadioSettingsAsync($serial)
    {
        return $this->getDeviceWirelessRadioSettingsAsyncWithHttpInfo($serial)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceWirelessRadioSettingsAsyncWithHttpInfo
     *
     * Return the radio settings of a device
     *
     * @param  string $serial (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceWirelessRadioSettingsAsyncWithHttpInfo($serial)
    {
        $returnType = 'object';
        $request = $this->getDeviceWirelessRadioSettingsRequest($serial);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceWirelessRadioSettings'
     *
     * @param  string $serial (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeviceWirelessRadioSettingsRequest($serial)
    {
        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceWirelessRadioSettings'
            );
        }

        $resourcePath = '/devices/{serial}/wireless/radio/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getDeviceWirelessStatus
     *
     * Return the SSID statuses of an access point
     *
     * @param  string $serial serial (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getDeviceWirelessStatus($serial)
    {
        list($response) = $this->getDeviceWirelessStatusWithHttpInfo($serial);
        return $response;
    }

    /**
     * Operation getDeviceWirelessStatusWithHttpInfo
     *
     * Return the SSID statuses of an access point
     *
     * @param  string $serial (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getDeviceWirelessStatusWithHttpInfo($serial)
    {
        $returnType = 'object';
        $request = $this->getDeviceWirelessStatusRequest($serial);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getDeviceWirelessStatusAsync
     *
     * Return the SSID statuses of an access point
     *
     * @param  string $serial (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceWirelessStatusAsync($serial)
    {
        return $this->getDeviceWirelessStatusAsyncWithHttpInfo($serial)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getDeviceWirelessStatusAsyncWithHttpInfo
     *
     * Return the SSID statuses of an access point
     *
     * @param  string $serial (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getDeviceWirelessStatusAsyncWithHttpInfo($serial)
    {
        $returnType = 'object';
        $request = $this->getDeviceWirelessStatusRequest($serial);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getDeviceWirelessStatus'
     *
     * @param  string $serial (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getDeviceWirelessStatusRequest($serial)
    {
        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling getDeviceWirelessStatus'
            );
        }

        $resourcePath = '/devices/{serial}/wireless/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessAirMarshal
     *
     * List Air Marshal scan results from a network
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessAirMarshal($network_id, $t0 = null, $timespan = null)
    {
        list($response) = $this->getNetworkWirelessAirMarshalWithHttpInfo($network_id, $t0, $timespan);
        return $response;
    }

    /**
     * Operation getNetworkWirelessAirMarshalWithHttpInfo
     *
     * List Air Marshal scan results from a network
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessAirMarshalWithHttpInfo($network_id, $t0 = null, $timespan = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessAirMarshalRequest($network_id, $t0, $timespan);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessAirMarshalAsync
     *
     * List Air Marshal scan results from a network
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessAirMarshalAsync($network_id, $t0 = null, $timespan = null)
    {
        return $this->getNetworkWirelessAirMarshalAsyncWithHttpInfo($network_id, $t0, $timespan)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessAirMarshalAsyncWithHttpInfo
     *
     * List Air Marshal scan results from a network
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessAirMarshalAsyncWithHttpInfo($network_id, $t0 = null, $timespan = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessAirMarshalRequest($network_id, $t0, $timespan);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessAirMarshal'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameter t0. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessAirMarshalRequest($network_id, $t0 = null, $timespan = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessAirMarshal'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/airMarshal';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessAlternateManagementInterface
     *
     * Return alternate management interface and devices with IP assigned
     *
     * @param  string $network_id network_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessAlternateManagementInterface($network_id)
    {
        list($response) = $this->getNetworkWirelessAlternateManagementInterfaceWithHttpInfo($network_id);
        return $response;
    }

    /**
     * Operation getNetworkWirelessAlternateManagementInterfaceWithHttpInfo
     *
     * Return alternate management interface and devices with IP assigned
     *
     * @param  string $network_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessAlternateManagementInterfaceWithHttpInfo($network_id)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessAlternateManagementInterfaceRequest($network_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessAlternateManagementInterfaceAsync
     *
     * Return alternate management interface and devices with IP assigned
     *
     * @param  string $network_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessAlternateManagementInterfaceAsync($network_id)
    {
        return $this->getNetworkWirelessAlternateManagementInterfaceAsyncWithHttpInfo($network_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessAlternateManagementInterfaceAsyncWithHttpInfo
     *
     * Return alternate management interface and devices with IP assigned
     *
     * @param  string $network_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessAlternateManagementInterfaceAsyncWithHttpInfo($network_id)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessAlternateManagementInterfaceRequest($network_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessAlternateManagementInterface'
     *
     * @param  string $network_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessAlternateManagementInterfaceRequest($network_id)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessAlternateManagementInterface'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/alternateManagementInterface';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessBilling
     *
     * Return the billing settings of this network
     *
     * @param  string $network_id network_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessBilling($network_id)
    {
        list($response) = $this->getNetworkWirelessBillingWithHttpInfo($network_id);
        return $response;
    }

    /**
     * Operation getNetworkWirelessBillingWithHttpInfo
     *
     * Return the billing settings of this network
     *
     * @param  string $network_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessBillingWithHttpInfo($network_id)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessBillingRequest($network_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessBillingAsync
     *
     * Return the billing settings of this network
     *
     * @param  string $network_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessBillingAsync($network_id)
    {
        return $this->getNetworkWirelessBillingAsyncWithHttpInfo($network_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessBillingAsyncWithHttpInfo
     *
     * Return the billing settings of this network
     *
     * @param  string $network_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessBillingAsyncWithHttpInfo($network_id)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessBillingRequest($network_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessBilling'
     *
     * @param  string $network_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessBillingRequest($network_id)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessBilling'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/billing';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessBluetoothSettings
     *
     * Return the Bluetooth settings for a network. <a href=\"https://documentation.meraki.com/MR/Bluetooth/Bluetooth_Low_Energy_(BLE)\">Bluetooth settings</a> must be enabled on the network.
     *
     * @param  string $network_id network_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessBluetoothSettings($network_id)
    {
        list($response) = $this->getNetworkWirelessBluetoothSettingsWithHttpInfo($network_id);
        return $response;
    }

    /**
     * Operation getNetworkWirelessBluetoothSettingsWithHttpInfo
     *
     * Return the Bluetooth settings for a network. <a href=\"https://documentation.meraki.com/MR/Bluetooth/Bluetooth_Low_Energy_(BLE)\">Bluetooth settings</a> must be enabled on the network.
     *
     * @param  string $network_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessBluetoothSettingsWithHttpInfo($network_id)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessBluetoothSettingsRequest($network_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessBluetoothSettingsAsync
     *
     * Return the Bluetooth settings for a network. <a href=\"https://documentation.meraki.com/MR/Bluetooth/Bluetooth_Low_Energy_(BLE)\">Bluetooth settings</a> must be enabled on the network.
     *
     * @param  string $network_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessBluetoothSettingsAsync($network_id)
    {
        return $this->getNetworkWirelessBluetoothSettingsAsyncWithHttpInfo($network_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessBluetoothSettingsAsyncWithHttpInfo
     *
     * Return the Bluetooth settings for a network. <a href=\"https://documentation.meraki.com/MR/Bluetooth/Bluetooth_Low_Energy_(BLE)\">Bluetooth settings</a> must be enabled on the network.
     *
     * @param  string $network_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessBluetoothSettingsAsyncWithHttpInfo($network_id)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessBluetoothSettingsRequest($network_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessBluetoothSettings'
     *
     * @param  string $network_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessBluetoothSettingsRequest($network_id)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessBluetoothSettings'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/bluetooth/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessChannelUtilizationHistory
     *
     * Return AP channel utilization over time for a device or network client
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client to return per-device, per-band AP channel utilization metrics inner joined by the queried client&#39;s connection history. (optional)
     * @param  string $device_serial Filter results by device to return AP channel utilization metrics for the queried device; either :band or :clientId must be jointly specified. (optional)
     * @param  string $ap_tag Filter results by AP tag to return AP channel utilization metrics for devices labeled with the given tag; either :clientId or :deviceSerial must be jointly specified. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessChannelUtilizationHistory($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null)
    {
        list($response) = $this->getNetworkWirelessChannelUtilizationHistoryWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band);
        return $response;
    }

    /**
     * Operation getNetworkWirelessChannelUtilizationHistoryWithHttpInfo
     *
     * Return AP channel utilization over time for a device or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client to return per-device, per-band AP channel utilization metrics inner joined by the queried client&#39;s connection history. (optional)
     * @param  string $device_serial Filter results by device to return AP channel utilization metrics for the queried device; either :band or :clientId must be jointly specified. (optional)
     * @param  string $ap_tag Filter results by AP tag to return AP channel utilization metrics for devices labeled with the given tag; either :clientId or :deviceSerial must be jointly specified. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessChannelUtilizationHistoryWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessChannelUtilizationHistoryRequest($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessChannelUtilizationHistoryAsync
     *
     * Return AP channel utilization over time for a device or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client to return per-device, per-band AP channel utilization metrics inner joined by the queried client&#39;s connection history. (optional)
     * @param  string $device_serial Filter results by device to return AP channel utilization metrics for the queried device; either :band or :clientId must be jointly specified. (optional)
     * @param  string $ap_tag Filter results by AP tag to return AP channel utilization metrics for devices labeled with the given tag; either :clientId or :deviceSerial must be jointly specified. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessChannelUtilizationHistoryAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null)
    {
        return $this->getNetworkWirelessChannelUtilizationHistoryAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessChannelUtilizationHistoryAsyncWithHttpInfo
     *
     * Return AP channel utilization over time for a device or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client to return per-device, per-band AP channel utilization metrics inner joined by the queried client&#39;s connection history. (optional)
     * @param  string $device_serial Filter results by device to return AP channel utilization metrics for the queried device; either :band or :clientId must be jointly specified. (optional)
     * @param  string $ap_tag Filter results by AP tag to return AP channel utilization metrics for devices labeled with the given tag; either :clientId or :deviceSerial must be jointly specified. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessChannelUtilizationHistoryAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessChannelUtilizationHistoryRequest($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessChannelUtilizationHistory'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client to return per-device, per-band AP channel utilization metrics inner joined by the queried client&#39;s connection history. (optional)
     * @param  string $device_serial Filter results by device to return AP channel utilization metrics for the queried device; either :band or :clientId must be jointly specified. (optional)
     * @param  string $ap_tag Filter results by AP tag to return AP channel utilization metrics for devices labeled with the given tag; either :clientId or :deviceSerial must be jointly specified. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessChannelUtilizationHistoryRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessChannelUtilizationHistory'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/channelUtilizationHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($resolution !== null) {
            $queryParams['resolution'] = ObjectSerializer::toQueryValue($resolution);
        }
        // query params
        if ($auto_resolution !== null) {
            $queryParams['autoResolution'] = ObjectSerializer::toQueryValue($auto_resolution);
        }
        // query params
        if ($client_id !== null) {
            $queryParams['clientId'] = ObjectSerializer::toQueryValue($client_id);
        }
        // query params
        if ($device_serial !== null) {
            $queryParams['deviceSerial'] = ObjectSerializer::toQueryValue($device_serial);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessClientConnectionStats
     *
     * Aggregated connectivity info for a given client on this network
     *
     * @param  string $network_id network_id (required)
     * @param  string $client_id client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessClientConnectionStats($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        list($response) = $this->getNetworkWirelessClientConnectionStatsWithHttpInfo($network_id, $client_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag);
        return $response;
    }

    /**
     * Operation getNetworkWirelessClientConnectionStatsWithHttpInfo
     *
     * Aggregated connectivity info for a given client on this network
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessClientConnectionStatsWithHttpInfo($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessClientConnectionStatsRequest($network_id, $client_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessClientConnectionStatsAsync
     *
     * Aggregated connectivity info for a given client on this network
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientConnectionStatsAsync($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        return $this->getNetworkWirelessClientConnectionStatsAsyncWithHttpInfo($network_id, $client_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessClientConnectionStatsAsyncWithHttpInfo
     *
     * Aggregated connectivity info for a given client on this network
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientConnectionStatsAsyncWithHttpInfo($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessClientConnectionStatsRequest($network_id, $client_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessClientConnectionStats'
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessClientConnectionStatsRequest($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessClientConnectionStats'
            );
        }
        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling getNetworkWirelessClientConnectionStats'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/clients/{clientId}/connectionStats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }
        // query params
        if ($vlan !== null) {
            $queryParams['vlan'] = ObjectSerializer::toQueryValue($vlan);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessClientConnectivityEvents
     *
     * List the wireless connectivity events for a client within a network in the timespan.
     *
     * @param  string $network_id network_id (required)
     * @param  string $client_id client_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string[] $types A list of event types to include. If not specified, events of all types will be returned. Valid types are &#39;assoc&#39;, &#39;disassoc&#39;, &#39;auth&#39;, &#39;deauth&#39;, &#39;dns&#39;, &#39;dhcp&#39;, &#39;roam&#39;, &#39;connection&#39; and/or &#39;sticky&#39;. (optional)
     * @param  string[] $included_severities A list of severities to include. If not specified, events of all severities will be returned. Valid severities are &#39;good&#39;, &#39;info&#39;, &#39;warn&#39; and/or &#39;bad&#39;. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid_number An SSID number to include. If not specified, events for all SSIDs will be returned. (optional)
     * @param  string $device_serial Filter results by an AP&#39;s serial number. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessClientConnectivityEvents($network_id, $client_id, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $types = null, $included_severities = null, $band = null, $ssid_number = null, $device_serial = null)
    {
        list($response) = $this->getNetworkWirelessClientConnectivityEventsWithHttpInfo($network_id, $client_id, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $types, $included_severities, $band, $ssid_number, $device_serial);
        return $response;
    }

    /**
     * Operation getNetworkWirelessClientConnectivityEventsWithHttpInfo
     *
     * List the wireless connectivity events for a client within a network in the timespan.
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string[] $types A list of event types to include. If not specified, events of all types will be returned. Valid types are &#39;assoc&#39;, &#39;disassoc&#39;, &#39;auth&#39;, &#39;deauth&#39;, &#39;dns&#39;, &#39;dhcp&#39;, &#39;roam&#39;, &#39;connection&#39; and/or &#39;sticky&#39;. (optional)
     * @param  string[] $included_severities A list of severities to include. If not specified, events of all severities will be returned. Valid severities are &#39;good&#39;, &#39;info&#39;, &#39;warn&#39; and/or &#39;bad&#39;. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid_number An SSID number to include. If not specified, events for all SSIDs will be returned. (optional)
     * @param  string $device_serial Filter results by an AP&#39;s serial number. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessClientConnectivityEventsWithHttpInfo($network_id, $client_id, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $types = null, $included_severities = null, $band = null, $ssid_number = null, $device_serial = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessClientConnectivityEventsRequest($network_id, $client_id, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $types, $included_severities, $band, $ssid_number, $device_serial);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessClientConnectivityEventsAsync
     *
     * List the wireless connectivity events for a client within a network in the timespan.
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string[] $types A list of event types to include. If not specified, events of all types will be returned. Valid types are &#39;assoc&#39;, &#39;disassoc&#39;, &#39;auth&#39;, &#39;deauth&#39;, &#39;dns&#39;, &#39;dhcp&#39;, &#39;roam&#39;, &#39;connection&#39; and/or &#39;sticky&#39;. (optional)
     * @param  string[] $included_severities A list of severities to include. If not specified, events of all severities will be returned. Valid severities are &#39;good&#39;, &#39;info&#39;, &#39;warn&#39; and/or &#39;bad&#39;. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid_number An SSID number to include. If not specified, events for all SSIDs will be returned. (optional)
     * @param  string $device_serial Filter results by an AP&#39;s serial number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientConnectivityEventsAsync($network_id, $client_id, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $types = null, $included_severities = null, $band = null, $ssid_number = null, $device_serial = null)
    {
        return $this->getNetworkWirelessClientConnectivityEventsAsyncWithHttpInfo($network_id, $client_id, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $types, $included_severities, $band, $ssid_number, $device_serial)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessClientConnectivityEventsAsyncWithHttpInfo
     *
     * List the wireless connectivity events for a client within a network in the timespan.
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string[] $types A list of event types to include. If not specified, events of all types will be returned. Valid types are &#39;assoc&#39;, &#39;disassoc&#39;, &#39;auth&#39;, &#39;deauth&#39;, &#39;dns&#39;, &#39;dhcp&#39;, &#39;roam&#39;, &#39;connection&#39; and/or &#39;sticky&#39;. (optional)
     * @param  string[] $included_severities A list of severities to include. If not specified, events of all severities will be returned. Valid severities are &#39;good&#39;, &#39;info&#39;, &#39;warn&#39; and/or &#39;bad&#39;. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid_number An SSID number to include. If not specified, events for all SSIDs will be returned. (optional)
     * @param  string $device_serial Filter results by an AP&#39;s serial number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientConnectivityEventsAsyncWithHttpInfo($network_id, $client_id, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $types = null, $included_severities = null, $band = null, $ssid_number = null, $device_serial = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessClientConnectivityEventsRequest($network_id, $client_id, $per_page, $starting_after, $ending_before, $t0, $t1, $timespan, $types, $included_severities, $band, $ssid_number, $device_serial);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessClientConnectivityEvents'
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 1000. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 1 day. (optional)
     * @param  string[] $types A list of event types to include. If not specified, events of all types will be returned. Valid types are &#39;assoc&#39;, &#39;disassoc&#39;, &#39;auth&#39;, &#39;deauth&#39;, &#39;dns&#39;, &#39;dhcp&#39;, &#39;roam&#39;, &#39;connection&#39; and/or &#39;sticky&#39;. (optional)
     * @param  string[] $included_severities A list of severities to include. If not specified, events of all severities will be returned. Valid severities are &#39;good&#39;, &#39;info&#39;, &#39;warn&#39; and/or &#39;bad&#39;. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid_number An SSID number to include. If not specified, events for all SSIDs will be returned. (optional)
     * @param  string $device_serial Filter results by an AP&#39;s serial number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessClientConnectivityEventsRequest($network_id, $client_id, $per_page = null, $starting_after = null, $ending_before = null, $t0 = null, $t1 = null, $timespan = null, $types = null, $included_severities = null, $band = null, $ssid_number = null, $device_serial = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessClientConnectivityEvents'
            );
        }
        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling getNetworkWirelessClientConnectivityEvents'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/clients/{clientId}/connectivityEvents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($per_page !== null) {
            $queryParams['perPage'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($starting_after !== null) {
            $queryParams['startingAfter'] = ObjectSerializer::toQueryValue($starting_after);
        }
        // query params
        if ($ending_before !== null) {
            $queryParams['endingBefore'] = ObjectSerializer::toQueryValue($ending_before);
        }
        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if (is_array($types)) {
            $queryParams['types'] = $types;
        } else
        if ($types !== null) {
            $queryParams['types'] = ObjectSerializer::toQueryValue($types);
        }
        // query params
        if (is_array($included_severities)) {
            $queryParams['includedSeverities'] = $included_severities;
        } else
        if ($included_severities !== null) {
            $queryParams['includedSeverities'] = ObjectSerializer::toQueryValue($included_severities);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid_number !== null) {
            $queryParams['ssidNumber'] = ObjectSerializer::toQueryValue($ssid_number);
        }
        // query params
        if ($device_serial !== null) {
            $queryParams['deviceSerial'] = ObjectSerializer::toQueryValue($device_serial);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessClientCountHistory
     *
     * Return wireless client counts over time for a network, device, or network client
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client to return per-device client counts over time inner joined by the queried client&#39;s connection history. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessClientCountHistory($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        list($response) = $this->getNetworkWirelessClientCountHistoryWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid);
        return $response;
    }

    /**
     * Operation getNetworkWirelessClientCountHistoryWithHttpInfo
     *
     * Return wireless client counts over time for a network, device, or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client to return per-device client counts over time inner joined by the queried client&#39;s connection history. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessClientCountHistoryWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessClientCountHistoryRequest($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessClientCountHistoryAsync
     *
     * Return wireless client counts over time for a network, device, or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client to return per-device client counts over time inner joined by the queried client&#39;s connection history. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientCountHistoryAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        return $this->getNetworkWirelessClientCountHistoryAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessClientCountHistoryAsyncWithHttpInfo
     *
     * Return wireless client counts over time for a network, device, or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client to return per-device client counts over time inner joined by the queried client&#39;s connection history. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientCountHistoryAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessClientCountHistoryRequest($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessClientCountHistory'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client to return per-device client counts over time inner joined by the queried client&#39;s connection history. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessClientCountHistoryRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessClientCountHistory'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/clientCountHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($resolution !== null) {
            $queryParams['resolution'] = ObjectSerializer::toQueryValue($resolution);
        }
        // query params
        if ($auto_resolution !== null) {
            $queryParams['autoResolution'] = ObjectSerializer::toQueryValue($auto_resolution);
        }
        // query params
        if ($client_id !== null) {
            $queryParams['clientId'] = ObjectSerializer::toQueryValue($client_id);
        }
        // query params
        if ($device_serial !== null) {
            $queryParams['deviceSerial'] = ObjectSerializer::toQueryValue($device_serial);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessClientLatencyHistory
     *
     * Return the latency history for a client
     *
     * @param  string $network_id network_id (required)
     * @param  string $client_id client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 791 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 1 day. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 86400. The default is 86400. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessClientLatencyHistory($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null)
    {
        list($response) = $this->getNetworkWirelessClientLatencyHistoryWithHttpInfo($network_id, $client_id, $t0, $t1, $timespan, $resolution);
        return $response;
    }

    /**
     * Operation getNetworkWirelessClientLatencyHistoryWithHttpInfo
     *
     * Return the latency history for a client
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 791 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 1 day. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 86400. The default is 86400. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessClientLatencyHistoryWithHttpInfo($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessClientLatencyHistoryRequest($network_id, $client_id, $t0, $t1, $timespan, $resolution);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessClientLatencyHistoryAsync
     *
     * Return the latency history for a client
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 791 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 1 day. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 86400. The default is 86400. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientLatencyHistoryAsync($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null)
    {
        return $this->getNetworkWirelessClientLatencyHistoryAsyncWithHttpInfo($network_id, $client_id, $t0, $t1, $timespan, $resolution)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessClientLatencyHistoryAsyncWithHttpInfo
     *
     * Return the latency history for a client
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 791 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 1 day. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 86400. The default is 86400. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientLatencyHistoryAsyncWithHttpInfo($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessClientLatencyHistoryRequest($network_id, $client_id, $t0, $t1, $timespan, $resolution);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessClientLatencyHistory'
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 791 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 791 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 791 days. The default is 1 day. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 86400. The default is 86400. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessClientLatencyHistoryRequest($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessClientLatencyHistory'
            );
        }
        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling getNetworkWirelessClientLatencyHistory'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/clients/{clientId}/latencyHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($resolution !== null) {
            $queryParams['resolution'] = ObjectSerializer::toQueryValue($resolution);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessClientLatencyStats
     *
     * Aggregated latency info for a given client on this network
     *
     * @param  string $network_id network_id (required)
     * @param  string $client_id client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessClientLatencyStats($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        list($response) = $this->getNetworkWirelessClientLatencyStatsWithHttpInfo($network_id, $client_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields);
        return $response;
    }

    /**
     * Operation getNetworkWirelessClientLatencyStatsWithHttpInfo
     *
     * Aggregated latency info for a given client on this network
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessClientLatencyStatsWithHttpInfo($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessClientLatencyStatsRequest($network_id, $client_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessClientLatencyStatsAsync
     *
     * Aggregated latency info for a given client on this network
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientLatencyStatsAsync($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        return $this->getNetworkWirelessClientLatencyStatsAsyncWithHttpInfo($network_id, $client_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessClientLatencyStatsAsyncWithHttpInfo
     *
     * Aggregated latency info for a given client on this network
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientLatencyStatsAsyncWithHttpInfo($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessClientLatencyStatsRequest($network_id, $client_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessClientLatencyStats'
     *
     * @param  string $network_id (required)
     * @param  string $client_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessClientLatencyStatsRequest($network_id, $client_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessClientLatencyStats'
            );
        }
        // verify the required parameter 'client_id' is set
        if ($client_id === null || (is_array($client_id) && count($client_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $client_id when calling getNetworkWirelessClientLatencyStats'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/clients/{clientId}/latencyStats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }
        // query params
        if ($vlan !== null) {
            $queryParams['vlan'] = ObjectSerializer::toQueryValue($vlan);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($client_id !== null) {
            $resourcePath = str_replace(
                '{' . 'clientId' . '}',
                ObjectSerializer::toPathValue($client_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessClientsConnectionStats
     *
     * Aggregated connectivity info for this network, grouped by clients
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessClientsConnectionStats($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        list($response) = $this->getNetworkWirelessClientsConnectionStatsWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag);
        return $response;
    }

    /**
     * Operation getNetworkWirelessClientsConnectionStatsWithHttpInfo
     *
     * Aggregated connectivity info for this network, grouped by clients
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessClientsConnectionStatsWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessClientsConnectionStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessClientsConnectionStatsAsync
     *
     * Aggregated connectivity info for this network, grouped by clients
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientsConnectionStatsAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        return $this->getNetworkWirelessClientsConnectionStatsAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessClientsConnectionStatsAsyncWithHttpInfo
     *
     * Aggregated connectivity info for this network, grouped by clients
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientsConnectionStatsAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessClientsConnectionStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessClientsConnectionStats'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessClientsConnectionStatsRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessClientsConnectionStats'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/clients/connectionStats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }
        // query params
        if ($vlan !== null) {
            $queryParams['vlan'] = ObjectSerializer::toQueryValue($vlan);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessClientsLatencyStats
     *
     * Aggregated latency info for this network, grouped by clients
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessClientsLatencyStats($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        list($response) = $this->getNetworkWirelessClientsLatencyStatsWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields);
        return $response;
    }

    /**
     * Operation getNetworkWirelessClientsLatencyStatsWithHttpInfo
     *
     * Aggregated latency info for this network, grouped by clients
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessClientsLatencyStatsWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessClientsLatencyStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessClientsLatencyStatsAsync
     *
     * Aggregated latency info for this network, grouped by clients
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientsLatencyStatsAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        return $this->getNetworkWirelessClientsLatencyStatsAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessClientsLatencyStatsAsyncWithHttpInfo
     *
     * Aggregated latency info for this network, grouped by clients
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessClientsLatencyStatsAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessClientsLatencyStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessClientsLatencyStats'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessClientsLatencyStatsRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessClientsLatencyStats'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/clients/latencyStats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }
        // query params
        if ($vlan !== null) {
            $queryParams['vlan'] = ObjectSerializer::toQueryValue($vlan);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessConnectionStats
     *
     * Aggregated connectivity info for this network
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessConnectionStats($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        list($response) = $this->getNetworkWirelessConnectionStatsWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag);
        return $response;
    }

    /**
     * Operation getNetworkWirelessConnectionStatsWithHttpInfo
     *
     * Aggregated connectivity info for this network
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessConnectionStatsWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessConnectionStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessConnectionStatsAsync
     *
     * Aggregated connectivity info for this network
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessConnectionStatsAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        return $this->getNetworkWirelessConnectionStatsAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessConnectionStatsAsyncWithHttpInfo
     *
     * Aggregated connectivity info for this network
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessConnectionStatsAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessConnectionStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessConnectionStats'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessConnectionStatsRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessConnectionStats'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/connectionStats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }
        // query params
        if ($vlan !== null) {
            $queryParams['vlan'] = ObjectSerializer::toQueryValue($vlan);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessDataRateHistory
     *
     * Return PHY data rates over time for a network, device, or network client
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessDataRateHistory($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        list($response) = $this->getNetworkWirelessDataRateHistoryWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid);
        return $response;
    }

    /**
     * Operation getNetworkWirelessDataRateHistoryWithHttpInfo
     *
     * Return PHY data rates over time for a network, device, or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessDataRateHistoryWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessDataRateHistoryRequest($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessDataRateHistoryAsync
     *
     * Return PHY data rates over time for a network, device, or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessDataRateHistoryAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        return $this->getNetworkWirelessDataRateHistoryAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessDataRateHistoryAsyncWithHttpInfo
     *
     * Return PHY data rates over time for a network, device, or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessDataRateHistoryAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessDataRateHistoryRequest($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessDataRateHistory'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessDataRateHistoryRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessDataRateHistory'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/dataRateHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($resolution !== null) {
            $queryParams['resolution'] = ObjectSerializer::toQueryValue($resolution);
        }
        // query params
        if ($auto_resolution !== null) {
            $queryParams['autoResolution'] = ObjectSerializer::toQueryValue($auto_resolution);
        }
        // query params
        if ($client_id !== null) {
            $queryParams['clientId'] = ObjectSerializer::toQueryValue($client_id);
        }
        // query params
        if ($device_serial !== null) {
            $queryParams['deviceSerial'] = ObjectSerializer::toQueryValue($device_serial);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessDevicesConnectionStats
     *
     * Aggregated connectivity info for this network, grouped by node
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessDevicesConnectionStats($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        list($response) = $this->getNetworkWirelessDevicesConnectionStatsWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag);
        return $response;
    }

    /**
     * Operation getNetworkWirelessDevicesConnectionStatsWithHttpInfo
     *
     * Aggregated connectivity info for this network, grouped by node
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessDevicesConnectionStatsWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessDevicesConnectionStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessDevicesConnectionStatsAsync
     *
     * Aggregated connectivity info for this network, grouped by node
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessDevicesConnectionStatsAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        return $this->getNetworkWirelessDevicesConnectionStatsAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessDevicesConnectionStatsAsyncWithHttpInfo
     *
     * Aggregated connectivity info for this network, grouped by node
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessDevicesConnectionStatsAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessDevicesConnectionStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessDevicesConnectionStats'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessDevicesConnectionStatsRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessDevicesConnectionStats'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/devices/connectionStats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }
        // query params
        if ($vlan !== null) {
            $queryParams['vlan'] = ObjectSerializer::toQueryValue($vlan);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessDevicesLatencyStats
     *
     * Aggregated latency info for this network, grouped by node
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessDevicesLatencyStats($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        list($response) = $this->getNetworkWirelessDevicesLatencyStatsWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields);
        return $response;
    }

    /**
     * Operation getNetworkWirelessDevicesLatencyStatsWithHttpInfo
     *
     * Aggregated latency info for this network, grouped by node
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessDevicesLatencyStatsWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessDevicesLatencyStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessDevicesLatencyStatsAsync
     *
     * Aggregated latency info for this network, grouped by node
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessDevicesLatencyStatsAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        return $this->getNetworkWirelessDevicesLatencyStatsAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessDevicesLatencyStatsAsyncWithHttpInfo
     *
     * Aggregated latency info for this network, grouped by node
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessDevicesLatencyStatsAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessDevicesLatencyStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessDevicesLatencyStats'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessDevicesLatencyStatsRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessDevicesLatencyStats'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/devices/latencyStats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }
        // query params
        if ($vlan !== null) {
            $queryParams['vlan'] = ObjectSerializer::toQueryValue($vlan);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessFailedConnections
     *
     * List of all failed client connection events on this network in a given time range
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $serial Filter by AP (optional)
     * @param  string $client_id Filter by client MAC (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessFailedConnections($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $serial = null, $client_id = null)
    {
        list($response) = $this->getNetworkWirelessFailedConnectionsWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $serial, $client_id);
        return $response;
    }

    /**
     * Operation getNetworkWirelessFailedConnectionsWithHttpInfo
     *
     * List of all failed client connection events on this network in a given time range
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $serial Filter by AP (optional)
     * @param  string $client_id Filter by client MAC (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessFailedConnectionsWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $serial = null, $client_id = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessFailedConnectionsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $serial, $client_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessFailedConnectionsAsync
     *
     * List of all failed client connection events on this network in a given time range
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $serial Filter by AP (optional)
     * @param  string $client_id Filter by client MAC (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessFailedConnectionsAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $serial = null, $client_id = null)
    {
        return $this->getNetworkWirelessFailedConnectionsAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $serial, $client_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessFailedConnectionsAsyncWithHttpInfo
     *
     * List of all failed client connection events on this network in a given time range
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $serial Filter by AP (optional)
     * @param  string $client_id Filter by client MAC (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessFailedConnectionsAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $serial = null, $client_id = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessFailedConnectionsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $serial, $client_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessFailedConnections'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $serial Filter by AP (optional)
     * @param  string $client_id Filter by client MAC (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessFailedConnectionsRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $serial = null, $client_id = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessFailedConnections'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/failedConnections';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }
        // query params
        if ($vlan !== null) {
            $queryParams['vlan'] = ObjectSerializer::toQueryValue($vlan);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }
        // query params
        if ($serial !== null) {
            $queryParams['serial'] = ObjectSerializer::toQueryValue($serial);
        }
        // query params
        if ($client_id !== null) {
            $queryParams['clientId'] = ObjectSerializer::toQueryValue($client_id);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessLatencyHistory
     *
     * Return average wireless latency over time for a network, device, or network client
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     * @param  string $access_category Filter by access category. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessLatencyHistory($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null, $access_category = null)
    {
        list($response) = $this->getNetworkWirelessLatencyHistoryWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid, $access_category);
        return $response;
    }

    /**
     * Operation getNetworkWirelessLatencyHistoryWithHttpInfo
     *
     * Return average wireless latency over time for a network, device, or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     * @param  string $access_category Filter by access category. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessLatencyHistoryWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null, $access_category = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessLatencyHistoryRequest($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid, $access_category);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessLatencyHistoryAsync
     *
     * Return average wireless latency over time for a network, device, or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     * @param  string $access_category Filter by access category. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessLatencyHistoryAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null, $access_category = null)
    {
        return $this->getNetworkWirelessLatencyHistoryAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid, $access_category)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessLatencyHistoryAsyncWithHttpInfo
     *
     * Return average wireless latency over time for a network, device, or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     * @param  string $access_category Filter by access category. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessLatencyHistoryAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null, $access_category = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessLatencyHistoryRequest($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid, $access_category);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessLatencyHistory'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     * @param  string $access_category Filter by access category. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessLatencyHistoryRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null, $access_category = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessLatencyHistory'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/latencyHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($resolution !== null) {
            $queryParams['resolution'] = ObjectSerializer::toQueryValue($resolution);
        }
        // query params
        if ($auto_resolution !== null) {
            $queryParams['autoResolution'] = ObjectSerializer::toQueryValue($auto_resolution);
        }
        // query params
        if ($client_id !== null) {
            $queryParams['clientId'] = ObjectSerializer::toQueryValue($client_id);
        }
        // query params
        if ($device_serial !== null) {
            $queryParams['deviceSerial'] = ObjectSerializer::toQueryValue($device_serial);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }
        // query params
        if ($access_category !== null) {
            $queryParams['accessCategory'] = ObjectSerializer::toQueryValue($access_category);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessLatencyStats
     *
     * Aggregated latency info for this network
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessLatencyStats($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        list($response) = $this->getNetworkWirelessLatencyStatsWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields);
        return $response;
    }

    /**
     * Operation getNetworkWirelessLatencyStatsWithHttpInfo
     *
     * Aggregated latency info for this network
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessLatencyStatsWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessLatencyStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessLatencyStatsAsync
     *
     * Aggregated latency info for this network
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessLatencyStatsAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        return $this->getNetworkWirelessLatencyStatsAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessLatencyStatsAsyncWithHttpInfo
     *
     * Aggregated latency info for this network
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessLatencyStatsAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessLatencyStatsRequest($network_id, $t0, $t1, $timespan, $band, $ssid, $vlan, $ap_tag, $fields);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessLatencyStats'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 180 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 7 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 7 days. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). Note that data prior to February 2020 will not have band information. (optional)
     * @param  int $ssid Filter results by SSID (optional)
     * @param  int $vlan Filter results by VLAN (optional)
     * @param  string $ap_tag Filter results by AP Tag (optional)
     * @param  string $fields Partial selection: If present, this call will return only the selected fields of [\&quot;rawDistribution\&quot;, \&quot;avg\&quot;]. All fields will be returned by default. Selected fields must be entered as a comma separated string. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessLatencyStatsRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $band = null, $ssid = null, $vlan = null, $ap_tag = null, $fields = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessLatencyStats'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/latencyStats';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }
        // query params
        if ($vlan !== null) {
            $queryParams['vlan'] = ObjectSerializer::toQueryValue($vlan);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }
        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessMeshStatuses
     *
     * List wireless mesh statuses for repeaters
     *
     * @param  string $network_id network_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 500. Default is 50. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessMeshStatuses($network_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        list($response) = $this->getNetworkWirelessMeshStatusesWithHttpInfo($network_id, $per_page, $starting_after, $ending_before);
        return $response;
    }

    /**
     * Operation getNetworkWirelessMeshStatusesWithHttpInfo
     *
     * List wireless mesh statuses for repeaters
     *
     * @param  string $network_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 500. Default is 50. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessMeshStatusesWithHttpInfo($network_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessMeshStatusesRequest($network_id, $per_page, $starting_after, $ending_before);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessMeshStatusesAsync
     *
     * List wireless mesh statuses for repeaters
     *
     * @param  string $network_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 500. Default is 50. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessMeshStatusesAsync($network_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        return $this->getNetworkWirelessMeshStatusesAsyncWithHttpInfo($network_id, $per_page, $starting_after, $ending_before)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessMeshStatusesAsyncWithHttpInfo
     *
     * List wireless mesh statuses for repeaters
     *
     * @param  string $network_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 500. Default is 50. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessMeshStatusesAsyncWithHttpInfo($network_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessMeshStatusesRequest($network_id, $per_page, $starting_after, $ending_before);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessMeshStatuses'
     *
     * @param  string $network_id (required)
     * @param  int $per_page The number of entries per page returned. Acceptable range is 3 - 500. Default is 50. (optional)
     * @param  string $starting_after A token used by the server to indicate the start of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     * @param  string $ending_before A token used by the server to indicate the end of the page. Often this is a timestamp or an ID but it is not limited to those. This parameter should not be defined by client applications. The link for the first, last, prev, or next page in the HTTP Link header should define it. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessMeshStatusesRequest($network_id, $per_page = null, $starting_after = null, $ending_before = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessMeshStatuses'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/meshStatuses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($per_page !== null) {
            $queryParams['perPage'] = ObjectSerializer::toQueryValue($per_page);
        }
        // query params
        if ($starting_after !== null) {
            $queryParams['startingAfter'] = ObjectSerializer::toQueryValue($starting_after);
        }
        // query params
        if ($ending_before !== null) {
            $queryParams['endingBefore'] = ObjectSerializer::toQueryValue($ending_before);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessRfProfile
     *
     * Return a RF profile
     *
     * @param  string $network_id network_id (required)
     * @param  string $rf_profile_id rf_profile_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessRfProfile($network_id, $rf_profile_id)
    {
        list($response) = $this->getNetworkWirelessRfProfileWithHttpInfo($network_id, $rf_profile_id);
        return $response;
    }

    /**
     * Operation getNetworkWirelessRfProfileWithHttpInfo
     *
     * Return a RF profile
     *
     * @param  string $network_id (required)
     * @param  string $rf_profile_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessRfProfileWithHttpInfo($network_id, $rf_profile_id)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessRfProfileRequest($network_id, $rf_profile_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessRfProfileAsync
     *
     * Return a RF profile
     *
     * @param  string $network_id (required)
     * @param  string $rf_profile_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessRfProfileAsync($network_id, $rf_profile_id)
    {
        return $this->getNetworkWirelessRfProfileAsyncWithHttpInfo($network_id, $rf_profile_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessRfProfileAsyncWithHttpInfo
     *
     * Return a RF profile
     *
     * @param  string $network_id (required)
     * @param  string $rf_profile_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessRfProfileAsyncWithHttpInfo($network_id, $rf_profile_id)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessRfProfileRequest($network_id, $rf_profile_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessRfProfile'
     *
     * @param  string $network_id (required)
     * @param  string $rf_profile_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessRfProfileRequest($network_id, $rf_profile_id)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessRfProfile'
            );
        }
        // verify the required parameter 'rf_profile_id' is set
        if ($rf_profile_id === null || (is_array($rf_profile_id) && count($rf_profile_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rf_profile_id when calling getNetworkWirelessRfProfile'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/rfProfiles/{rfProfileId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($rf_profile_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rfProfileId' . '}',
                ObjectSerializer::toPathValue($rf_profile_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessRfProfiles
     *
     * List the non-basic RF profiles for this network
     *
     * @param  string $network_id network_id (required)
     * @param  bool $include_template_profiles If the network is bound to a template, this parameter controls whether or not the non-basic RF profiles defined on the template should be included in the response alongside the non-basic profiles defined on the bound network. Defaults to false. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessRfProfiles($network_id, $include_template_profiles = null)
    {
        list($response) = $this->getNetworkWirelessRfProfilesWithHttpInfo($network_id, $include_template_profiles);
        return $response;
    }

    /**
     * Operation getNetworkWirelessRfProfilesWithHttpInfo
     *
     * List the non-basic RF profiles for this network
     *
     * @param  string $network_id (required)
     * @param  bool $include_template_profiles If the network is bound to a template, this parameter controls whether or not the non-basic RF profiles defined on the template should be included in the response alongside the non-basic profiles defined on the bound network. Defaults to false. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessRfProfilesWithHttpInfo($network_id, $include_template_profiles = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessRfProfilesRequest($network_id, $include_template_profiles);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessRfProfilesAsync
     *
     * List the non-basic RF profiles for this network
     *
     * @param  string $network_id (required)
     * @param  bool $include_template_profiles If the network is bound to a template, this parameter controls whether or not the non-basic RF profiles defined on the template should be included in the response alongside the non-basic profiles defined on the bound network. Defaults to false. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessRfProfilesAsync($network_id, $include_template_profiles = null)
    {
        return $this->getNetworkWirelessRfProfilesAsyncWithHttpInfo($network_id, $include_template_profiles)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessRfProfilesAsyncWithHttpInfo
     *
     * List the non-basic RF profiles for this network
     *
     * @param  string $network_id (required)
     * @param  bool $include_template_profiles If the network is bound to a template, this parameter controls whether or not the non-basic RF profiles defined on the template should be included in the response alongside the non-basic profiles defined on the bound network. Defaults to false. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessRfProfilesAsyncWithHttpInfo($network_id, $include_template_profiles = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessRfProfilesRequest($network_id, $include_template_profiles);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessRfProfiles'
     *
     * @param  string $network_id (required)
     * @param  bool $include_template_profiles If the network is bound to a template, this parameter controls whether or not the non-basic RF profiles defined on the template should be included in the response alongside the non-basic profiles defined on the bound network. Defaults to false. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessRfProfilesRequest($network_id, $include_template_profiles = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessRfProfiles'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/rfProfiles';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($include_template_profiles !== null) {
            $queryParams['includeTemplateProfiles'] = ObjectSerializer::toQueryValue($include_template_profiles);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessSettings
     *
     * Return the wireless settings for a network
     *
     * @param  string $network_id network_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessSettings($network_id)
    {
        list($response) = $this->getNetworkWirelessSettingsWithHttpInfo($network_id);
        return $response;
    }

    /**
     * Operation getNetworkWirelessSettingsWithHttpInfo
     *
     * Return the wireless settings for a network
     *
     * @param  string $network_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessSettingsWithHttpInfo($network_id)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSettingsRequest($network_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessSettingsAsync
     *
     * Return the wireless settings for a network
     *
     * @param  string $network_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSettingsAsync($network_id)
    {
        return $this->getNetworkWirelessSettingsAsyncWithHttpInfo($network_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessSettingsAsyncWithHttpInfo
     *
     * Return the wireless settings for a network
     *
     * @param  string $network_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSettingsAsyncWithHttpInfo($network_id)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSettingsRequest($network_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessSettings'
     *
     * @param  string $network_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessSettingsRequest($network_id)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessSettings'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessSignalQualityHistory
     *
     * Return signal quality (SNR/RSSI) over time for a device or network client
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessSignalQualityHistory($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        list($response) = $this->getNetworkWirelessSignalQualityHistoryWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid);
        return $response;
    }

    /**
     * Operation getNetworkWirelessSignalQualityHistoryWithHttpInfo
     *
     * Return signal quality (SNR/RSSI) over time for a device or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessSignalQualityHistoryWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSignalQualityHistoryRequest($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessSignalQualityHistoryAsync
     *
     * Return signal quality (SNR/RSSI) over time for a device or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSignalQualityHistoryAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        return $this->getNetworkWirelessSignalQualityHistoryAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessSignalQualityHistoryAsyncWithHttpInfo
     *
     * Return signal quality (SNR/RSSI) over time for a device or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSignalQualityHistoryAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSignalQualityHistoryRequest($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessSignalQualityHistory'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client. (optional)
     * @param  string $device_serial Filter results by device. (optional)
     * @param  string $ap_tag Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessSignalQualityHistoryRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessSignalQualityHistory'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/signalQualityHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($resolution !== null) {
            $queryParams['resolution'] = ObjectSerializer::toQueryValue($resolution);
        }
        // query params
        if ($auto_resolution !== null) {
            $queryParams['autoResolution'] = ObjectSerializer::toQueryValue($auto_resolution);
        }
        // query params
        if ($client_id !== null) {
            $queryParams['clientId'] = ObjectSerializer::toQueryValue($client_id);
        }
        // query params
        if ($device_serial !== null) {
            $queryParams['deviceSerial'] = ObjectSerializer::toQueryValue($device_serial);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessSsid
     *
     * Return a single MR SSID
     *
     * @param  string $network_id network_id (required)
     * @param  string $number number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessSsid($network_id, $number)
    {
        list($response) = $this->getNetworkWirelessSsidWithHttpInfo($network_id, $number);
        return $response;
    }

    /**
     * Operation getNetworkWirelessSsidWithHttpInfo
     *
     * Return a single MR SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessSsidWithHttpInfo($network_id, $number)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSsidRequest($network_id, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessSsidAsync
     *
     * Return a single MR SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSsidAsync($network_id, $number)
    {
        return $this->getNetworkWirelessSsidAsyncWithHttpInfo($network_id, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessSsidAsyncWithHttpInfo
     *
     * Return a single MR SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSsidAsyncWithHttpInfo($network_id, $number)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSsidRequest($network_id, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessSsid'
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessSsidRequest($network_id, $number)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessSsid'
            );
        }
        // verify the required parameter 'number' is set
        if ($number === null || (is_array($number) && count($number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling getNetworkWirelessSsid'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/ssids/{number}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($number !== null) {
            $resourcePath = str_replace(
                '{' . 'number' . '}',
                ObjectSerializer::toPathValue($number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessSsidBonjourForwarding
     *
     * List the Bonjour forwarding setting and rules for the SSID
     *
     * @param  string $network_id network_id (required)
     * @param  string $number number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessSsidBonjourForwarding($network_id, $number)
    {
        list($response) = $this->getNetworkWirelessSsidBonjourForwardingWithHttpInfo($network_id, $number);
        return $response;
    }

    /**
     * Operation getNetworkWirelessSsidBonjourForwardingWithHttpInfo
     *
     * List the Bonjour forwarding setting and rules for the SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessSsidBonjourForwardingWithHttpInfo($network_id, $number)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSsidBonjourForwardingRequest($network_id, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessSsidBonjourForwardingAsync
     *
     * List the Bonjour forwarding setting and rules for the SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSsidBonjourForwardingAsync($network_id, $number)
    {
        return $this->getNetworkWirelessSsidBonjourForwardingAsyncWithHttpInfo($network_id, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessSsidBonjourForwardingAsyncWithHttpInfo
     *
     * List the Bonjour forwarding setting and rules for the SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSsidBonjourForwardingAsyncWithHttpInfo($network_id, $number)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSsidBonjourForwardingRequest($network_id, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessSsidBonjourForwarding'
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessSsidBonjourForwardingRequest($network_id, $number)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessSsidBonjourForwarding'
            );
        }
        // verify the required parameter 'number' is set
        if ($number === null || (is_array($number) && count($number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling getNetworkWirelessSsidBonjourForwarding'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/ssids/{number}/bonjourForwarding';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($number !== null) {
            $resourcePath = str_replace(
                '{' . 'number' . '}',
                ObjectSerializer::toPathValue($number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessSsidDeviceTypeGroupPolicies
     *
     * List the device type group policies for the SSID
     *
     * @param  string $network_id network_id (required)
     * @param  string $number number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessSsidDeviceTypeGroupPolicies($network_id, $number)
    {
        list($response) = $this->getNetworkWirelessSsidDeviceTypeGroupPoliciesWithHttpInfo($network_id, $number);
        return $response;
    }

    /**
     * Operation getNetworkWirelessSsidDeviceTypeGroupPoliciesWithHttpInfo
     *
     * List the device type group policies for the SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessSsidDeviceTypeGroupPoliciesWithHttpInfo($network_id, $number)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSsidDeviceTypeGroupPoliciesRequest($network_id, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessSsidDeviceTypeGroupPoliciesAsync
     *
     * List the device type group policies for the SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSsidDeviceTypeGroupPoliciesAsync($network_id, $number)
    {
        return $this->getNetworkWirelessSsidDeviceTypeGroupPoliciesAsyncWithHttpInfo($network_id, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessSsidDeviceTypeGroupPoliciesAsyncWithHttpInfo
     *
     * List the device type group policies for the SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSsidDeviceTypeGroupPoliciesAsyncWithHttpInfo($network_id, $number)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSsidDeviceTypeGroupPoliciesRequest($network_id, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessSsidDeviceTypeGroupPolicies'
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessSsidDeviceTypeGroupPoliciesRequest($network_id, $number)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessSsidDeviceTypeGroupPolicies'
            );
        }
        // verify the required parameter 'number' is set
        if ($number === null || (is_array($number) && count($number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling getNetworkWirelessSsidDeviceTypeGroupPolicies'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/ssids/{number}/deviceTypeGroupPolicies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($number !== null) {
            $resourcePath = str_replace(
                '{' . 'number' . '}',
                ObjectSerializer::toPathValue($number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessSsidEapOverride
     *
     * Return the EAP overridden parameters for an SSID
     *
     * @param  string $network_id network_id (required)
     * @param  string $number number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessSsidEapOverride($network_id, $number)
    {
        list($response) = $this->getNetworkWirelessSsidEapOverrideWithHttpInfo($network_id, $number);
        return $response;
    }

    /**
     * Operation getNetworkWirelessSsidEapOverrideWithHttpInfo
     *
     * Return the EAP overridden parameters for an SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessSsidEapOverrideWithHttpInfo($network_id, $number)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSsidEapOverrideRequest($network_id, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessSsidEapOverrideAsync
     *
     * Return the EAP overridden parameters for an SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSsidEapOverrideAsync($network_id, $number)
    {
        return $this->getNetworkWirelessSsidEapOverrideAsyncWithHttpInfo($network_id, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessSsidEapOverrideAsyncWithHttpInfo
     *
     * Return the EAP overridden parameters for an SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSsidEapOverrideAsyncWithHttpInfo($network_id, $number)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSsidEapOverrideRequest($network_id, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessSsidEapOverride'
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessSsidEapOverrideRequest($network_id, $number)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessSsidEapOverride'
            );
        }
        // verify the required parameter 'number' is set
        if ($number === null || (is_array($number) && count($number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling getNetworkWirelessSsidEapOverride'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/ssids/{number}/eapOverride';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($number !== null) {
            $resourcePath = str_replace(
                '{' . 'number' . '}',
                ObjectSerializer::toPathValue($number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessSsidFirewallL3FirewallRules
     *
     * Return the L3 firewall rules for an SSID on an MR network
     *
     * @param  string $network_id network_id (required)
     * @param  string $number number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessSsidFirewallL3FirewallRules($network_id, $number)
    {
        list($response) = $this->getNetworkWirelessSsidFirewallL3FirewallRulesWithHttpInfo($network_id, $number);
        return $response;
    }

    /**
     * Operation getNetworkWirelessSsidFirewallL3FirewallRulesWithHttpInfo
     *
     * Return the L3 firewall rules for an SSID on an MR network
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessSsidFirewallL3FirewallRulesWithHttpInfo($network_id, $number)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSsidFirewallL3FirewallRulesRequest($network_id, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessSsidFirewallL3FirewallRulesAsync
     *
     * Return the L3 firewall rules for an SSID on an MR network
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSsidFirewallL3FirewallRulesAsync($network_id, $number)
    {
        return $this->getNetworkWirelessSsidFirewallL3FirewallRulesAsyncWithHttpInfo($network_id, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessSsidFirewallL3FirewallRulesAsyncWithHttpInfo
     *
     * Return the L3 firewall rules for an SSID on an MR network
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSsidFirewallL3FirewallRulesAsyncWithHttpInfo($network_id, $number)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSsidFirewallL3FirewallRulesRequest($network_id, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessSsidFirewallL3FirewallRules'
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessSsidFirewallL3FirewallRulesRequest($network_id, $number)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessSsidFirewallL3FirewallRules'
            );
        }
        // verify the required parameter 'number' is set
        if ($number === null || (is_array($number) && count($number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling getNetworkWirelessSsidFirewallL3FirewallRules'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/ssids/{number}/firewall/l3FirewallRules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($number !== null) {
            $resourcePath = str_replace(
                '{' . 'number' . '}',
                ObjectSerializer::toPathValue($number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessSsidFirewallL7FirewallRules
     *
     * Return the L7 firewall rules for an SSID on an MR network
     *
     * @param  string $network_id network_id (required)
     * @param  string $number number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessSsidFirewallL7FirewallRules($network_id, $number)
    {
        list($response) = $this->getNetworkWirelessSsidFirewallL7FirewallRulesWithHttpInfo($network_id, $number);
        return $response;
    }

    /**
     * Operation getNetworkWirelessSsidFirewallL7FirewallRulesWithHttpInfo
     *
     * Return the L7 firewall rules for an SSID on an MR network
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessSsidFirewallL7FirewallRulesWithHttpInfo($network_id, $number)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSsidFirewallL7FirewallRulesRequest($network_id, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessSsidFirewallL7FirewallRulesAsync
     *
     * Return the L7 firewall rules for an SSID on an MR network
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSsidFirewallL7FirewallRulesAsync($network_id, $number)
    {
        return $this->getNetworkWirelessSsidFirewallL7FirewallRulesAsyncWithHttpInfo($network_id, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessSsidFirewallL7FirewallRulesAsyncWithHttpInfo
     *
     * Return the L7 firewall rules for an SSID on an MR network
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSsidFirewallL7FirewallRulesAsyncWithHttpInfo($network_id, $number)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSsidFirewallL7FirewallRulesRequest($network_id, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessSsidFirewallL7FirewallRules'
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessSsidFirewallL7FirewallRulesRequest($network_id, $number)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessSsidFirewallL7FirewallRules'
            );
        }
        // verify the required parameter 'number' is set
        if ($number === null || (is_array($number) && count($number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling getNetworkWirelessSsidFirewallL7FirewallRules'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/ssids/{number}/firewall/l7FirewallRules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($number !== null) {
            $resourcePath = str_replace(
                '{' . 'number' . '}',
                ObjectSerializer::toPathValue($number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessSsidHotspot20
     *
     * Return the Hotspot 2.0 settings for an SSID
     *
     * @param  string $network_id network_id (required)
     * @param  string $number number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessSsidHotspot20($network_id, $number)
    {
        list($response) = $this->getNetworkWirelessSsidHotspot20WithHttpInfo($network_id, $number);
        return $response;
    }

    /**
     * Operation getNetworkWirelessSsidHotspot20WithHttpInfo
     *
     * Return the Hotspot 2.0 settings for an SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessSsidHotspot20WithHttpInfo($network_id, $number)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSsidHotspot20Request($network_id, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessSsidHotspot20Async
     *
     * Return the Hotspot 2.0 settings for an SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSsidHotspot20Async($network_id, $number)
    {
        return $this->getNetworkWirelessSsidHotspot20AsyncWithHttpInfo($network_id, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessSsidHotspot20AsyncWithHttpInfo
     *
     * Return the Hotspot 2.0 settings for an SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSsidHotspot20AsyncWithHttpInfo($network_id, $number)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSsidHotspot20Request($network_id, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessSsidHotspot20'
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessSsidHotspot20Request($network_id, $number)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessSsidHotspot20'
            );
        }
        // verify the required parameter 'number' is set
        if ($number === null || (is_array($number) && count($number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling getNetworkWirelessSsidHotspot20'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/ssids/{number}/hotspot20';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($number !== null) {
            $resourcePath = str_replace(
                '{' . 'number' . '}',
                ObjectSerializer::toPathValue($number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessSsidIdentityPsk
     *
     * Return an Identity PSK
     *
     * @param  string $network_id network_id (required)
     * @param  string $number number (required)
     * @param  string $identity_psk_id identity_psk_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessSsidIdentityPsk($network_id, $number, $identity_psk_id)
    {
        list($response) = $this->getNetworkWirelessSsidIdentityPskWithHttpInfo($network_id, $number, $identity_psk_id);
        return $response;
    }

    /**
     * Operation getNetworkWirelessSsidIdentityPskWithHttpInfo
     *
     * Return an Identity PSK
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  string $identity_psk_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessSsidIdentityPskWithHttpInfo($network_id, $number, $identity_psk_id)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSsidIdentityPskRequest($network_id, $number, $identity_psk_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessSsidIdentityPskAsync
     *
     * Return an Identity PSK
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  string $identity_psk_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSsidIdentityPskAsync($network_id, $number, $identity_psk_id)
    {
        return $this->getNetworkWirelessSsidIdentityPskAsyncWithHttpInfo($network_id, $number, $identity_psk_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessSsidIdentityPskAsyncWithHttpInfo
     *
     * Return an Identity PSK
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  string $identity_psk_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSsidIdentityPskAsyncWithHttpInfo($network_id, $number, $identity_psk_id)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSsidIdentityPskRequest($network_id, $number, $identity_psk_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessSsidIdentityPsk'
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  string $identity_psk_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessSsidIdentityPskRequest($network_id, $number, $identity_psk_id)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessSsidIdentityPsk'
            );
        }
        // verify the required parameter 'number' is set
        if ($number === null || (is_array($number) && count($number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling getNetworkWirelessSsidIdentityPsk'
            );
        }
        // verify the required parameter 'identity_psk_id' is set
        if ($identity_psk_id === null || (is_array($identity_psk_id) && count($identity_psk_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identity_psk_id when calling getNetworkWirelessSsidIdentityPsk'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/ssids/{number}/identityPsks/{identityPskId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($number !== null) {
            $resourcePath = str_replace(
                '{' . 'number' . '}',
                ObjectSerializer::toPathValue($number),
                $resourcePath
            );
        }
        // path params
        if ($identity_psk_id !== null) {
            $resourcePath = str_replace(
                '{' . 'identityPskId' . '}',
                ObjectSerializer::toPathValue($identity_psk_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessSsidIdentityPsks
     *
     * List all Identity PSKs in a wireless network
     *
     * @param  string $network_id network_id (required)
     * @param  string $number number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessSsidIdentityPsks($network_id, $number)
    {
        list($response) = $this->getNetworkWirelessSsidIdentityPsksWithHttpInfo($network_id, $number);
        return $response;
    }

    /**
     * Operation getNetworkWirelessSsidIdentityPsksWithHttpInfo
     *
     * List all Identity PSKs in a wireless network
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessSsidIdentityPsksWithHttpInfo($network_id, $number)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSsidIdentityPsksRequest($network_id, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessSsidIdentityPsksAsync
     *
     * List all Identity PSKs in a wireless network
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSsidIdentityPsksAsync($network_id, $number)
    {
        return $this->getNetworkWirelessSsidIdentityPsksAsyncWithHttpInfo($network_id, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessSsidIdentityPsksAsyncWithHttpInfo
     *
     * List all Identity PSKs in a wireless network
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSsidIdentityPsksAsyncWithHttpInfo($network_id, $number)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSsidIdentityPsksRequest($network_id, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessSsidIdentityPsks'
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessSsidIdentityPsksRequest($network_id, $number)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessSsidIdentityPsks'
            );
        }
        // verify the required parameter 'number' is set
        if ($number === null || (is_array($number) && count($number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling getNetworkWirelessSsidIdentityPsks'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/ssids/{number}/identityPsks';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($number !== null) {
            $resourcePath = str_replace(
                '{' . 'number' . '}',
                ObjectSerializer::toPathValue($number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessSsidSchedules
     *
     * List the outage schedule for the SSID
     *
     * @param  string $network_id network_id (required)
     * @param  string $number number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessSsidSchedules($network_id, $number)
    {
        list($response) = $this->getNetworkWirelessSsidSchedulesWithHttpInfo($network_id, $number);
        return $response;
    }

    /**
     * Operation getNetworkWirelessSsidSchedulesWithHttpInfo
     *
     * List the outage schedule for the SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessSsidSchedulesWithHttpInfo($network_id, $number)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSsidSchedulesRequest($network_id, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessSsidSchedulesAsync
     *
     * List the outage schedule for the SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSsidSchedulesAsync($network_id, $number)
    {
        return $this->getNetworkWirelessSsidSchedulesAsyncWithHttpInfo($network_id, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessSsidSchedulesAsyncWithHttpInfo
     *
     * List the outage schedule for the SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSsidSchedulesAsyncWithHttpInfo($network_id, $number)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSsidSchedulesRequest($network_id, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessSsidSchedules'
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessSsidSchedulesRequest($network_id, $number)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessSsidSchedules'
            );
        }
        // verify the required parameter 'number' is set
        if ($number === null || (is_array($number) && count($number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling getNetworkWirelessSsidSchedules'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/ssids/{number}/schedules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($number !== null) {
            $resourcePath = str_replace(
                '{' . 'number' . '}',
                ObjectSerializer::toPathValue($number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessSsidSplashSettings
     *
     * Display the splash page settings for the given SSID
     *
     * @param  string $network_id network_id (required)
     * @param  string $number number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessSsidSplashSettings($network_id, $number)
    {
        list($response) = $this->getNetworkWirelessSsidSplashSettingsWithHttpInfo($network_id, $number);
        return $response;
    }

    /**
     * Operation getNetworkWirelessSsidSplashSettingsWithHttpInfo
     *
     * Display the splash page settings for the given SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessSsidSplashSettingsWithHttpInfo($network_id, $number)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSsidSplashSettingsRequest($network_id, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessSsidSplashSettingsAsync
     *
     * Display the splash page settings for the given SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSsidSplashSettingsAsync($network_id, $number)
    {
        return $this->getNetworkWirelessSsidSplashSettingsAsyncWithHttpInfo($network_id, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessSsidSplashSettingsAsyncWithHttpInfo
     *
     * Display the splash page settings for the given SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSsidSplashSettingsAsyncWithHttpInfo($network_id, $number)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSsidSplashSettingsRequest($network_id, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessSsidSplashSettings'
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessSsidSplashSettingsRequest($network_id, $number)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessSsidSplashSettings'
            );
        }
        // verify the required parameter 'number' is set
        if ($number === null || (is_array($number) && count($number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling getNetworkWirelessSsidSplashSettings'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/ssids/{number}/splash/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($number !== null) {
            $resourcePath = str_replace(
                '{' . 'number' . '}',
                ObjectSerializer::toPathValue($number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessSsidTrafficShapingRules
     *
     * Display the traffic shaping settings for a SSID on an MR network
     *
     * @param  string $network_id network_id (required)
     * @param  string $number number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessSsidTrafficShapingRules($network_id, $number)
    {
        list($response) = $this->getNetworkWirelessSsidTrafficShapingRulesWithHttpInfo($network_id, $number);
        return $response;
    }

    /**
     * Operation getNetworkWirelessSsidTrafficShapingRulesWithHttpInfo
     *
     * Display the traffic shaping settings for a SSID on an MR network
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessSsidTrafficShapingRulesWithHttpInfo($network_id, $number)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSsidTrafficShapingRulesRequest($network_id, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessSsidTrafficShapingRulesAsync
     *
     * Display the traffic shaping settings for a SSID on an MR network
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSsidTrafficShapingRulesAsync($network_id, $number)
    {
        return $this->getNetworkWirelessSsidTrafficShapingRulesAsyncWithHttpInfo($network_id, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessSsidTrafficShapingRulesAsyncWithHttpInfo
     *
     * Display the traffic shaping settings for a SSID on an MR network
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSsidTrafficShapingRulesAsyncWithHttpInfo($network_id, $number)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSsidTrafficShapingRulesRequest($network_id, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessSsidTrafficShapingRules'
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessSsidTrafficShapingRulesRequest($network_id, $number)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessSsidTrafficShapingRules'
            );
        }
        // verify the required parameter 'number' is set
        if ($number === null || (is_array($number) && count($number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling getNetworkWirelessSsidTrafficShapingRules'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/ssids/{number}/trafficShaping/rules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($number !== null) {
            $resourcePath = str_replace(
                '{' . 'number' . '}',
                ObjectSerializer::toPathValue($number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessSsidVpn
     *
     * List the VPN settings for the SSID.
     *
     * @param  string $network_id network_id (required)
     * @param  string $number number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessSsidVpn($network_id, $number)
    {
        list($response) = $this->getNetworkWirelessSsidVpnWithHttpInfo($network_id, $number);
        return $response;
    }

    /**
     * Operation getNetworkWirelessSsidVpnWithHttpInfo
     *
     * List the VPN settings for the SSID.
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessSsidVpnWithHttpInfo($network_id, $number)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSsidVpnRequest($network_id, $number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessSsidVpnAsync
     *
     * List the VPN settings for the SSID.
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSsidVpnAsync($network_id, $number)
    {
        return $this->getNetworkWirelessSsidVpnAsyncWithHttpInfo($network_id, $number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessSsidVpnAsyncWithHttpInfo
     *
     * List the VPN settings for the SSID.
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSsidVpnAsyncWithHttpInfo($network_id, $number)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSsidVpnRequest($network_id, $number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessSsidVpn'
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessSsidVpnRequest($network_id, $number)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessSsidVpn'
            );
        }
        // verify the required parameter 'number' is set
        if ($number === null || (is_array($number) && count($number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling getNetworkWirelessSsidVpn'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/ssids/{number}/vpn';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($number !== null) {
            $resourcePath = str_replace(
                '{' . 'number' . '}',
                ObjectSerializer::toPathValue($number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessSsids
     *
     * List the MR SSIDs in a network
     *
     * @param  string $network_id network_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessSsids($network_id)
    {
        list($response) = $this->getNetworkWirelessSsidsWithHttpInfo($network_id);
        return $response;
    }

    /**
     * Operation getNetworkWirelessSsidsWithHttpInfo
     *
     * List the MR SSIDs in a network
     *
     * @param  string $network_id (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessSsidsWithHttpInfo($network_id)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSsidsRequest($network_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessSsidsAsync
     *
     * List the MR SSIDs in a network
     *
     * @param  string $network_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSsidsAsync($network_id)
    {
        return $this->getNetworkWirelessSsidsAsyncWithHttpInfo($network_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessSsidsAsyncWithHttpInfo
     *
     * List the MR SSIDs in a network
     *
     * @param  string $network_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessSsidsAsyncWithHttpInfo($network_id)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessSsidsRequest($network_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessSsids'
     *
     * @param  string $network_id (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessSsidsRequest($network_id)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessSsids'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/ssids';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getNetworkWirelessUsageHistory
     *
     * Return AP usage over time for a device or network client
     *
     * @param  string $network_id network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client to return per-device AP usage over time inner joined by the queried client&#39;s connection history. (optional)
     * @param  string $device_serial Filter results by device. Requires :band. (optional)
     * @param  string $ap_tag Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function getNetworkWirelessUsageHistory($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        list($response) = $this->getNetworkWirelessUsageHistoryWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid);
        return $response;
    }

    /**
     * Operation getNetworkWirelessUsageHistoryWithHttpInfo
     *
     * Return AP usage over time for a device or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client to return per-device AP usage over time inner joined by the queried client&#39;s connection history. (optional)
     * @param  string $device_serial Filter results by device. Requires :band. (optional)
     * @param  string $ap_tag Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getNetworkWirelessUsageHistoryWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessUsageHistoryRequest($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getNetworkWirelessUsageHistoryAsync
     *
     * Return AP usage over time for a device or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client to return per-device AP usage over time inner joined by the queried client&#39;s connection history. (optional)
     * @param  string $device_serial Filter results by device. Requires :band. (optional)
     * @param  string $ap_tag Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessUsageHistoryAsync($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        return $this->getNetworkWirelessUsageHistoryAsyncWithHttpInfo($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getNetworkWirelessUsageHistoryAsyncWithHttpInfo
     *
     * Return AP usage over time for a device or network client
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client to return per-device AP usage over time inner joined by the queried client&#39;s connection history. (optional)
     * @param  string $device_serial Filter results by device. Requires :band. (optional)
     * @param  string $ap_tag Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getNetworkWirelessUsageHistoryAsyncWithHttpInfo($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        $returnType = 'object';
        $request = $this->getNetworkWirelessUsageHistoryRequest($network_id, $t0, $t1, $timespan, $resolution, $auto_resolution, $client_id, $device_serial, $ap_tag, $band, $ssid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getNetworkWirelessUsageHistory'
     *
     * @param  string $network_id (required)
     * @param  string $t0 The beginning of the timespan for the data. The maximum lookback period is 31 days from today. (optional)
     * @param  string $t1 The end of the timespan for the data. t1 can be a maximum of 31 days after t0. (optional)
     * @param  float $timespan The timespan for which the information will be fetched. If specifying timespan, do not specify parameters t0 and t1. The value must be in seconds and be less than or equal to 31 days. The default is 7 days. (optional)
     * @param  int $resolution The time resolution in seconds for returned data. The valid resolutions are: 300, 600, 1200, 3600, 14400, 86400. The default is 86400. (optional)
     * @param  bool $auto_resolution Automatically select a data resolution based on the given timespan; this overrides the value specified by the &#39;resolution&#39; parameter. The default setting is false. (optional)
     * @param  string $client_id Filter results by network client to return per-device AP usage over time inner joined by the queried client&#39;s connection history. (optional)
     * @param  string $device_serial Filter results by device. Requires :band. (optional)
     * @param  string $ap_tag Filter results by AP tag; either :clientId or :deviceSerial must be jointly specified. (optional)
     * @param  string $band Filter results by band (either &#39;2.4&#39; or &#39;5&#39;). (optional)
     * @param  int $ssid Filter results by SSID number. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getNetworkWirelessUsageHistoryRequest($network_id, $t0 = null, $t1 = null, $timespan = null, $resolution = null, $auto_resolution = null, $client_id = null, $device_serial = null, $ap_tag = null, $band = null, $ssid = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling getNetworkWirelessUsageHistory'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/usageHistory';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($t0 !== null) {
            $queryParams['t0'] = ObjectSerializer::toQueryValue($t0);
        }
        // query params
        if ($t1 !== null) {
            $queryParams['t1'] = ObjectSerializer::toQueryValue($t1);
        }
        // query params
        if ($timespan !== null) {
            $queryParams['timespan'] = ObjectSerializer::toQueryValue($timespan);
        }
        // query params
        if ($resolution !== null) {
            $queryParams['resolution'] = ObjectSerializer::toQueryValue($resolution);
        }
        // query params
        if ($auto_resolution !== null) {
            $queryParams['autoResolution'] = ObjectSerializer::toQueryValue($auto_resolution);
        }
        // query params
        if ($client_id !== null) {
            $queryParams['clientId'] = ObjectSerializer::toQueryValue($client_id);
        }
        // query params
        if ($device_serial !== null) {
            $queryParams['deviceSerial'] = ObjectSerializer::toQueryValue($device_serial);
        }
        // query params
        if ($ap_tag !== null) {
            $queryParams['apTag'] = ObjectSerializer::toQueryValue($ap_tag);
        }
        // query params
        if ($band !== null) {
            $queryParams['band'] = ObjectSerializer::toQueryValue($band);
        }
        // query params
        if ($ssid !== null) {
            $queryParams['ssid'] = ObjectSerializer::toQueryValue($ssid);
        }

        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateDeviceWirelessBluetoothSettings
     *
     * Update the bluetooth settings for a wireless device
     *
     * @param  string $serial serial (required)
     * @param  \Swagger\Client\Model\UpdateDeviceWirelessBluetoothSettings $update_device_wireless_bluetooth_settings update_device_wireless_bluetooth_settings (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateDeviceWirelessBluetoothSettings($serial, $update_device_wireless_bluetooth_settings = null)
    {
        list($response) = $this->updateDeviceWirelessBluetoothSettingsWithHttpInfo($serial, $update_device_wireless_bluetooth_settings);
        return $response;
    }

    /**
     * Operation updateDeviceWirelessBluetoothSettingsWithHttpInfo
     *
     * Update the bluetooth settings for a wireless device
     *
     * @param  string $serial (required)
     * @param  \Swagger\Client\Model\UpdateDeviceWirelessBluetoothSettings $update_device_wireless_bluetooth_settings (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateDeviceWirelessBluetoothSettingsWithHttpInfo($serial, $update_device_wireless_bluetooth_settings = null)
    {
        $returnType = 'object';
        $request = $this->updateDeviceWirelessBluetoothSettingsRequest($serial, $update_device_wireless_bluetooth_settings);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateDeviceWirelessBluetoothSettingsAsync
     *
     * Update the bluetooth settings for a wireless device
     *
     * @param  string $serial (required)
     * @param  \Swagger\Client\Model\UpdateDeviceWirelessBluetoothSettings $update_device_wireless_bluetooth_settings (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDeviceWirelessBluetoothSettingsAsync($serial, $update_device_wireless_bluetooth_settings = null)
    {
        return $this->updateDeviceWirelessBluetoothSettingsAsyncWithHttpInfo($serial, $update_device_wireless_bluetooth_settings)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateDeviceWirelessBluetoothSettingsAsyncWithHttpInfo
     *
     * Update the bluetooth settings for a wireless device
     *
     * @param  string $serial (required)
     * @param  \Swagger\Client\Model\UpdateDeviceWirelessBluetoothSettings $update_device_wireless_bluetooth_settings (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDeviceWirelessBluetoothSettingsAsyncWithHttpInfo($serial, $update_device_wireless_bluetooth_settings = null)
    {
        $returnType = 'object';
        $request = $this->updateDeviceWirelessBluetoothSettingsRequest($serial, $update_device_wireless_bluetooth_settings);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateDeviceWirelessBluetoothSettings'
     *
     * @param  string $serial (required)
     * @param  \Swagger\Client\Model\UpdateDeviceWirelessBluetoothSettings $update_device_wireless_bluetooth_settings (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateDeviceWirelessBluetoothSettingsRequest($serial, $update_device_wireless_bluetooth_settings = null)
    {
        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling updateDeviceWirelessBluetoothSettings'
            );
        }

        $resourcePath = '/devices/{serial}/wireless/bluetooth/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($update_device_wireless_bluetooth_settings)) {
            $_tempBody = $update_device_wireless_bluetooth_settings;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateDeviceWirelessRadioSettings
     *
     * Update the radio settings of a device
     *
     * @param  string $serial serial (required)
     * @param  \Swagger\Client\Model\UpdateDeviceWirelessRadioSettings $update_device_wireless_radio_settings update_device_wireless_radio_settings (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateDeviceWirelessRadioSettings($serial, $update_device_wireless_radio_settings = null)
    {
        list($response) = $this->updateDeviceWirelessRadioSettingsWithHttpInfo($serial, $update_device_wireless_radio_settings);
        return $response;
    }

    /**
     * Operation updateDeviceWirelessRadioSettingsWithHttpInfo
     *
     * Update the radio settings of a device
     *
     * @param  string $serial (required)
     * @param  \Swagger\Client\Model\UpdateDeviceWirelessRadioSettings $update_device_wireless_radio_settings (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateDeviceWirelessRadioSettingsWithHttpInfo($serial, $update_device_wireless_radio_settings = null)
    {
        $returnType = 'object';
        $request = $this->updateDeviceWirelessRadioSettingsRequest($serial, $update_device_wireless_radio_settings);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateDeviceWirelessRadioSettingsAsync
     *
     * Update the radio settings of a device
     *
     * @param  string $serial (required)
     * @param  \Swagger\Client\Model\UpdateDeviceWirelessRadioSettings $update_device_wireless_radio_settings (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDeviceWirelessRadioSettingsAsync($serial, $update_device_wireless_radio_settings = null)
    {
        return $this->updateDeviceWirelessRadioSettingsAsyncWithHttpInfo($serial, $update_device_wireless_radio_settings)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateDeviceWirelessRadioSettingsAsyncWithHttpInfo
     *
     * Update the radio settings of a device
     *
     * @param  string $serial (required)
     * @param  \Swagger\Client\Model\UpdateDeviceWirelessRadioSettings $update_device_wireless_radio_settings (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateDeviceWirelessRadioSettingsAsyncWithHttpInfo($serial, $update_device_wireless_radio_settings = null)
    {
        $returnType = 'object';
        $request = $this->updateDeviceWirelessRadioSettingsRequest($serial, $update_device_wireless_radio_settings);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateDeviceWirelessRadioSettings'
     *
     * @param  string $serial (required)
     * @param  \Swagger\Client\Model\UpdateDeviceWirelessRadioSettings $update_device_wireless_radio_settings (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateDeviceWirelessRadioSettingsRequest($serial, $update_device_wireless_radio_settings = null)
    {
        // verify the required parameter 'serial' is set
        if ($serial === null || (is_array($serial) && count($serial) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serial when calling updateDeviceWirelessRadioSettings'
            );
        }

        $resourcePath = '/devices/{serial}/wireless/radio/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($serial !== null) {
            $resourcePath = str_replace(
                '{' . 'serial' . '}',
                ObjectSerializer::toPathValue($serial),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($update_device_wireless_radio_settings)) {
            $_tempBody = $update_device_wireless_radio_settings;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkWirelessAlternateManagementInterface
     *
     * Update alternate management interface and device static IP
     *
     * @param  string $network_id network_id (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessAlternateManagementInterface $update_network_wireless_alternate_management_interface update_network_wireless_alternate_management_interface (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateNetworkWirelessAlternateManagementInterface($network_id, $update_network_wireless_alternate_management_interface = null)
    {
        list($response) = $this->updateNetworkWirelessAlternateManagementInterfaceWithHttpInfo($network_id, $update_network_wireless_alternate_management_interface);
        return $response;
    }

    /**
     * Operation updateNetworkWirelessAlternateManagementInterfaceWithHttpInfo
     *
     * Update alternate management interface and device static IP
     *
     * @param  string $network_id (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessAlternateManagementInterface $update_network_wireless_alternate_management_interface (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkWirelessAlternateManagementInterfaceWithHttpInfo($network_id, $update_network_wireless_alternate_management_interface = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessAlternateManagementInterfaceRequest($network_id, $update_network_wireless_alternate_management_interface);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkWirelessAlternateManagementInterfaceAsync
     *
     * Update alternate management interface and device static IP
     *
     * @param  string $network_id (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessAlternateManagementInterface $update_network_wireless_alternate_management_interface (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessAlternateManagementInterfaceAsync($network_id, $update_network_wireless_alternate_management_interface = null)
    {
        return $this->updateNetworkWirelessAlternateManagementInterfaceAsyncWithHttpInfo($network_id, $update_network_wireless_alternate_management_interface)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkWirelessAlternateManagementInterfaceAsyncWithHttpInfo
     *
     * Update alternate management interface and device static IP
     *
     * @param  string $network_id (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessAlternateManagementInterface $update_network_wireless_alternate_management_interface (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessAlternateManagementInterfaceAsyncWithHttpInfo($network_id, $update_network_wireless_alternate_management_interface = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessAlternateManagementInterfaceRequest($network_id, $update_network_wireless_alternate_management_interface);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkWirelessAlternateManagementInterface'
     *
     * @param  string $network_id (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessAlternateManagementInterface $update_network_wireless_alternate_management_interface (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateNetworkWirelessAlternateManagementInterfaceRequest($network_id, $update_network_wireless_alternate_management_interface = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkWirelessAlternateManagementInterface'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/alternateManagementInterface';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($update_network_wireless_alternate_management_interface)) {
            $_tempBody = $update_network_wireless_alternate_management_interface;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkWirelessBilling
     *
     * Update the billing settings
     *
     * @param  string $network_id network_id (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessBilling $update_network_wireless_billing update_network_wireless_billing (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateNetworkWirelessBilling($network_id, $update_network_wireless_billing = null)
    {
        list($response) = $this->updateNetworkWirelessBillingWithHttpInfo($network_id, $update_network_wireless_billing);
        return $response;
    }

    /**
     * Operation updateNetworkWirelessBillingWithHttpInfo
     *
     * Update the billing settings
     *
     * @param  string $network_id (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessBilling $update_network_wireless_billing (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkWirelessBillingWithHttpInfo($network_id, $update_network_wireless_billing = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessBillingRequest($network_id, $update_network_wireless_billing);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkWirelessBillingAsync
     *
     * Update the billing settings
     *
     * @param  string $network_id (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessBilling $update_network_wireless_billing (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessBillingAsync($network_id, $update_network_wireless_billing = null)
    {
        return $this->updateNetworkWirelessBillingAsyncWithHttpInfo($network_id, $update_network_wireless_billing)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkWirelessBillingAsyncWithHttpInfo
     *
     * Update the billing settings
     *
     * @param  string $network_id (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessBilling $update_network_wireless_billing (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessBillingAsyncWithHttpInfo($network_id, $update_network_wireless_billing = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessBillingRequest($network_id, $update_network_wireless_billing);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkWirelessBilling'
     *
     * @param  string $network_id (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessBilling $update_network_wireless_billing (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateNetworkWirelessBillingRequest($network_id, $update_network_wireless_billing = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkWirelessBilling'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/billing';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($update_network_wireless_billing)) {
            $_tempBody = $update_network_wireless_billing;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkWirelessBluetoothSettings
     *
     * Update the Bluetooth settings for a network
     *
     * @param  string $network_id network_id (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessBluetoothSettings $update_network_wireless_bluetooth_settings update_network_wireless_bluetooth_settings (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateNetworkWirelessBluetoothSettings($network_id, $update_network_wireless_bluetooth_settings = null)
    {
        list($response) = $this->updateNetworkWirelessBluetoothSettingsWithHttpInfo($network_id, $update_network_wireless_bluetooth_settings);
        return $response;
    }

    /**
     * Operation updateNetworkWirelessBluetoothSettingsWithHttpInfo
     *
     * Update the Bluetooth settings for a network
     *
     * @param  string $network_id (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessBluetoothSettings $update_network_wireless_bluetooth_settings (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkWirelessBluetoothSettingsWithHttpInfo($network_id, $update_network_wireless_bluetooth_settings = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessBluetoothSettingsRequest($network_id, $update_network_wireless_bluetooth_settings);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkWirelessBluetoothSettingsAsync
     *
     * Update the Bluetooth settings for a network
     *
     * @param  string $network_id (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessBluetoothSettings $update_network_wireless_bluetooth_settings (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessBluetoothSettingsAsync($network_id, $update_network_wireless_bluetooth_settings = null)
    {
        return $this->updateNetworkWirelessBluetoothSettingsAsyncWithHttpInfo($network_id, $update_network_wireless_bluetooth_settings)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkWirelessBluetoothSettingsAsyncWithHttpInfo
     *
     * Update the Bluetooth settings for a network
     *
     * @param  string $network_id (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessBluetoothSettings $update_network_wireless_bluetooth_settings (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessBluetoothSettingsAsyncWithHttpInfo($network_id, $update_network_wireless_bluetooth_settings = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessBluetoothSettingsRequest($network_id, $update_network_wireless_bluetooth_settings);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkWirelessBluetoothSettings'
     *
     * @param  string $network_id (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessBluetoothSettings $update_network_wireless_bluetooth_settings (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateNetworkWirelessBluetoothSettingsRequest($network_id, $update_network_wireless_bluetooth_settings = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkWirelessBluetoothSettings'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/bluetooth/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($update_network_wireless_bluetooth_settings)) {
            $_tempBody = $update_network_wireless_bluetooth_settings;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkWirelessRfProfile
     *
     * Updates specified RF profile for this network
     *
     * @param  string $network_id network_id (required)
     * @param  string $rf_profile_id rf_profile_id (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessRfProfile $update_network_wireless_rf_profile update_network_wireless_rf_profile (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateNetworkWirelessRfProfile($network_id, $rf_profile_id, $update_network_wireless_rf_profile = null)
    {
        list($response) = $this->updateNetworkWirelessRfProfileWithHttpInfo($network_id, $rf_profile_id, $update_network_wireless_rf_profile);
        return $response;
    }

    /**
     * Operation updateNetworkWirelessRfProfileWithHttpInfo
     *
     * Updates specified RF profile for this network
     *
     * @param  string $network_id (required)
     * @param  string $rf_profile_id (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessRfProfile $update_network_wireless_rf_profile (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkWirelessRfProfileWithHttpInfo($network_id, $rf_profile_id, $update_network_wireless_rf_profile = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessRfProfileRequest($network_id, $rf_profile_id, $update_network_wireless_rf_profile);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkWirelessRfProfileAsync
     *
     * Updates specified RF profile for this network
     *
     * @param  string $network_id (required)
     * @param  string $rf_profile_id (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessRfProfile $update_network_wireless_rf_profile (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessRfProfileAsync($network_id, $rf_profile_id, $update_network_wireless_rf_profile = null)
    {
        return $this->updateNetworkWirelessRfProfileAsyncWithHttpInfo($network_id, $rf_profile_id, $update_network_wireless_rf_profile)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkWirelessRfProfileAsyncWithHttpInfo
     *
     * Updates specified RF profile for this network
     *
     * @param  string $network_id (required)
     * @param  string $rf_profile_id (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessRfProfile $update_network_wireless_rf_profile (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessRfProfileAsyncWithHttpInfo($network_id, $rf_profile_id, $update_network_wireless_rf_profile = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessRfProfileRequest($network_id, $rf_profile_id, $update_network_wireless_rf_profile);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkWirelessRfProfile'
     *
     * @param  string $network_id (required)
     * @param  string $rf_profile_id (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessRfProfile $update_network_wireless_rf_profile (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateNetworkWirelessRfProfileRequest($network_id, $rf_profile_id, $update_network_wireless_rf_profile = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkWirelessRfProfile'
            );
        }
        // verify the required parameter 'rf_profile_id' is set
        if ($rf_profile_id === null || (is_array($rf_profile_id) && count($rf_profile_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $rf_profile_id when calling updateNetworkWirelessRfProfile'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/rfProfiles/{rfProfileId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($rf_profile_id !== null) {
            $resourcePath = str_replace(
                '{' . 'rfProfileId' . '}',
                ObjectSerializer::toPathValue($rf_profile_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($update_network_wireless_rf_profile)) {
            $_tempBody = $update_network_wireless_rf_profile;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkWirelessSettings
     *
     * Update the wireless settings for a network
     *
     * @param  string $network_id network_id (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSettings $update_network_wireless_settings update_network_wireless_settings (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateNetworkWirelessSettings($network_id, $update_network_wireless_settings = null)
    {
        list($response) = $this->updateNetworkWirelessSettingsWithHttpInfo($network_id, $update_network_wireless_settings);
        return $response;
    }

    /**
     * Operation updateNetworkWirelessSettingsWithHttpInfo
     *
     * Update the wireless settings for a network
     *
     * @param  string $network_id (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSettings $update_network_wireless_settings (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkWirelessSettingsWithHttpInfo($network_id, $update_network_wireless_settings = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessSettingsRequest($network_id, $update_network_wireless_settings);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkWirelessSettingsAsync
     *
     * Update the wireless settings for a network
     *
     * @param  string $network_id (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSettings $update_network_wireless_settings (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessSettingsAsync($network_id, $update_network_wireless_settings = null)
    {
        return $this->updateNetworkWirelessSettingsAsyncWithHttpInfo($network_id, $update_network_wireless_settings)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkWirelessSettingsAsyncWithHttpInfo
     *
     * Update the wireless settings for a network
     *
     * @param  string $network_id (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSettings $update_network_wireless_settings (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessSettingsAsyncWithHttpInfo($network_id, $update_network_wireless_settings = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessSettingsRequest($network_id, $update_network_wireless_settings);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkWirelessSettings'
     *
     * @param  string $network_id (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSettings $update_network_wireless_settings (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateNetworkWirelessSettingsRequest($network_id, $update_network_wireless_settings = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkWirelessSettings'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($update_network_wireless_settings)) {
            $_tempBody = $update_network_wireless_settings;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkWirelessSsid
     *
     * Update the attributes of an MR SSID
     *
     * @param  string $network_id network_id (required)
     * @param  string $number number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsid $update_network_wireless_ssid update_network_wireless_ssid (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateNetworkWirelessSsid($network_id, $number, $update_network_wireless_ssid = null)
    {
        list($response) = $this->updateNetworkWirelessSsidWithHttpInfo($network_id, $number, $update_network_wireless_ssid);
        return $response;
    }

    /**
     * Operation updateNetworkWirelessSsidWithHttpInfo
     *
     * Update the attributes of an MR SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsid $update_network_wireless_ssid (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkWirelessSsidWithHttpInfo($network_id, $number, $update_network_wireless_ssid = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessSsidRequest($network_id, $number, $update_network_wireless_ssid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkWirelessSsidAsync
     *
     * Update the attributes of an MR SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsid $update_network_wireless_ssid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessSsidAsync($network_id, $number, $update_network_wireless_ssid = null)
    {
        return $this->updateNetworkWirelessSsidAsyncWithHttpInfo($network_id, $number, $update_network_wireless_ssid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkWirelessSsidAsyncWithHttpInfo
     *
     * Update the attributes of an MR SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsid $update_network_wireless_ssid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessSsidAsyncWithHttpInfo($network_id, $number, $update_network_wireless_ssid = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessSsidRequest($network_id, $number, $update_network_wireless_ssid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkWirelessSsid'
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsid $update_network_wireless_ssid (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateNetworkWirelessSsidRequest($network_id, $number, $update_network_wireless_ssid = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkWirelessSsid'
            );
        }
        // verify the required parameter 'number' is set
        if ($number === null || (is_array($number) && count($number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling updateNetworkWirelessSsid'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/ssids/{number}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($number !== null) {
            $resourcePath = str_replace(
                '{' . 'number' . '}',
                ObjectSerializer::toPathValue($number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($update_network_wireless_ssid)) {
            $_tempBody = $update_network_wireless_ssid;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkWirelessSsidBonjourForwarding
     *
     * Update the bonjour forwarding setting and rules for the SSID
     *
     * @param  string $network_id network_id (required)
     * @param  string $number number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidBonjourForwarding $update_network_wireless_ssid_bonjour_forwarding update_network_wireless_ssid_bonjour_forwarding (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateNetworkWirelessSsidBonjourForwarding($network_id, $number, $update_network_wireless_ssid_bonjour_forwarding = null)
    {
        list($response) = $this->updateNetworkWirelessSsidBonjourForwardingWithHttpInfo($network_id, $number, $update_network_wireless_ssid_bonjour_forwarding);
        return $response;
    }

    /**
     * Operation updateNetworkWirelessSsidBonjourForwardingWithHttpInfo
     *
     * Update the bonjour forwarding setting and rules for the SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidBonjourForwarding $update_network_wireless_ssid_bonjour_forwarding (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkWirelessSsidBonjourForwardingWithHttpInfo($network_id, $number, $update_network_wireless_ssid_bonjour_forwarding = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessSsidBonjourForwardingRequest($network_id, $number, $update_network_wireless_ssid_bonjour_forwarding);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkWirelessSsidBonjourForwardingAsync
     *
     * Update the bonjour forwarding setting and rules for the SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidBonjourForwarding $update_network_wireless_ssid_bonjour_forwarding (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessSsidBonjourForwardingAsync($network_id, $number, $update_network_wireless_ssid_bonjour_forwarding = null)
    {
        return $this->updateNetworkWirelessSsidBonjourForwardingAsyncWithHttpInfo($network_id, $number, $update_network_wireless_ssid_bonjour_forwarding)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkWirelessSsidBonjourForwardingAsyncWithHttpInfo
     *
     * Update the bonjour forwarding setting and rules for the SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidBonjourForwarding $update_network_wireless_ssid_bonjour_forwarding (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessSsidBonjourForwardingAsyncWithHttpInfo($network_id, $number, $update_network_wireless_ssid_bonjour_forwarding = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessSsidBonjourForwardingRequest($network_id, $number, $update_network_wireless_ssid_bonjour_forwarding);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkWirelessSsidBonjourForwarding'
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidBonjourForwarding $update_network_wireless_ssid_bonjour_forwarding (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateNetworkWirelessSsidBonjourForwardingRequest($network_id, $number, $update_network_wireless_ssid_bonjour_forwarding = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkWirelessSsidBonjourForwarding'
            );
        }
        // verify the required parameter 'number' is set
        if ($number === null || (is_array($number) && count($number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling updateNetworkWirelessSsidBonjourForwarding'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/ssids/{number}/bonjourForwarding';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($number !== null) {
            $resourcePath = str_replace(
                '{' . 'number' . '}',
                ObjectSerializer::toPathValue($number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($update_network_wireless_ssid_bonjour_forwarding)) {
            $_tempBody = $update_network_wireless_ssid_bonjour_forwarding;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkWirelessSsidDeviceTypeGroupPolicies
     *
     * Update the device type group policies for the SSID
     *
     * @param  string $network_id network_id (required)
     * @param  string $number number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidDeviceTypeGroupPolicies $update_network_wireless_ssid_device_type_group_policies update_network_wireless_ssid_device_type_group_policies (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateNetworkWirelessSsidDeviceTypeGroupPolicies($network_id, $number, $update_network_wireless_ssid_device_type_group_policies = null)
    {
        list($response) = $this->updateNetworkWirelessSsidDeviceTypeGroupPoliciesWithHttpInfo($network_id, $number, $update_network_wireless_ssid_device_type_group_policies);
        return $response;
    }

    /**
     * Operation updateNetworkWirelessSsidDeviceTypeGroupPoliciesWithHttpInfo
     *
     * Update the device type group policies for the SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidDeviceTypeGroupPolicies $update_network_wireless_ssid_device_type_group_policies (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkWirelessSsidDeviceTypeGroupPoliciesWithHttpInfo($network_id, $number, $update_network_wireless_ssid_device_type_group_policies = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessSsidDeviceTypeGroupPoliciesRequest($network_id, $number, $update_network_wireless_ssid_device_type_group_policies);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkWirelessSsidDeviceTypeGroupPoliciesAsync
     *
     * Update the device type group policies for the SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidDeviceTypeGroupPolicies $update_network_wireless_ssid_device_type_group_policies (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessSsidDeviceTypeGroupPoliciesAsync($network_id, $number, $update_network_wireless_ssid_device_type_group_policies = null)
    {
        return $this->updateNetworkWirelessSsidDeviceTypeGroupPoliciesAsyncWithHttpInfo($network_id, $number, $update_network_wireless_ssid_device_type_group_policies)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkWirelessSsidDeviceTypeGroupPoliciesAsyncWithHttpInfo
     *
     * Update the device type group policies for the SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidDeviceTypeGroupPolicies $update_network_wireless_ssid_device_type_group_policies (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessSsidDeviceTypeGroupPoliciesAsyncWithHttpInfo($network_id, $number, $update_network_wireless_ssid_device_type_group_policies = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessSsidDeviceTypeGroupPoliciesRequest($network_id, $number, $update_network_wireless_ssid_device_type_group_policies);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkWirelessSsidDeviceTypeGroupPolicies'
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidDeviceTypeGroupPolicies $update_network_wireless_ssid_device_type_group_policies (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateNetworkWirelessSsidDeviceTypeGroupPoliciesRequest($network_id, $number, $update_network_wireless_ssid_device_type_group_policies = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkWirelessSsidDeviceTypeGroupPolicies'
            );
        }
        // verify the required parameter 'number' is set
        if ($number === null || (is_array($number) && count($number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling updateNetworkWirelessSsidDeviceTypeGroupPolicies'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/ssids/{number}/deviceTypeGroupPolicies';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($number !== null) {
            $resourcePath = str_replace(
                '{' . 'number' . '}',
                ObjectSerializer::toPathValue($number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($update_network_wireless_ssid_device_type_group_policies)) {
            $_tempBody = $update_network_wireless_ssid_device_type_group_policies;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkWirelessSsidEapOverride
     *
     * Update the EAP overridden parameters for an SSID.
     *
     * @param  string $network_id network_id (required)
     * @param  string $number number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidEapOverride $update_network_wireless_ssid_eap_override update_network_wireless_ssid_eap_override (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateNetworkWirelessSsidEapOverride($network_id, $number, $update_network_wireless_ssid_eap_override = null)
    {
        list($response) = $this->updateNetworkWirelessSsidEapOverrideWithHttpInfo($network_id, $number, $update_network_wireless_ssid_eap_override);
        return $response;
    }

    /**
     * Operation updateNetworkWirelessSsidEapOverrideWithHttpInfo
     *
     * Update the EAP overridden parameters for an SSID.
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidEapOverride $update_network_wireless_ssid_eap_override (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkWirelessSsidEapOverrideWithHttpInfo($network_id, $number, $update_network_wireless_ssid_eap_override = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessSsidEapOverrideRequest($network_id, $number, $update_network_wireless_ssid_eap_override);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkWirelessSsidEapOverrideAsync
     *
     * Update the EAP overridden parameters for an SSID.
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidEapOverride $update_network_wireless_ssid_eap_override (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessSsidEapOverrideAsync($network_id, $number, $update_network_wireless_ssid_eap_override = null)
    {
        return $this->updateNetworkWirelessSsidEapOverrideAsyncWithHttpInfo($network_id, $number, $update_network_wireless_ssid_eap_override)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkWirelessSsidEapOverrideAsyncWithHttpInfo
     *
     * Update the EAP overridden parameters for an SSID.
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidEapOverride $update_network_wireless_ssid_eap_override (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessSsidEapOverrideAsyncWithHttpInfo($network_id, $number, $update_network_wireless_ssid_eap_override = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessSsidEapOverrideRequest($network_id, $number, $update_network_wireless_ssid_eap_override);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkWirelessSsidEapOverride'
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidEapOverride $update_network_wireless_ssid_eap_override (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateNetworkWirelessSsidEapOverrideRequest($network_id, $number, $update_network_wireless_ssid_eap_override = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkWirelessSsidEapOverride'
            );
        }
        // verify the required parameter 'number' is set
        if ($number === null || (is_array($number) && count($number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling updateNetworkWirelessSsidEapOverride'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/ssids/{number}/eapOverride';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($number !== null) {
            $resourcePath = str_replace(
                '{' . 'number' . '}',
                ObjectSerializer::toPathValue($number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($update_network_wireless_ssid_eap_override)) {
            $_tempBody = $update_network_wireless_ssid_eap_override;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkWirelessSsidFirewallL3FirewallRules
     *
     * Update the L3 firewall rules of an SSID on an MR network
     *
     * @param  string $network_id network_id (required)
     * @param  string $number number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidFirewallL3FirewallRules $update_network_wireless_ssid_firewall_l3_firewall_rules update_network_wireless_ssid_firewall_l3_firewall_rules (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateNetworkWirelessSsidFirewallL3FirewallRules($network_id, $number, $update_network_wireless_ssid_firewall_l3_firewall_rules = null)
    {
        list($response) = $this->updateNetworkWirelessSsidFirewallL3FirewallRulesWithHttpInfo($network_id, $number, $update_network_wireless_ssid_firewall_l3_firewall_rules);
        return $response;
    }

    /**
     * Operation updateNetworkWirelessSsidFirewallL3FirewallRulesWithHttpInfo
     *
     * Update the L3 firewall rules of an SSID on an MR network
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidFirewallL3FirewallRules $update_network_wireless_ssid_firewall_l3_firewall_rules (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkWirelessSsidFirewallL3FirewallRulesWithHttpInfo($network_id, $number, $update_network_wireless_ssid_firewall_l3_firewall_rules = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessSsidFirewallL3FirewallRulesRequest($network_id, $number, $update_network_wireless_ssid_firewall_l3_firewall_rules);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkWirelessSsidFirewallL3FirewallRulesAsync
     *
     * Update the L3 firewall rules of an SSID on an MR network
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidFirewallL3FirewallRules $update_network_wireless_ssid_firewall_l3_firewall_rules (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessSsidFirewallL3FirewallRulesAsync($network_id, $number, $update_network_wireless_ssid_firewall_l3_firewall_rules = null)
    {
        return $this->updateNetworkWirelessSsidFirewallL3FirewallRulesAsyncWithHttpInfo($network_id, $number, $update_network_wireless_ssid_firewall_l3_firewall_rules)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkWirelessSsidFirewallL3FirewallRulesAsyncWithHttpInfo
     *
     * Update the L3 firewall rules of an SSID on an MR network
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidFirewallL3FirewallRules $update_network_wireless_ssid_firewall_l3_firewall_rules (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessSsidFirewallL3FirewallRulesAsyncWithHttpInfo($network_id, $number, $update_network_wireless_ssid_firewall_l3_firewall_rules = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessSsidFirewallL3FirewallRulesRequest($network_id, $number, $update_network_wireless_ssid_firewall_l3_firewall_rules);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkWirelessSsidFirewallL3FirewallRules'
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidFirewallL3FirewallRules $update_network_wireless_ssid_firewall_l3_firewall_rules (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateNetworkWirelessSsidFirewallL3FirewallRulesRequest($network_id, $number, $update_network_wireless_ssid_firewall_l3_firewall_rules = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkWirelessSsidFirewallL3FirewallRules'
            );
        }
        // verify the required parameter 'number' is set
        if ($number === null || (is_array($number) && count($number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling updateNetworkWirelessSsidFirewallL3FirewallRules'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/ssids/{number}/firewall/l3FirewallRules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($number !== null) {
            $resourcePath = str_replace(
                '{' . 'number' . '}',
                ObjectSerializer::toPathValue($number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($update_network_wireless_ssid_firewall_l3_firewall_rules)) {
            $_tempBody = $update_network_wireless_ssid_firewall_l3_firewall_rules;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkWirelessSsidFirewallL7FirewallRules
     *
     * Update the L7 firewall rules of an SSID on an MR network
     *
     * @param  string $network_id network_id (required)
     * @param  string $number number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidFirewallL7FirewallRules $update_network_wireless_ssid_firewall_l7_firewall_rules update_network_wireless_ssid_firewall_l7_firewall_rules (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateNetworkWirelessSsidFirewallL7FirewallRules($network_id, $number, $update_network_wireless_ssid_firewall_l7_firewall_rules = null)
    {
        list($response) = $this->updateNetworkWirelessSsidFirewallL7FirewallRulesWithHttpInfo($network_id, $number, $update_network_wireless_ssid_firewall_l7_firewall_rules);
        return $response;
    }

    /**
     * Operation updateNetworkWirelessSsidFirewallL7FirewallRulesWithHttpInfo
     *
     * Update the L7 firewall rules of an SSID on an MR network
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidFirewallL7FirewallRules $update_network_wireless_ssid_firewall_l7_firewall_rules (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkWirelessSsidFirewallL7FirewallRulesWithHttpInfo($network_id, $number, $update_network_wireless_ssid_firewall_l7_firewall_rules = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessSsidFirewallL7FirewallRulesRequest($network_id, $number, $update_network_wireless_ssid_firewall_l7_firewall_rules);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkWirelessSsidFirewallL7FirewallRulesAsync
     *
     * Update the L7 firewall rules of an SSID on an MR network
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidFirewallL7FirewallRules $update_network_wireless_ssid_firewall_l7_firewall_rules (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessSsidFirewallL7FirewallRulesAsync($network_id, $number, $update_network_wireless_ssid_firewall_l7_firewall_rules = null)
    {
        return $this->updateNetworkWirelessSsidFirewallL7FirewallRulesAsyncWithHttpInfo($network_id, $number, $update_network_wireless_ssid_firewall_l7_firewall_rules)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkWirelessSsidFirewallL7FirewallRulesAsyncWithHttpInfo
     *
     * Update the L7 firewall rules of an SSID on an MR network
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidFirewallL7FirewallRules $update_network_wireless_ssid_firewall_l7_firewall_rules (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessSsidFirewallL7FirewallRulesAsyncWithHttpInfo($network_id, $number, $update_network_wireless_ssid_firewall_l7_firewall_rules = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessSsidFirewallL7FirewallRulesRequest($network_id, $number, $update_network_wireless_ssid_firewall_l7_firewall_rules);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkWirelessSsidFirewallL7FirewallRules'
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidFirewallL7FirewallRules $update_network_wireless_ssid_firewall_l7_firewall_rules (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateNetworkWirelessSsidFirewallL7FirewallRulesRequest($network_id, $number, $update_network_wireless_ssid_firewall_l7_firewall_rules = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkWirelessSsidFirewallL7FirewallRules'
            );
        }
        // verify the required parameter 'number' is set
        if ($number === null || (is_array($number) && count($number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling updateNetworkWirelessSsidFirewallL7FirewallRules'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/ssids/{number}/firewall/l7FirewallRules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($number !== null) {
            $resourcePath = str_replace(
                '{' . 'number' . '}',
                ObjectSerializer::toPathValue($number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($update_network_wireless_ssid_firewall_l7_firewall_rules)) {
            $_tempBody = $update_network_wireless_ssid_firewall_l7_firewall_rules;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkWirelessSsidHotspot20
     *
     * Update the Hotspot 2.0 settings of an SSID
     *
     * @param  string $network_id network_id (required)
     * @param  string $number number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidHotspot20 $update_network_wireless_ssid_hotspot20 update_network_wireless_ssid_hotspot20 (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateNetworkWirelessSsidHotspot20($network_id, $number, $update_network_wireless_ssid_hotspot20 = null)
    {
        list($response) = $this->updateNetworkWirelessSsidHotspot20WithHttpInfo($network_id, $number, $update_network_wireless_ssid_hotspot20);
        return $response;
    }

    /**
     * Operation updateNetworkWirelessSsidHotspot20WithHttpInfo
     *
     * Update the Hotspot 2.0 settings of an SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidHotspot20 $update_network_wireless_ssid_hotspot20 (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkWirelessSsidHotspot20WithHttpInfo($network_id, $number, $update_network_wireless_ssid_hotspot20 = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessSsidHotspot20Request($network_id, $number, $update_network_wireless_ssid_hotspot20);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkWirelessSsidHotspot20Async
     *
     * Update the Hotspot 2.0 settings of an SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidHotspot20 $update_network_wireless_ssid_hotspot20 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessSsidHotspot20Async($network_id, $number, $update_network_wireless_ssid_hotspot20 = null)
    {
        return $this->updateNetworkWirelessSsidHotspot20AsyncWithHttpInfo($network_id, $number, $update_network_wireless_ssid_hotspot20)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkWirelessSsidHotspot20AsyncWithHttpInfo
     *
     * Update the Hotspot 2.0 settings of an SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidHotspot20 $update_network_wireless_ssid_hotspot20 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessSsidHotspot20AsyncWithHttpInfo($network_id, $number, $update_network_wireless_ssid_hotspot20 = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessSsidHotspot20Request($network_id, $number, $update_network_wireless_ssid_hotspot20);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkWirelessSsidHotspot20'
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidHotspot20 $update_network_wireless_ssid_hotspot20 (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateNetworkWirelessSsidHotspot20Request($network_id, $number, $update_network_wireless_ssid_hotspot20 = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkWirelessSsidHotspot20'
            );
        }
        // verify the required parameter 'number' is set
        if ($number === null || (is_array($number) && count($number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling updateNetworkWirelessSsidHotspot20'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/ssids/{number}/hotspot20';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($number !== null) {
            $resourcePath = str_replace(
                '{' . 'number' . '}',
                ObjectSerializer::toPathValue($number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($update_network_wireless_ssid_hotspot20)) {
            $_tempBody = $update_network_wireless_ssid_hotspot20;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkWirelessSsidIdentityPsk
     *
     * Update an Identity PSK
     *
     * @param  string $network_id network_id (required)
     * @param  string $number number (required)
     * @param  string $identity_psk_id identity_psk_id (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidIdentityPsk $update_network_wireless_ssid_identity_psk update_network_wireless_ssid_identity_psk (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateNetworkWirelessSsidIdentityPsk($network_id, $number, $identity_psk_id, $update_network_wireless_ssid_identity_psk = null)
    {
        list($response) = $this->updateNetworkWirelessSsidIdentityPskWithHttpInfo($network_id, $number, $identity_psk_id, $update_network_wireless_ssid_identity_psk);
        return $response;
    }

    /**
     * Operation updateNetworkWirelessSsidIdentityPskWithHttpInfo
     *
     * Update an Identity PSK
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  string $identity_psk_id (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidIdentityPsk $update_network_wireless_ssid_identity_psk (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkWirelessSsidIdentityPskWithHttpInfo($network_id, $number, $identity_psk_id, $update_network_wireless_ssid_identity_psk = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessSsidIdentityPskRequest($network_id, $number, $identity_psk_id, $update_network_wireless_ssid_identity_psk);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkWirelessSsidIdentityPskAsync
     *
     * Update an Identity PSK
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  string $identity_psk_id (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidIdentityPsk $update_network_wireless_ssid_identity_psk (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessSsidIdentityPskAsync($network_id, $number, $identity_psk_id, $update_network_wireless_ssid_identity_psk = null)
    {
        return $this->updateNetworkWirelessSsidIdentityPskAsyncWithHttpInfo($network_id, $number, $identity_psk_id, $update_network_wireless_ssid_identity_psk)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkWirelessSsidIdentityPskAsyncWithHttpInfo
     *
     * Update an Identity PSK
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  string $identity_psk_id (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidIdentityPsk $update_network_wireless_ssid_identity_psk (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessSsidIdentityPskAsyncWithHttpInfo($network_id, $number, $identity_psk_id, $update_network_wireless_ssid_identity_psk = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessSsidIdentityPskRequest($network_id, $number, $identity_psk_id, $update_network_wireless_ssid_identity_psk);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkWirelessSsidIdentityPsk'
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  string $identity_psk_id (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidIdentityPsk $update_network_wireless_ssid_identity_psk (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateNetworkWirelessSsidIdentityPskRequest($network_id, $number, $identity_psk_id, $update_network_wireless_ssid_identity_psk = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkWirelessSsidIdentityPsk'
            );
        }
        // verify the required parameter 'number' is set
        if ($number === null || (is_array($number) && count($number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling updateNetworkWirelessSsidIdentityPsk'
            );
        }
        // verify the required parameter 'identity_psk_id' is set
        if ($identity_psk_id === null || (is_array($identity_psk_id) && count($identity_psk_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $identity_psk_id when calling updateNetworkWirelessSsidIdentityPsk'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/ssids/{number}/identityPsks/{identityPskId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($number !== null) {
            $resourcePath = str_replace(
                '{' . 'number' . '}',
                ObjectSerializer::toPathValue($number),
                $resourcePath
            );
        }
        // path params
        if ($identity_psk_id !== null) {
            $resourcePath = str_replace(
                '{' . 'identityPskId' . '}',
                ObjectSerializer::toPathValue($identity_psk_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($update_network_wireless_ssid_identity_psk)) {
            $_tempBody = $update_network_wireless_ssid_identity_psk;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkWirelessSsidSchedules
     *
     * Update the outage schedule for the SSID
     *
     * @param  string $network_id network_id (required)
     * @param  string $number number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidSchedules $update_network_wireless_ssid_schedules update_network_wireless_ssid_schedules (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateNetworkWirelessSsidSchedules($network_id, $number, $update_network_wireless_ssid_schedules = null)
    {
        list($response) = $this->updateNetworkWirelessSsidSchedulesWithHttpInfo($network_id, $number, $update_network_wireless_ssid_schedules);
        return $response;
    }

    /**
     * Operation updateNetworkWirelessSsidSchedulesWithHttpInfo
     *
     * Update the outage schedule for the SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidSchedules $update_network_wireless_ssid_schedules (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkWirelessSsidSchedulesWithHttpInfo($network_id, $number, $update_network_wireless_ssid_schedules = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessSsidSchedulesRequest($network_id, $number, $update_network_wireless_ssid_schedules);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkWirelessSsidSchedulesAsync
     *
     * Update the outage schedule for the SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidSchedules $update_network_wireless_ssid_schedules (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessSsidSchedulesAsync($network_id, $number, $update_network_wireless_ssid_schedules = null)
    {
        return $this->updateNetworkWirelessSsidSchedulesAsyncWithHttpInfo($network_id, $number, $update_network_wireless_ssid_schedules)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkWirelessSsidSchedulesAsyncWithHttpInfo
     *
     * Update the outage schedule for the SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidSchedules $update_network_wireless_ssid_schedules (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessSsidSchedulesAsyncWithHttpInfo($network_id, $number, $update_network_wireless_ssid_schedules = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessSsidSchedulesRequest($network_id, $number, $update_network_wireless_ssid_schedules);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkWirelessSsidSchedules'
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidSchedules $update_network_wireless_ssid_schedules (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateNetworkWirelessSsidSchedulesRequest($network_id, $number, $update_network_wireless_ssid_schedules = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkWirelessSsidSchedules'
            );
        }
        // verify the required parameter 'number' is set
        if ($number === null || (is_array($number) && count($number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling updateNetworkWirelessSsidSchedules'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/ssids/{number}/schedules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($number !== null) {
            $resourcePath = str_replace(
                '{' . 'number' . '}',
                ObjectSerializer::toPathValue($number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($update_network_wireless_ssid_schedules)) {
            $_tempBody = $update_network_wireless_ssid_schedules;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkWirelessSsidSplashSettings
     *
     * Modify the splash page settings for the given SSID
     *
     * @param  string $network_id network_id (required)
     * @param  string $number number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidSplashSettings $update_network_wireless_ssid_splash_settings update_network_wireless_ssid_splash_settings (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateNetworkWirelessSsidSplashSettings($network_id, $number, $update_network_wireless_ssid_splash_settings = null)
    {
        list($response) = $this->updateNetworkWirelessSsidSplashSettingsWithHttpInfo($network_id, $number, $update_network_wireless_ssid_splash_settings);
        return $response;
    }

    /**
     * Operation updateNetworkWirelessSsidSplashSettingsWithHttpInfo
     *
     * Modify the splash page settings for the given SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidSplashSettings $update_network_wireless_ssid_splash_settings (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkWirelessSsidSplashSettingsWithHttpInfo($network_id, $number, $update_network_wireless_ssid_splash_settings = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessSsidSplashSettingsRequest($network_id, $number, $update_network_wireless_ssid_splash_settings);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkWirelessSsidSplashSettingsAsync
     *
     * Modify the splash page settings for the given SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidSplashSettings $update_network_wireless_ssid_splash_settings (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessSsidSplashSettingsAsync($network_id, $number, $update_network_wireless_ssid_splash_settings = null)
    {
        return $this->updateNetworkWirelessSsidSplashSettingsAsyncWithHttpInfo($network_id, $number, $update_network_wireless_ssid_splash_settings)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkWirelessSsidSplashSettingsAsyncWithHttpInfo
     *
     * Modify the splash page settings for the given SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidSplashSettings $update_network_wireless_ssid_splash_settings (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessSsidSplashSettingsAsyncWithHttpInfo($network_id, $number, $update_network_wireless_ssid_splash_settings = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessSsidSplashSettingsRequest($network_id, $number, $update_network_wireless_ssid_splash_settings);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkWirelessSsidSplashSettings'
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidSplashSettings $update_network_wireless_ssid_splash_settings (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateNetworkWirelessSsidSplashSettingsRequest($network_id, $number, $update_network_wireless_ssid_splash_settings = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkWirelessSsidSplashSettings'
            );
        }
        // verify the required parameter 'number' is set
        if ($number === null || (is_array($number) && count($number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling updateNetworkWirelessSsidSplashSettings'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/ssids/{number}/splash/settings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($number !== null) {
            $resourcePath = str_replace(
                '{' . 'number' . '}',
                ObjectSerializer::toPathValue($number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($update_network_wireless_ssid_splash_settings)) {
            $_tempBody = $update_network_wireless_ssid_splash_settings;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkWirelessSsidTrafficShapingRules
     *
     * Update the traffic shaping settings for an SSID on an MR network
     *
     * @param  string $network_id network_id (required)
     * @param  string $number number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidTrafficShapingRules $update_network_wireless_ssid_traffic_shaping_rules update_network_wireless_ssid_traffic_shaping_rules (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateNetworkWirelessSsidTrafficShapingRules($network_id, $number, $update_network_wireless_ssid_traffic_shaping_rules = null)
    {
        list($response) = $this->updateNetworkWirelessSsidTrafficShapingRulesWithHttpInfo($network_id, $number, $update_network_wireless_ssid_traffic_shaping_rules);
        return $response;
    }

    /**
     * Operation updateNetworkWirelessSsidTrafficShapingRulesWithHttpInfo
     *
     * Update the traffic shaping settings for an SSID on an MR network
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidTrafficShapingRules $update_network_wireless_ssid_traffic_shaping_rules (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkWirelessSsidTrafficShapingRulesWithHttpInfo($network_id, $number, $update_network_wireless_ssid_traffic_shaping_rules = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessSsidTrafficShapingRulesRequest($network_id, $number, $update_network_wireless_ssid_traffic_shaping_rules);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkWirelessSsidTrafficShapingRulesAsync
     *
     * Update the traffic shaping settings for an SSID on an MR network
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidTrafficShapingRules $update_network_wireless_ssid_traffic_shaping_rules (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessSsidTrafficShapingRulesAsync($network_id, $number, $update_network_wireless_ssid_traffic_shaping_rules = null)
    {
        return $this->updateNetworkWirelessSsidTrafficShapingRulesAsyncWithHttpInfo($network_id, $number, $update_network_wireless_ssid_traffic_shaping_rules)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkWirelessSsidTrafficShapingRulesAsyncWithHttpInfo
     *
     * Update the traffic shaping settings for an SSID on an MR network
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidTrafficShapingRules $update_network_wireless_ssid_traffic_shaping_rules (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessSsidTrafficShapingRulesAsyncWithHttpInfo($network_id, $number, $update_network_wireless_ssid_traffic_shaping_rules = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessSsidTrafficShapingRulesRequest($network_id, $number, $update_network_wireless_ssid_traffic_shaping_rules);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkWirelessSsidTrafficShapingRules'
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidTrafficShapingRules $update_network_wireless_ssid_traffic_shaping_rules (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateNetworkWirelessSsidTrafficShapingRulesRequest($network_id, $number, $update_network_wireless_ssid_traffic_shaping_rules = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkWirelessSsidTrafficShapingRules'
            );
        }
        // verify the required parameter 'number' is set
        if ($number === null || (is_array($number) && count($number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling updateNetworkWirelessSsidTrafficShapingRules'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/ssids/{number}/trafficShaping/rules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($number !== null) {
            $resourcePath = str_replace(
                '{' . 'number' . '}',
                ObjectSerializer::toPathValue($number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($update_network_wireless_ssid_traffic_shaping_rules)) {
            $_tempBody = $update_network_wireless_ssid_traffic_shaping_rules;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateNetworkWirelessSsidVpn
     *
     * Update the VPN settings for the SSID
     *
     * @param  string $network_id network_id (required)
     * @param  string $number number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidVpn $update_network_wireless_ssid_vpn update_network_wireless_ssid_vpn (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateNetworkWirelessSsidVpn($network_id, $number, $update_network_wireless_ssid_vpn = null)
    {
        list($response) = $this->updateNetworkWirelessSsidVpnWithHttpInfo($network_id, $number, $update_network_wireless_ssid_vpn);
        return $response;
    }

    /**
     * Operation updateNetworkWirelessSsidVpnWithHttpInfo
     *
     * Update the VPN settings for the SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidVpn $update_network_wireless_ssid_vpn (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateNetworkWirelessSsidVpnWithHttpInfo($network_id, $number, $update_network_wireless_ssid_vpn = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessSsidVpnRequest($network_id, $number, $update_network_wireless_ssid_vpn);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateNetworkWirelessSsidVpnAsync
     *
     * Update the VPN settings for the SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidVpn $update_network_wireless_ssid_vpn (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessSsidVpnAsync($network_id, $number, $update_network_wireless_ssid_vpn = null)
    {
        return $this->updateNetworkWirelessSsidVpnAsyncWithHttpInfo($network_id, $number, $update_network_wireless_ssid_vpn)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateNetworkWirelessSsidVpnAsyncWithHttpInfo
     *
     * Update the VPN settings for the SSID
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidVpn $update_network_wireless_ssid_vpn (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateNetworkWirelessSsidVpnAsyncWithHttpInfo($network_id, $number, $update_network_wireless_ssid_vpn = null)
    {
        $returnType = 'object';
        $request = $this->updateNetworkWirelessSsidVpnRequest($network_id, $number, $update_network_wireless_ssid_vpn);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateNetworkWirelessSsidVpn'
     *
     * @param  string $network_id (required)
     * @param  string $number (required)
     * @param  \Swagger\Client\Model\UpdateNetworkWirelessSsidVpn $update_network_wireless_ssid_vpn (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateNetworkWirelessSsidVpnRequest($network_id, $number, $update_network_wireless_ssid_vpn = null)
    {
        // verify the required parameter 'network_id' is set
        if ($network_id === null || (is_array($network_id) && count($network_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $network_id when calling updateNetworkWirelessSsidVpn'
            );
        }
        // verify the required parameter 'number' is set
        if ($number === null || (is_array($number) && count($number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $number when calling updateNetworkWirelessSsidVpn'
            );
        }

        $resourcePath = '/networks/{networkId}/wireless/ssids/{number}/vpn';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($network_id !== null) {
            $resourcePath = str_replace(
                '{' . 'networkId' . '}',
                ObjectSerializer::toPathValue($network_id),
                $resourcePath
            );
        }
        // path params
        if ($number !== null) {
            $resourcePath = str_replace(
                '{' . 'number' . '}',
                ObjectSerializer::toPathValue($number),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($update_network_wireless_ssid_vpn)) {
            $_tempBody = $update_network_wireless_ssid_vpn;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-Cisco-Meraki-API-Key');
        if ($apiKey !== null) {
            $headers['X-Cisco-Meraki-API-Key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
